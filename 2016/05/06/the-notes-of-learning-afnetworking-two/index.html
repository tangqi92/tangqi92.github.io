<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> AFNetworking 3.0 源码阅读笔记（二） · Qi Tang's Blog</title><meta name="description" content="AFNetworking 3.0 源码阅读笔记（二） - Qi Tang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://imtangqi.com/atom.xml" title="Qi Tang's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/logo.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/qiktang" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/tangqi92" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">AFNetworking 3.0 源码阅读笔记（二）</h1><div class="post-info">May 6, 2016</div><div class="post-content"><h2 id="前言">前言</h2><p>首先，我们来看一下 AFNetworking 框架中主要涉及到了哪些类：</p>
<p><strong>NSURLSession</strong></p>
<ul>
<li><code>AFURLSessionManager</code></li>
<li><code>AFHTTPSessionManager</code></li>
</ul>
<a id="more"></a>
<p><strong>序列化</strong></p>
<ul>
<li><code>AFURLRequestSerialization</code></li>
<li><code>AFURLResponseSerialization</code></li>
</ul>
<p><strong>附加功能</strong></p>
<ul>
<li><code>AFSecurityPolicy</code></li>
<li><code>AFNetworkReachabilityManager</code></li>
</ul>
<!-- more -->
<p>下面，通过一张图来直观地感受下 AF 架构的设计：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-afnetworking-two-01.png" alt=""></p>
<hr>
<h2 id="AFHTTPSessionManager">AFHTTPSessionManager</h2><blockquote>
<p><code>AFHTTPSessionManager</code> is a subclass of <code>AFURLSessionManager</code> with convenience methods for making HTTP requests. When a <code>baseURL</code> is provided, requests made with the <code>GET</code> / <code>POST</code> / et al. convenience methods can be made with relative paths.</p>
</blockquote>
<p>一句话总结：<code>AFHTTPSessionManager</code> 继承于 <code>AFURLSessionManager</code>，并提供了方便的 HTTP 请求方法。</p>
<p>下面，我们通过一段实际代码来感受下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://api.app.net/"</span>]];</span><br><span class="line">[sessionManager GET:<span class="string">@"stream/0/posts/stream/global"</span> parameters:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nonnull responseObject) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"请求成功---%@"</span>, responseObject);</span><br><span class="line">    &#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"请求失败---%@"</span>, error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>通过上面短短几行代码，我们便完成了 GET 请求，有木有很简单！现在是不是很想知道其背后蕴藏的玄机呢？别急，下面就让我们一起来探一探究竟。</p>
<hr>
<h2 id="调用栈">调用栈</h2><h3 id="initWithBaseURL:">initWithBaseURL:</h3><p>首先，我们来探一探 <code>AFHTTPSessionManager</code> 初始化方法 <code>- initWithBaseURL:</code> 的调用栈：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://api.app.net/"</span>]];</span><br></pre></td></tr></table></figure>
<p>我们一路「Command + 左键」，可以归纳出如下结果：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- [AFHTTPSessionManager initWithBaseURL:]</span><br><span class="line">    - [AFHTTPSessionManager initWithBaseURL:sessionConfiguration:]</span><br><span class="line">        - [AFURLSessionManager initWithSessionConfiguration:]</span><br><span class="line">            - [<span class="built_in">NSURLSession</span> sessionWithConfiguration:delegate:delegateQueue:]</span><br><span class="line">            - [AFJSONResponseSerializer serializer] <span class="comment">// 负责序列化响应</span></span><br><span class="line">            - [AFSecurityPolicy defaultPolicy] <span class="comment">// 负责身份认证</span></span><br><span class="line">            - [AFNetworkReachabilityManager sharedManager] <span class="comment">// 查看网络连接情况</span></span><br><span class="line">        - [AFHTTPRequestSerializer serializer] <span class="comment">// 负责序列化请求</span></span><br><span class="line">        - [AFJSONResponseSerializer serializer] <span class="comment">// 负责序列化响应</span></span><br></pre></td></tr></table></figure>
<p>从这个初始化方法的调用栈，我们可以非常清晰地了解这个框架的结构：</p>
<ul>
<li>其中 <code>AFURLSessionManager</code> 是 <code>AFHTTPSessionManager</code> 的父类</li>
<li><code>AFURLSessionManager</code> 负责生成 <code>NSURLSession</code> 的实例，管理 <code>AFSecurityPolicy</code> 和 <code>AFNetworkReachabilityManager</code>，来保证请求的安全和查看网络连接情况，它有一个 <code>AFJSONResponseSerializer</code> 的实例来序列化 HTTP 响应</li>
<li><code>AFHTTPSessionManager</code> 有着<strong>自己的</strong> <code>AFHTTPRequestSerializer</code> 和 <code>AFJSONResponseSerializer</code> 来管理请求和响应的序列化，同时<strong>依赖父类提供的接口</strong>保证安全、监控网络状态，实现发出 HTTP 请求这一核心功能</li>
</ul>
<h4 id="baseURL">baseURL</h4><p>关于 <code>baseURL</code> 一开始我是有点迷糊的，不过源代码中有如下注释：</p>
<blockquote>
<p>For HTTP convenience methods, the request serializer constructs URLs from the path relative to the <code>-baseURL</code>, using <code>NSURL +URLWithString:relativeToURL:</code>, when provided. If <code>baseURL</code> is <code>nil</code>, <code>path</code> needs to resolve to a valid <code>NSURL</code> object using <code>NSURL +URLWithString:</code>.</p>
</blockquote>
<p>并举例进行了说明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *baseURL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/v1/"</span>];</span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"foo"</span> relativeToURL:baseURL];                  <span class="comment">// http://example.com/v1/foo</span></span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"foo?bar=baz"</span> relativeToURL:baseURL];          <span class="comment">// http://example.com/v1/foo?bar=baz</span></span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"/foo"</span> relativeToURL:baseURL];                 <span class="comment">// http://example.com/foo</span></span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"foo/"</span> relativeToURL:baseURL];                 <span class="comment">// http://example.com/v1/foo</span></span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"/foo/"</span> relativeToURL:baseURL];                <span class="comment">// http://example.com/foo/</span></span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example2.com/"</span> relativeToURL:baseURL]; <span class="comment">// http://example2.com/</span></span><br></pre></td></tr></table></figure>
<p>所以，<code>baseURL</code> 为访问的基路径如：<a href="https://api.app.net/，" target="_blank" rel="external">https://api.app.net/，</a> path 是跟在基路径之后的部分路径，如：stream/0/posts/stream/global（因为 AFNetworking 的访问方式才这样划分）。</p>
<h3 id="GET:parameters:process:success:failure:">GET:parameters:process:success:failure:</h3><p>初始化方法很好地揭示了 AFNetworking 整个框架的架构，接下来我们要通过分析另一个方法 <code>- GET:parameters:process:success:failure:</code> 的调用栈，看一下 HTTP 请求是如何发出的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- [AFHTTPSessionManager GET:parameters:process:success:failure:]</span><br><span class="line">    - [AFHTTPSessionManager dataTaskWithHTTPMethod:parameters:uploadProgress:downloadProgress:success:failure:] <span class="comment">// 返回 NSURLSessionDataTask #1</span></span><br><span class="line">        - [AFHTTPRequestSerializer requestWithMethod:URLString:parameters:error:] <span class="comment">// 返回 NSMutableURLRequest</span></span><br><span class="line">        - [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] <span class="comment">// 返回 NSURLSessionDataTask #2</span></span><br><span class="line">            - [<span class="built_in">NSURLSession</span> dataTaskWithRequest:] <span class="comment">// 返回 NSURLSessionDataTask #3</span></span><br><span class="line">            - [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</span><br><span class="line">                - [AFURLSessionManagerTaskDelegate init]</span><br><span class="line">                - [AFURLSessionManager setDelegate:forTask:]</span><br><span class="line">    - [<span class="built_in">NSURLSessionDataTask</span> resume]</span><br></pre></td></tr></table></figure>
<p>在这里 <code>#1</code> <code>#2</code> <code>#3</code> 处返回的是同一个 data task，我们可以看到，在 <code>#3</code> 处调用的方法 <code>- [NSURLSession dataTaskWithRequest:]</code> 和只使用 <code>NSURLSession</code> 发出 HTTP 请求时调用的方法 <code>- [NSURLSession dataTaskWithRequest:completionHandler:]</code> 差不多。在这个地方返回 data task 之后，我们再调用 <code>- resume</code> 方法执行请求，并在某些事件执行时通知代理 <code>AFURLSessionManagerTaskDelegate</code>。</p>
<p>我们在第一篇文章中已经说明过，AFNetworking 3.0 既是在 <code>NSURLSession</code> 之上的高度封装，并提供更加简洁易用的 API。从调用栈的结果来看，将使我们的理解更加清晰。</p>
<hr>
<h2 id="循环引用">循环引用</h2><p>关于在使用 AFNetworking 的过程中出现循环引用的问题，我并没有在实际开发中遇到过（其实我丫的根本就没写过几行代码好嘛（ ＴДＴ）），我是在浏览相关文章时发现这个问题的，所以在此提及一下：</p>
<ul>
<li><a href="https://github.com/AFNetworking/AFNetworking/issues/2149#issuecomment-46842747" target="_blank" rel="external">AFHTTPSessionManager subclass not deallocating - retain cycle?</a></li>
<li><a href="https://github.com/AFNetworking/AFNetworking/issues/3116" target="_blank" rel="external">AFHTTPSessionManager and AFURLSessionManager never deallocated</a></li>
<li><a href="https://github.com/AFNetworking/AFNetworking/issues/2767" target="_blank" rel="external">block retain cycle in AFUrLSessionManager init method</a></li>
</ul>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/AFNetworking/AFNetworking%20%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89.md" target="_blank" rel="external">AFNetworking 概述（一）</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2016/05/09/the-notes-of-learning-afnetworking-three/" class="prev">上一篇</a><a href="/2016/05/05/the-notes-of-learning-afnetworking-one/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'tangqi92githubio';
var disqus_identifier = '2016/05/06/the-notes-of-learning-afnetworking-two/';
var disqus_title = 'AFNetworking 3.0 源码阅读笔记（二）';
var disqus_url = 'http://imtangqi.com/2016/05/06/the-notes-of-learning-afnetworking-two/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//tangqi92githubio.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://imtangqi.com">Qi Tang</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-61827851-1",'auto');ga('send','pageview');</script></body></html>