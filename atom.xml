<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Qi Tang's Blog]]></title>
  <subtitle><![CDATA[你不能把这个世界，让给你所鄙视的人]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://itangqi.me/"/>
  <updated>2017-03-22T12:28:45.000Z</updated>
  <id>http://itangqi.me/</id>
  
  <author>
    <name><![CDATA[Qi Tang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[ReactiveCocoa 知识点整理]]></title>
    <link href="http://itangqi.me/2017/03/22/the-notes-of-learning-reactivecocoa/"/>
    <id>http://itangqi.me/2017/03/22/the-notes-of-learning-reactivecocoa/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-03-22T12:28:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>本文仅作为个人对于 <code>ReactiveCocoa</code> 学习与使用的总结，文章绝大部分内容来自网络，详情请见参考链接。</p>
</blockquote>
<p>Last updated on 2017.03.22</p>
<a id="more"></a> 
<hr>
<h2 id="FRP_思想">FRP 思想</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = a + b <span class="comment">// c is 4</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line"><span class="comment">// now what is the value of c?</span></span><br></pre></td></tr></table></figure>
<p>简单来讲，FRP 是基于异步事件流进行编程的一种编程范式。针对离散事件序列进行有效的封装，利用函数式编程的思想，满足响应式编程的需要。</p>
<hr>
<h2 id="ReactiveCocoa_常见类">ReactiveCocoa 常见类</h2><h3 id="信号源相关">信号源相关</h3><h4 id="RACStream">RACStream</h4><blockquote>
<p>An abstract class representing any stream of values.</p>
</blockquote>
<p><code>RACStream</code> 是一个抽象类，是以 <code>Monad</code>（函数式编程语言）的概念为依据进行设计的，它代表的就是一个 <code>Monad</code>。有了 <code>Monad</code> 作为基石后，许多基于流的操作就可以被建立起来了，比如 <code>map</code> 、<code>filter</code> 、<code>zip</code> 等。 </p>
<h4 id="RACSignal">RACSignal</h4><p>可以把信号想象成水龙头，只不过里面不是水，而是玻璃球（value），直径跟水管的内径一样，这样就能保证玻璃球是依次排列，不会出现并排的情况（数据都是线性处理的，不会出现并发情况）。水龙头的开关默认是关的，除非有了接收方（subscriber），才会打开。这样只要有新的玻璃球进来，就会自动传送给接收方。可以在水龙头上加一个过滤嘴（filter），不符合的不让通过，也可以加一个改动装置，把球改变成符合自己的需求（map）。也可以把多个水龙头合并成一个新的水龙头（combineLatest:reduce:），这样只要其中的一个水龙头有玻璃球出来，这个新合并的水龙头就会得到这个球。</p>
<p><code>RACSignal</code> 代表的是将来会被传递的值，它是一种 <code>push-driven</code> 的流。<code>RACSignal</code> 可以向订阅者发送三种不同类型的事件：</p>
<ul>
<li><code>next</code> ：<code>RACSignal</code> 通过 <code>next</code> 事件向订阅者传送新的值，并且这个值可以为 <code>nil</code>；</li>
<li><code>error</code> ：<code>RACSignal</code> 通过 <code>error</code> 事件向订阅者表明信号在正常结束前发生了错误；</li>
<li><code>completed</code> ：<code>RACSignal</code> 通过 <code>completed</code> 事件向订阅者表明信号已经正常结束，不会再有后续的值传送给订阅者。</li>
</ul>
<p>注意，<code>ReactiveCocoa</code> 中的值流只包含正常的值，即通过 <code>next</code> 事件传送的值，并不包括 <code>error</code> 和 <code>completed</code> 事件，它们需要被特殊处理。通常情况下，一个信号的生命周期是由任意个 <code>next</code> 事件和一个 <code>error</code> 事件或一个 <code>completed</code> 事件组成的。</p>
<p><code>RACSignal</code> 的 <code>Subscription</code> 过程概括起来可以分为三个步骤：</p>
<ol>
<li>[RACSignal createSignal] 来获得 signal</li>
<li>[signal subscribeNext:] 来获得 subscriber，然后进行subscription</li>
<li>进入 didSubscribe ，通过 [subscriber sendNext:] 来执行 next block 。</li>
</ol>
<h4 id="RACSubject">RACSubject</h4><p><code>RACSubject</code> 代表的是可以手动控制的信号，我们可以把它看作是 <code>RACSignal</code> 的可变版本，就好比 <code>NSMutableArray</code> 是 <code>NSArray</code> 的可变版本一样。<code>RACSubject</code> 继承自 <code>RACSignal</code> ，所以它可以作为信号源被订阅者订阅，同时，它又实现了 <code>RACSubscriber</code> 协议，所以它也可以作为订阅者订阅其他信号源，这个就是 <code>RACSubject</code> 为什么可以手动控制的原因。</p>
<p>实际使用中，在 <code>MVVM</code> 中使用 <code>RACSubject</code> 可以非常方便地实现统一的错误处理逻辑。比如，我们可以在 <code>viewModel</code> 的基类中声明一个 <code>RACSubject</code> 类型的属性 <code>errors</code> ，然后在 <code>viewController</code> 的基类中编写统一的错误处理逻辑：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span><span class="variable">.viewModel</span><span class="variable">.errors</span> subscribeNext:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// 错误处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RACCommand">RACCommand</h4><blockquote>
<p>A command is a signal triggered in response to some action, typically UI-related.</p>
</blockquote>
<p><code>RACCommand</code> 通常用来表示某个 <code>Action</code> 的执行，比如点击<code>Button</code>。它有几个比较重要的属性：executionSignals / errors / executing。</p>
<ul>
<li><code>executionSignals</code> ：是 signal of signals ，如果直接 subscribe 的话会得到一个 signal ，而不是我们想要的 value，所以一般会配合 <code>switchToLatest</code> 。</li>
<li><code>errors</code> ：跟正常的 signal 不一样，RACCommand 的错误不是通过 sendError 来实现的，而是通过 errors 属性传递出来的。</li>
<li><code>executing</code> ：表示该 command 当前是否正在执行。</li>
</ul>
<h4 id="RACSequence">RACSequence</h4><blockquote>
<p>Represents an immutable sequence of values. Unless otherwise specified, the sequences’ values are evaluated lazily on demand. Like Cocoa collections, sequences cannot contain nil.</p>
</blockquote>
<p><code>RACSequence</code> 代表的是一个不可变的值的序列，与 <code>RACSignal</code> 不同，它是 <code>pull-driven</code> 类型的流。从严格意义上讲，<code>RACSequence</code> 并不能算作是信号源，因为它并不能像 <code>RACSignal</code> 那样，可以被订阅者订阅，但是它与 <code>RACSignal</code> 之间可以非常方便地进行转换。</p>
<p>因此，我们可以非常方便地使用 <code>RACSequence</code> 来实现集合的链式操作，直到得到你想要的最终结果为止，常用的使用场景为「字典转模型」。</p>
<p><strong>注意</strong>：<code>RACSequence</code> 会涉及到性能与效率的问题。</p>
<h3 id="订阅者相关">订阅者相关</h3><h4 id="RACSubscriber">RACSubscriber</h4><blockquote>
<p>Represents any object which can directly receive values from a RACSignal.</p>
</blockquote>
<p>订阅者对信号源的一次订阅过程可以抽象为：通过 <code>RACSignal</code> 的 <code>-subscribe:</code> 方法传入一个订阅者，并最终返回一个 <code>RACDisposable</code> 对象的过程。</p>
<p><strong>注意</strong>：在 <code>ReactiveCocoa</code> 中并没有专门的类 <code>RACSubscription</code> 来代表一次订阅，而间接地使用 <code>RACDisposable</code> 来充当这一角色。因此，一个 <code>RACDisposable</code> 对象就代表着一次订阅，并且我们可以用它来取消这次订阅。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))nextBlock &#123;</span><br><span class="line">true<span class="built_in">NSCParameterAssert</span>(nextBlock != <span class="literal">NULL</span>);</span><br><span class="line">true</span><br><span class="line">trueRACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:<span class="literal">NULL</span> completed:<span class="literal">NULL</span>];</span><br><span class="line">true<span class="keyword">return</span> [<span class="keyword">self</span> subscribe:o];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)subscriberWithNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))next error:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *error))error completed:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completed &#123;</span><br><span class="line">trueRACSubscriber *subscriber = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line"></span><br><span class="line">truesubscriber-&gt;_next = [next <span class="keyword">copy</span>];</span><br><span class="line">truesubscriber-&gt;_error = [error <span class="keyword">copy</span>];</span><br><span class="line">truesubscriber-&gt;_completed = [completed <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">true<span class="keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">true<span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"This method must be overridden by subclasses"</span>);</span><br><span class="line">true<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调度器相关">调度器相关</h3><h4 id="RACScheduler">RACScheduler</h4><blockquote>
<p>Schedulers are used to control when and where work is performed.</p>
</blockquote>
<p><code>RACScheduler</code> 在 <code>ReactiveCocoa</code> 中就是扮演着调度器的角色，本质上，它就是用 <code>GCD</code> 的串行队列来实现的，并且支持取消操作。是的，在 <code>ReactiveCocoa</code> 中，并没有使用到 <code>NSOperationQueue</code> 和 <code>NSRunloop</code> 等技术，<code>RACScheduler</code> 也只是对 <code>GCD</code> 的简单封装而已。</p>
<h3 id="清洁工相关">清洁工相关</h3><h4 id="RACDisposable">RACDisposable</h4><blockquote>
<p>A disposable encapsulates the work necessary to tear down and cleanup a subscription.</p>
</blockquote>
<p><code>RACDisposable</code> 在 <code>ReactiveCocoa</code> 中就充当着清洁工的角色，它封装了取消和清理一次订阅所必需的工作。它有一个核心的方法 <code>-dispose</code> ，调用这个方法就会执行相应的清理工作，这有点类似于 <code>NSObject</code> 的 <code>-dealloc</code> 方法。</p>
<hr>
<h2 id="ReactiveCocoa_常见用法">ReactiveCocoa 常见用法</h2><h3 id="代替代理">代替代理</h3><ul>
<li><code>rac_signalForSelector</code> 用户代替代理</li>
</ul>
<h3 id="代替_KVO">代替 KVO</h3><ul>
<li><code>rac_valuesAndChangesForKeyPath</code> 用于监听某个对象的某个属性的改变</li>
</ul>
<h3 id="代替事件监听">代替事件监听</h3><ul>
<li><code>rac_signalForControlEvents</code> 用于监听某个事件</li>
</ul>
<h3 id="代替通知">代替通知</h3><ul>
<li><code>rac_addObserverForName</code> 用于监听某个通知，且不需要在 <code>- (void)dealloc</code> 中移除监听</li>
</ul>
<h3 id="监听文本框文字改变">监听文本框文字改变</h3><ul>
<li><code>rac_textSignal</code> 用于监听文本框文字变化</li>
</ul>
<h3 id="代替手势">代替手势</h3><ul>
<li><code>rac_gestureSignal</code>用于监听手势操作</li>
</ul>
<h3 id="多个请求完成时，再执行后继操作">多个请求完成时，再执行后继操作</h3><ul>
<li><code>rac_liftSelector:withSignalsFromArray:Signals</code> 当传入的 Signals，每一个 Signal 都至少 sendNext 过一次，就会去触发第一个 selector 参数的方法。</li>
</ul>
<h3 id="信号的相关操作">信号的相关操作</h3><ul>
<li><code>bind</code> ：函数会返回一个新的信号 N。整体思路是对原信号 O 进行订阅，每当信号 O 产生一个值就将其转变成一个中间信号 M ，并马上订阅 M ，之后将信号M的输出作为新信号 N 的输出。</li>
<li><code>map</code> \ <code>flattenMap</code> ：用于把源信号内容映射成新的内容（信号）。</li>
<li><code>concat</code> ：组合，按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号。</li>
<li><code>then</code> ：用于连接两个信号，当第一个信号完成，才会连接 <code>then</code> 返回的信号。</li>
<li><code>merge</code> ：把多个信号合并为一个信号，任何一个信号有新值的时候就会调用。</li>
<li><code>zipWith</code> ：把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的 <code>next</code> 事件。</li>
<li><code>combineLatest</code> ：将多个信号合并起来，并且拿到各个信号的最新的值，必须每个合并的 <code>signal</code> 至少都有过一次 <code>sendNext</code> ，才会触发合并的信号。</li>
<li><code>reduce</code> ：聚合，用于信号发出的内容是元组，把信号发出元组的值聚合成一个值。</li>
<li><code>filter</code> ：过滤信号，使用它可以获取满足条件的信号。</li>
<li><code>ignore</code> ：忽略某些值的信号，使用 <code>RACObserve</code> 时可配合使用，其实现由 <code>filter</code> 完成。</li>
<li><code>distinctUntilChanged</code> ：实现是用 <code>bind</code> 来完成的，每次变换中都记录一下原信号上一次发送过来的值，并与这一次进行比较，如果是相同的值，就「吞」掉，返回 empty 信号。只有和原信号上一次发送的值不同，变换后的新信号才把这个值发送出来。</li>
<li><code>take</code> ：从开始一共取 N 次的信号。</li>
<li><code>takeLast</code> ：取最后 N 次的信号，前提条件：订阅者必须调用完成，因为只有完成，才知道总共有多少信号。</li>
<li><code>takeUntil</code> ：获取信号直到某个信号执行完成。</li>
<li><code>skip</code> ：跳过几个信号，不接受。</li>
<li><code>switchToLatest</code> ：用于 <code>signalOfSignals</code>（信号的信号），有时候信号也会发出信号，会在 <code>signalOfSignals</code> 中，获取 <code>signalOfSignals</code> 发送的最新信号。</li>
<li><code>doNext</code> ：执行 <code>next</code> 之前，会先执行这个 Block 。</li>
<li><code>doCompleted</code> ：执行 <code>sendCompleted</code> 之前，会先执行这个Block 。</li>
<li><code>timeout</code> ：超时，可以让一个信号在一定的时间后，自动报错。</li>
<li><code>interval</code> ：定时：每隔一段时间发出信号。</li>
<li><code>delay</code> ：延迟发送 <code>next</code> 。</li>
<li><code>retry</code> ：重试，只要失败，就会重新执行创建信号中的 block ，直到成功。</li>
<li><code>replay</code> ：重放，当一个信号被多次订阅，反复播放内容。</li>
<li><code>throttle</code> ：节流，当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</li>
</ul>
<hr>
<h2 id="ReactiveCocoa_常见宏">ReactiveCocoa 常见宏</h2><ul>
<li><code>RAC(TARGET, ...)</code> 用于绑定某个对象的某个属性</li>
<li><code>RACObserve(TARGET, KEYPATH)</code> 用于监听某个对象的某个属性，返回的是信号</li>
<li><code>@weakify(Obj)</code> &amp; <code>@strongify(Obj)</code> 配套使用</li>
</ul>
<hr>
<h2 id="注意事项">注意事项</h2><h3 id="Side_Effect">Side Effect</h3><blockquote>
<p>Side effects occur for each subscription by default, but there are certain situations where side effects should only occur once – for example, a network request typically should not be repeated when a new subscriber is added.</p>
</blockquote>
<p>如果某个信号被多个 <code>subscriber</code> 订阅，那么它的 <code>didSubscribe</code> 会被多次调用。</p>
<p>如果想要避免这种情况的发生，可以使用 <code>reply</code> / <code>replayLast</code> / <code>replayLazily</code> 方法，它们的作用是保证 <code>signal</code> 只被触发一次，然后把 <code>sendNext:</code> 的 <code>value</code> 给缓存起来，下一次再有新的 <code>subscriber</code> 时，直接发送缓存的 <code>value</code> 。</p>
<p>其内部实现依赖：<code>- (RACMulticastConnection *)multicast:(RACSubject *)subject;</code> 这个方法。</p>
<h3 id="Cell_重用">Cell 重用</h3><p>RAC 给 <code>UITableViewCell</code> 提供了一个方法： <code>rac_prepareForReuseSignal</code> ，它的作用是当 Cell 即将要被重用时，告诉 Cell 。想象 Cell 上有多个 <code>Button</code> ，Cell 在初始化时给每个 Button 都 <code>addTarget:action:forControlEvents</code> ，被重用时需要先移除这些 target ，下面这段代码就可以很方便地解决这个问题：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[[<span class="keyword">self</span><span class="variable">.cancelButton</span></span><br><span class="line">truerac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>]</span><br><span class="line">truetakeUntil:<span class="keyword">self</span><span class="variable">.rac_prepareForReuseSignal</span>]</span><br><span class="line">truesubscribeNext:^(<span class="built_in">UIButton</span> *x) &#123;</span><br><span class="line">true<span class="comment">// do other things</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="Strong_/_Weak_Dance">Strong / Weak Dance</h3><p>因为 RAC 很多操作都是在 <code>Block</code> 中进行的，所以最常见的问题便是「循环引用」，所以需要通过 <code>@weakify</code> 和 <code>@strongify</code> 来消除循环引用。</p>
<p>注意：事实上 <code>RACObserve(TARGET, KEYPATH)</code> 总是会引用 <code>self</code> ，即使 target 不是 self ，所以只要有 RACObserve 的地方都要使用 <code>@weakify</code> / <code>@strongify</code> 。</p>
<h3 id="flattenMap_与_map_的区别">flattenMap 与 map 的区别</h3><ul>
<li><code>flattenMap</code> 中的 block 返回信号。</li>
<li><code>map</code> 中的 block 返回对象。</li>
<li><code>map</code> 的实现是用了 <code>flattenMap</code> 函数来实现的。把 <code>map</code> 的入参闭包，放到了 <code>flattenMap</code> 的返回值中。</li>
<li>开发中，如果信号发出的值不是信号，映射一般使用 <code>map</code> 。</li>
<li>开发中，如果信号发出的值是信号，映射一般使用 <code>flattenMap</code> 。</li>
<li><code>signalOfsignals</code> 用 <code>flattenMap</code> 。</li>
</ul>
<h3 id="冷信号与热信号的区别">冷信号与热信号的区别</h3><ul>
<li>Hot Observable 是主动的，尽管你并没有订阅事件，但是它会时刻推送，就像鼠标移动；而 Cold Observable 是被动的，只有当你订阅的时候，它才会发布消息。</li>
<li>Hot Observable 可以有多个订阅者，是一对多，集合可以与订阅者共享信息；而 Cold Observable 只能一对一，当有不同的订阅者，消息是重新完整发送。</li>
<li><code>Subject</code> 类似「直播」，错过了就不再处理。而 <code>Signal</code> 类似「点播」。</li>
<li><code>RACSubject</code> 及其子类是热信号，<code>RACSignal</code> 排除 <code>RACSubject</code> 类以外的是冷信号。</li>
<li><code>RACSubject</code> 会持有订阅者（因为 <code>RACSubject</code> 是热信号，为了保证未来有事件发送的时候，订阅者可以收到信息，所以需要对订阅者保持状态，做法就是持有订阅者），而 <code>RACSignal</code> 不会持有订阅者。</li>
</ul>
<h3 id="其他">其他</h3><ul>
<li><p>当一个 <code>signal</code> 被一个 <code>subscriber</code> subscribe 后，这个 <code>subscriber</code> 何时会被移除？答案是：当 <code>subscriber</code> 被 <code>sendComplete</code> 或 <code>sendError</code> 时，或者手动调用 <code>[disposable dispose]</code> 。</p>
</li>
<li><p><code>replay</code> 是 <code>multicast</code> 的一个特殊 case 而已。</p>
</li>
<li><p>当 <code>subscriber</code> 被 <code>dispose</code> 后，所有该 <code>subscriber</code> 相关的工作都会被停止或取消，如 http 请求，资源也会被释放。</p>
</li>
<li><p><code>Errors</code> 有优先权，如果有多个 <code>signals</code> 被同时监听，只要其中一个 signal <code>sendError</code>，那么 error 就会立刻被传送给 subscriber ，并导致 signals 终止执行。相当于<code>Exception</code> 。</p>
</li>
<li><p>使用 <code>RACSubject</code> ，如果进行了 <code>map</code> 操作，那么一定要发送完成信号，不然会内存泄漏。</p>
</li>
<li><p>任何的信号转换即是对原有的信号进行订阅从而产生新的信号。</p>
</li>
</ul>
<hr>
<h2 id="系列文章">系列文章</h2><ol>
<li><a href="http://tech.meituan.com/tag/ReactiveCocoa" target="_blank" rel="external">美团点评技术团队</a></li>
<li><a href="http://www.jianshu.com/p/d7d951a99db8" target="_blank" rel="external">一缕殇流化隐半边冰霜</a></li>
<li><a href="http://draveness.me/racsignal/" target="_blank" rel="external">Draveness</a></li>
</ol>
<hr>
<h2 id="参考链接">参考链接</h2><ol>
<li><a href="http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/" target="_blank" rel="external">ReactiveCocoa v2.5 源码解析之架构总览</a></li>
<li><a href="http://limboy.me/tech/2014/06/06/deep-into-reactivecocoa2.html" target="_blank" rel="external">ReactiveCocoa2实战</a></li>
<li><a href="http://limboy.me/tech/2013/12/27/reactivecocoa-2.html" target="_blank" rel="external">说说ReactiveCocoa 2</a></li>
<li><a href="https://github.com/ming1016/study/wiki/iOS%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%BB%A5%E5%8F%8AReactiveCocoa%E7%9A%84%E4%BD%BF%E7%94%A8" target="_blank" rel="external">iOS函数响应式编程以及ReactiveCocoa的使用</a></li>
<li><a href="http://www.jianshu.com/p/87ef6720a096" target="_blank" rel="external">最快让你上手ReactiveCocoa之基础篇</a></li>
<li><a href="http://www.jianshu.com/p/e10e5ca413b7" target="_blank" rel="external">最快让你上手ReactiveCocoa之进阶篇</a></li>
<li><a href="http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/" target="_blank" rel="external">ReactiveCocoa 讨论会</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>本文仅作为个人对于 <code>ReactiveCocoa</code> 学习与使用的总结，文章绝大部分内容来自网络，详情请见参考链接。</p>
</blockquote>
<p>Last updated on 2017.03.22</p>]]>
    
    </summary>
    
      <category term="FRP" scheme="http://itangqi.me/tags/FRP/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="ReactiveCocoa" scheme="http://itangqi.me/tags/ReactiveCocoa/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 屏幕旋转的那些事（二）]]></title>
    <link href="http://itangqi.me/2017/03/09/handle-orientation-changes-two/"/>
    <id>http://itangqi.me/2017/03/09/handle-orientation-changes-two/</id>
    <published>2017-03-08T16:00:00.000Z</published>
    <updated>2017-03-09T07:37:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在 <a href="http://itangqi.me/2017/03/09/handle-orientation-changes-one/">iOS 屏幕旋转的那些事（一）</a>一文中，整个实践的过程都比较顺利，但直到我遇到了 FLEX……</p>
<a id="more"></a>
<hr>
<h2 id="迷之_FLEX">迷之 FLEX</h2><p>如果你对 FLEX 还不了解，可参见：<a href="https://github.com/Flipboard/FLEX" target="_blank" rel="external">https://github.com/Flipboard/FLEX</a></p>
<p>由于在 iPad 版的某些页面，需要以 <a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/PresentingaViewController.html" target="_blank" rel="external">Modal View</a> 的形式展现，其中又涉及到横竖屏切换时，Modal View 的高度相应改变的问题，所以我需要获取到 Screen Width 与 Screen Height 的值。效果如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/handle-orientation-changes-04.png" alt=""></p>
<p>于是，我在 <code>- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator;</code> 中执行如下代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillTransitionToSize:(<span class="built_in">CGSize</span>)size withTransitionCoordinator:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinator</span>&gt;)coordinator &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillTransitionToSize:size withTransitionCoordinator:coordinator];</span><br><span class="line">    <span class="built_in">CGFloat</span> screenWidth = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> screenHeight = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你觉得此时 <code>screenWidth</code> 与 <code>screenHeight</code> 的值是屏幕旋转前还是旋转后的呢？</p>
<p>顺便说一句：iOS 7 之前 UIScreen 的 bounds 不会随着方向而变化，但是到了 iOS 8 以后，随着设备方向的旋转，<code>[UIScreen mainScreen].bounds.size.width</code> 和 <code>[UIScreen mainScreen].bounds.size.height</code> 也会相应发生变化。具体请参见: <a href="http://stackoverflow.com/questions/24150359/is-uiscreen-mainscreen-bounds-size-becoming-orientation-dependent-in-ios8" target="_blank" rel="external">Is [UIScreen mainScreen].bounds.size becoming orientation-dependent in iOS8?</a></p>
<p>最终经过测试后的答案是：<strong>要看 FLEX 使用声明语句的位置而定！</strong></p>
<p>FLEX 的使用非常简单，我们来看下 <code>AppDelegate.m</code> 中的 <code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(nullable NSDictionary *)launchOptions;</code> ：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.window</span> = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</span><br><span class="line"></span><br><span class="line">QTViewController *viewController = [[QTViewController alloc] init];</span><br><span class="line">viewController<span class="variable">.title</span> = <span class="string">@"QTViewController"</span>;</span><br><span class="line"><span class="built_in">UINavigationController</span> *navigationController = [[<span class="built_in">UINavigationController</span> alloc] initWithRootViewController:viewController];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此处及之前开启，则在 - (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator 中使用 [UIScreen mainScreen].bounds.size 获取的为旋转后的值。</span></span><br><span class="line">[[FLEXManager sharedManager] showExplorer];</span><br><span class="line"><span class="comment">// !!!:</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> = navigationController;</span><br><span class="line"><span class="comment">// 在此处及之后开启，则在 - (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator 中使用 [UIScreen mainScreen].bounds.size 获取的为旋转前的值。</span></span><br><span class="line">[[FLEXManager sharedManager] showExplorer];</span><br></pre></td></tr></table></figure>
<p>随后，我又改进了写法，进行进一步测试：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillTransitionToSize:(<span class="built_in">CGSize</span>)size withTransitionCoordinator:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinator</span>&gt;)coordinator &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillTransitionToSize:size withTransitionCoordinator:coordinator];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Before: %f"</span>, [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Before: %f"</span>, [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">    </span><br><span class="line">    [coordinator animateAlongsideTransition:^(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinatorContext</span>&gt; context) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"After: %f"</span>, [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"After: %f"</span>, [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">    &#125;</span><br><span class="line">                                 completion:^(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinatorContext</span>&gt; context)&#123;</span><br><span class="line">                                     </span><br><span class="line">                                 &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的测试结果为：</p>
<table>
<thead>
<tr>
<th>是否开启 FLEX</th>
<th style="text-align:center">位置</th>
<th style="text-align:center">Before 处的 Size</th>
<th style="text-align:center">After 处的 Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>否</td>
<td style="text-align:center"></td>
<td style="text-align:center">旋转前</td>
<td style="text-align:center">旋转后</td>
</tr>
<tr>
<td>是</td>
<td style="text-align:center">self.window.rootViewController = xxx 之后</td>
<td style="text-align:center">旋转前</td>
<td style="text-align:center">旋转后</td>
</tr>
<tr>
<td>是</td>
<td style="text-align:center">self.window.rootViewController = xxx 之前</td>
<td style="text-align:center"><strong>旋转后</strong></td>
<td style="text-align:center">旋转后</td>
</tr>
</tbody>
</table>
<p>所以，如果你真的需要在屏幕旋转时获取 Screen Size，请将操作放在 <code>After</code> 中，因为此时无论 FLEX 是否开启，也无论声明的位置，其都是获取到屏幕旋转之后的值。或将 FLEX 的使用声明语句放到 <code>self.window.rootViewController = xxx</code> 之后。</p>
<p>虽然已经可以解决问题了，但我仍有疑问，那就是「FLEX 到底做了什么，导致在 <code>self.window.rootViewController = xxx 之前</code> 声明，会改变 Before 处的 Size？」</p>
<p>于是，我们顺着 <code>[[FLEXManager sharedManager] showExplorer];</code> 查看源码中的调用顺序：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedManager</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> FLEXManager *sharedManager = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedManager = [[[<span class="keyword">self</span> class] alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)showExplorer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.explorerWindow</span><span class="variable">.hidden</span> = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (FLEXWindow *)explorerWindow</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="built_in">NSThread</span> isMainThread], <span class="string">@"You must use %@ from the main thread only."</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!_explorerWindow) &#123;</span><br><span class="line">        _explorerWindow = [[FLEXWindow alloc] initWithFrame:[[<span class="built_in">UIScreen</span> mainScreen] bounds]];</span><br><span class="line">        _explorerWindow<span class="variable">.eventDelegate</span> = <span class="keyword">self</span>;</span><br><span class="line">        _explorerWindow<span class="variable">.rootViewController</span> = <span class="keyword">self</span><span class="variable">.explorerViewController</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _explorerWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们来看下 <code>FLEXWindow</code> 是如何实现的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">        <span class="comment">// Some apps have windows at UIWindowLevelStatusBar + n.</span></span><br><span class="line">        <span class="comment">// If we make the window level too high, we block out UIAlertViews.</span></span><br><span class="line">        <span class="comment">// There's a balance between staying above the app's windows and staying below alerts.</span></span><br><span class="line">        <span class="comment">// UIWindowLevelStatusBar + 100 seems to hit that balance.</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.windowLevel</span> = <span class="built_in">UIWindowLevelStatusBar</span> + <span class="number">100.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> pointInside = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.eventDelegate</span> shouldHandleTouchAtPoint:point]) &#123;</span><br><span class="line">        pointInside = [<span class="keyword">super</span> pointInside:point withEvent:event];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pointInside;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)shouldAffectStatusBarAppearance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> isKeyWindow];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)canBecomeKeyWindow</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.eventDelegate</span> canBecomeKeyWindow];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This adds a method (superclass override) at runtime which gives us the status bar behavior we want.</span></span><br><span class="line">    <span class="comment">// The FLEX window is intended to be an overlay that generally doesn't affect the app underneath.</span></span><br><span class="line">    <span class="comment">// Most of the time, we want the app's main window(s) to be in control of status bar behavior.</span></span><br><span class="line">    <span class="comment">// Done at runtime with an obfuscated selector because it is private API. But you shoudn't ship this to the App Store anyways...</span></span><br><span class="line">    <span class="built_in">NSString</span> *canAffectSelectorString = [@[<span class="string">@"_can"</span>, <span class="string">@"Affect"</span>, <span class="string">@"Status"</span>, <span class="string">@"Bar"</span>, <span class="string">@"Appearance"</span>] componentsJoinedByString:<span class="string">@""</span>];</span><br><span class="line">    SEL canAffectSelector = <span class="built_in">NSSelectorFromString</span>(canAffectSelectorString);</span><br><span class="line">    Method shouldAffectMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(shouldAffectStatusBarAppearance));</span><br><span class="line">    IMP canAffectImplementation = method_getImplementation(shouldAffectMethod);</span><br><span class="line">    class_addMethod(<span class="keyword">self</span>, canAffectSelector, canAffectImplementation, method_getTypeEncoding(shouldAffectMethod));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// One more...</span></span><br><span class="line">    <span class="built_in">NSString</span> *canBecomeKeySelectorString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"_%@"</span>, <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(canBecomeKeyWindow))];</span><br><span class="line">    SEL canBecomeKeySelector = <span class="built_in">NSSelectorFromString</span>(canBecomeKeySelectorString);</span><br><span class="line">    Method canBecomeKeyMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(canBecomeKeyWindow));</span><br><span class="line">    IMP canBecomeKeyImplementation = method_getImplementation(canBecomeKeyMethod);</span><br><span class="line">    class_addMethod(<span class="keyword">self</span>, canBecomeKeySelector, canBecomeKeyImplementation, method_getTypeEncoding(canBecomeKeyMethod));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，也许你需要一点关于 <code>UIWindow</code> 的相关知识。简言之，就是将 <code>FLEXWindow</code> 置于整个 View Hierarchy 的最顶部，如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/handle-orientation-changes-03.png" alt=""><a href="http://www.jianshu.com/p/8bc4c5f4b19f" target="_blank" rel="external">图片来源</a></p>
<p>那 FLEX 又在屏幕旋转时做了哪些操作呢？首先我们需要了解下整体响应旋转变化的事件流程，简单来说如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIScreen</span> -&gt; <span class="built_in">UIWindow</span> -&gt; <span class="built_in">UIViewController</span> -&gt; ChildViewControllers -&gt; View -&gt; Subviews</span><br></pre></td></tr></table></figure>
<p>当发生屏幕旋转事件的时候，<code>UIApplication</code> 对象会将旋转事件传递给 <code>UIWindow</code>，<code>UIWindow</code> 本身并不处理旋转事件，而是将旋转事件传递给它的根控制器，由根控制器决定是否需要旋转及旋转操作。</p>
<p>最后，我们来看下 <code>FLEXExplorerViewController</code> 中关于 <code>Rotation</code> 的逻辑：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - Rotation</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)viewControllerForRotationAndOrientation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIWindow</span> *window = <span class="keyword">self</span><span class="variable">.previousKeyWindow</span> ?: [[<span class="built_in">UIApplication</span> sharedApplication] keyWindow];</span><br><span class="line">    <span class="built_in">UIViewController</span> *viewController = window<span class="variable">.rootViewController</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *viewControllerSelectorString = [@[<span class="string">@"_vie"</span>, <span class="string">@"wContro"</span>, <span class="string">@"llerFor"</span>, <span class="string">@"Supported"</span>, <span class="string">@"Interface"</span>, <span class="string">@"Orientations"</span>] componentsJoinedByString:<span class="string">@""</span>];</span><br><span class="line">    SEL viewControllerSelector = <span class="built_in">NSSelectorFromString</span>(viewControllerSelectorString);</span><br><span class="line">    <span class="keyword">if</span> ([viewController respondsToSelector:viewControllerSelector]) &#123;</span><br><span class="line"><span class="preprocessor">#pragma clang diagnostic push</span></span><br><span class="line"><span class="preprocessor">#pragma clang diagnostic ignored <span class="title">"-Warc-performSelector-leaks"</span></span></span><br><span class="line">        viewController = [viewController performSelector:viewControllerSelector];</span><br><span class="line"><span class="preprocessor">#pragma clang diagnostic pop</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> viewController;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIInterfaceOrientationMask</span>)supportedInterfaceOrientations</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIViewController</span> *viewControllerToAsk = [<span class="keyword">self</span> viewControllerForRotationAndOrientation];</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMask</span> supportedOrientations = [FLEXUtility infoPlistSupportedInterfaceOrientationsMask];</span><br><span class="line">    <span class="keyword">if</span> (viewControllerToAsk &amp;&amp; viewControllerToAsk != <span class="keyword">self</span>) &#123;</span><br><span class="line">        supportedOrientations = [viewControllerToAsk supportedInterfaceOrientations];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The UIViewController docs state that this method must not return zero.</span></span><br><span class="line">    <span class="comment">// If we weren't able to get a valid value for the supported interface orientations, default to all supported.</span></span><br><span class="line">    <span class="keyword">if</span> (supportedOrientations == <span class="number">0</span>) &#123;</span><br><span class="line">        supportedOrientations = <span class="built_in">UIInterfaceOrientationMaskAll</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> supportedOrientations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)shouldAutorotate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIViewController</span> *viewControllerToAsk = [<span class="keyword">self</span> viewControllerForRotationAndOrientation];</span><br><span class="line">    <span class="built_in">BOOL</span> shouldAutorotate = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (viewControllerToAsk &amp;&amp; viewControllerToAsk != <span class="keyword">self</span>) &#123;</span><br><span class="line">        shouldAutorotate = [viewControllerToAsk shouldAutorotate];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shouldAutorotate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willRotateToInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)toInterfaceOrientation duration:(<span class="built_in">NSTimeInterval</span>)duration</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *outlineView <span class="keyword">in</span> [<span class="keyword">self</span><span class="variable">.outlineViewsForVisibleViews</span> allValues]) &#123;</span><br><span class="line">        outlineView<span class="variable">.hidden</span> = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.selectedViewOverlay</span><span class="variable">.hidden</span> = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didRotateFromInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)fromInterfaceOrientation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *view <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.viewsAtTapPoint</span>) &#123;</span><br><span class="line">        <span class="built_in">NSValue</span> *key = [<span class="built_in">NSValue</span> valueWithNonretainedObject:view];</span><br><span class="line">        <span class="built_in">UIView</span> *outlineView = <span class="keyword">self</span><span class="variable">.outlineViewsForVisibleViews</span>[key];</span><br><span class="line">        outlineView<span class="variable">.frame</span> = [<span class="keyword">self</span> frameInLocalCoordinatesForView:view];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.currentMode</span> == FLEXExplorerModeSelect) &#123;</span><br><span class="line">            outlineView<span class="variable">.hidden</span> = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.selectedView</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.selectedViewOverlay</span><span class="variable">.frame</span> = [<span class="keyword">self</span> frameInLocalCoordinatesForView:<span class="keyword">self</span><span class="variable">.selectedView</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.selectedViewOverlay</span><span class="variable">.hidden</span> = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，到目前为止，仍然不能解决我的疑问（瞬间感觉自己弱爆了……）如果你正巧知道原因，欢迎给我留言：）</p>
<p>如果你想对 FLEX 有更深入的了解，可参见系列文章：<a href="http://www.jianshu.com/p/8bc4c5f4b19f" target="_blank" rel="external">FLEX 2.0源码分析（一）</a></p>
<hr>
<h2 id="One_More_Thing">One More Thing</h2><p>好啦，对于已经阅读到这部分的朋友，作为回报，送上两个 iPad 适配相关的 Tips：</p>
<ol>
<li><a href="http://stackoverflow.com/questions/14469251/uicollectionviewflowlayout-size-warning-when-rotating-device-to-landscape" target="_blank" rel="external">UICollectionViewFlowLayout Size Warning When Rotating Device to Landscape</a></li>
<li><a href="http://stackoverflow.com/questions/16518175/custom-size-for-modal-view-loaded-with-form-sheet-presentation" target="_blank" rel="external">Custom size for Modal View loaded with Form Sheet presentation</a></li>
</ol>
<hr>
<h2 id="参考&amp;推荐">参考&amp;推荐</h2><ol>
<li><a href="http://stackoverflow.com/questions/26069874/what-is-the-right-way-to-handle-orientation-changes-in-ios-8" target="_blank" rel="external">What is the “right” way to handle orientation changes in iOS 8?</a></li>
<li><a href="http://www.jianshu.com/p/db03da61cd2c" target="_blank" rel="external">详解iOS开发中处理屏幕旋转的几种方法</a></li>
<li><a href="http://www.jianshu.com/p/8bc4c5f4b19f" target="_blank" rel="external">FLEX 2.0源码分析（一）</a></li>
<li><a href="https://satanwoo.github.io/2016/09/17/uiwindow-iOS/" target="_blank" rel="external">浅谈iOS的多Window处理</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>在 <a href="http://itangqi.me/2017/03/09/handle-orientation-changes-one/">iOS 屏幕旋转的那些事（一）</a>一文中，整个实践的过程都比较顺利，但直到我遇到了 FLEX……</p>]]>
    
    </summary>
    
      <category term="FLEX" scheme="http://itangqi.me/tags/FLEX/"/>
    
      <category term="Orientation" scheme="http://itangqi.me/tags/Orientation/"/>
    
      <category term="Rotation" scheme="http://itangqi.me/tags/Rotation/"/>
    
      <category term="UIDevice" scheme="http://itangqi.me/tags/UIDevice/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 屏幕旋转的那些事（一）]]></title>
    <link href="http://itangqi.me/2017/03/08/handle-orientation-changes-one/"/>
    <id>http://itangqi.me/2017/03/08/handle-orientation-changes-one/</id>
    <published>2017-03-07T16:00:00.000Z</published>
    <updated>2017-03-09T05:07:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文将讨论的话题是：iOS 屏幕旋转的那些事，文中示例 Demo 请参见：<a href="https://github.com/tangqi92/QTHandleOrientationChanges.git" target="_blank" rel="external">https://github.com/tangqi92/QTHandleOrientationChanges.git</a>。</p>
<a id="more"></a>
<hr>
<h2 id="需求">需求</h2><p>在即将推出的<strong>花瓣 4.0</strong> 版本中我们增加了对 iPad 横屏的支持，因为在实践的过程中踩了些坑，所以在此作下总结，同时也希望能帮助到有需要的朋友们。</p>
<p>由于历史原因，项目是手撕 Frame 而不是 Storyboard 进行布局，也并没有使用 Auto Layout。</p>
<p>又由于历史原因，项目设置为 「Universal」以支持 iPad。虽然支持 iPad，不过仅支持竖屏，其实也就是个放大的 iPhone 版，体验效果不佳。这次花瓣 4.0 的改版，iPad 横屏的支持便是一重点改进点，效果可见下图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/handle-orientation-changes-01.png" alt=""></p>
<p>如果你是使用 Storyboard 进行布局，当然可以通过 <a href="Size-Class-Specific Layout">Size Classes</a> 来解决多尺寸设备适配的问题。不过前面已经提到，本人喜欢手写布局，但依然可以实现效果。</p>
<p>PS：如果你对「布局实现方式的选择」或「Auto Layout」等概念仍有疑问，你可阅读下面参考文章，本文就不作过多详述：</p>
<ol>
<li><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/" target="_blank" rel="external">Understanding Auto Layout</a></li>
<li><a href="https://blog.callmewhy.com/2016/08/24/autolayout-design-aesthetic/" target="_blank" rel="external">Auto Layout 设计美学</a></li>
<li><a href="http://hjcapple.github.io/2016/04/21/ios-make-ui.html" target="_blank" rel="external">iOS 开发中，搭建界面的一些争论</a></li>
<li><a href="https://halfrost.com/wwdc2016_xcode8autolayout_features/" target="_blank" rel="external">WWDC2016 Session笔记 - Xcode 8 Auto Layout新特性</a></li>
</ol>
<hr>
<h2 id="实现">实现</h2><p>因为当屏幕旋转的时候，Controller 的 View 的 Size 会发生改变，就会调用 <code>viewWillLayoutSubviews()</code> 等方法重新布局，如果你是在这些方法里面布局的话，那么界面中的内容会重新布局，更进一步，如果你是在这些方法里面使用 Auto Layout 布局，那么就不需要再做额外的处理了。</p>
<p>但是，如果你是在 <code>viewDidLoad()</code> 等里面布局，那么界面中的内容将不会变化，你可能就需要监听屏幕旋转的地方重新布局，处理好旋转动画等。</p>
<p>于是，实现的关键便是处理屏幕的旋转事件，手动进行布局修改，以适配横竖屏不同效果的布局。那，我们又是如何知道设备的方向发生了改变的呢？不妨看看下面这些方法吧：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIInterfaceOrientation</span> interfaceOrientation <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0,<span class="number">8</span>_0) __TVOS_PROHIBITED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notifies when rotation begins, reaches halfway point and ends.</span></span><br><span class="line">- (<span class="keyword">void</span>)willRotateToInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)toInterfaceOrientation duration:(<span class="built_in">NSTimeInterval</span>)duration <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0,<span class="number">8</span>_0, <span class="string">"Implement viewWillTransitionToSize:withTransitionCoordinator: instead"</span>) __TVOS_PROHIBITED;</span><br><span class="line">- (<span class="keyword">void</span>)didRotateFromInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)fromInterfaceOrientation <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0,<span class="number">8</span>_0) __TVOS_PROHIBITED;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willAnimateRotationToInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)toInterfaceOrientation duration:(<span class="built_in">NSTimeInterval</span>)duration <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">3</span>_0,<span class="number">8</span>_0, <span class="string">"Implement viewWillTransitionToSize:withTransitionCoordinator: instead"</span>) __TVOS_PROHIBITED;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willAnimateFirstHalfOfRotationToInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)toInterfaceOrientation duration:(<span class="built_in">NSTimeInterval</span>)duration <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0, <span class="number">5</span>_0) __TVOS_PROHIBITED;</span><br><span class="line">- (<span class="keyword">void</span>)didAnimateFirstHalfOfRotationToInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)toInterfaceOrientation <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0, <span class="number">5</span>_0) __TVOS_PROHIBITED; <span class="comment">// The rotating header and footer views are offscreen.</span></span><br><span class="line">- (<span class="keyword">void</span>)willAnimateSecondHalfOfRotationFromInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)fromInterfaceOrientation duration:(<span class="built_in">NSTimeInterval</span>)duration <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0, <span class="number">5</span>_0) __TVOS_PROHIBITED; <span class="comment">// A this point, our view orientation is set to the new orientation.</span></span><br></pre></td></tr></table></figure>
<p>别高兴的太早，网上大部分文章（至少中文文章）都会告诉你使用上面的这些方法，而然，Apple 早已在 iOS 8.0 中便将这些关于 Controller 的 Rotation APIs 进行废弃，取而代之的是推荐使用：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillTransitionToSize:(<span class="built_in">CGSize</span>)size withTransitionCoordinator:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerTransitionCoordinator</span>&gt;)coordinator <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br></pre></td></tr></table></figure>
<p>即当 Controller 的 View 的 Size 发生改变时便会触发该方法，下面来看下官方文档的解释：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/handle-orientation-changes-02.png" alt=""></p>
<p>其中 <strong>Size</strong> 为 View 改变（旋转）后的 Size，而 <strong>coordinator</strong> 则可用来处理转换动画。例如，你可以在该方法中改变子 View 的位置或大小：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillTransitionToSize:(<span class="built_in">CGSize</span>)size withTransitionCoordinator:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinator</span>&gt;)coordinator &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">super</span> viewWillTransitionToSize:size withTransitionCoordinator:coordinator];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Code here will execute before the rotation begins.</span></span><br><span class="line">    <span class="comment">// Equivalent to placing it in the deprecated method -[willRotateToInterfaceOrientation:duration:].</span></span><br><span class="line">    [coordinator animateAlongsideTransition:^(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinatorContext</span>&gt; context) &#123;</span><br><span class="line">        <span class="comment">// Place code here to perform animations during the rotation.</span></span><br><span class="line">        <span class="comment">// You can pass nil for this closure if not necessary.</span></span><br><span class="line">        <span class="comment">// Reorganize views, or move child view controllers.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">UIInterfaceOrientationIsLandscape</span>([<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.statusBarOrientation</span>)) &#123;</span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.redView</span> mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">                make<span class="variable">.size</span><span class="variable">.mas_equalTo</span>(<span class="built_in">CGSizeMake</span>(<span class="number">200</span>, <span class="number">200</span>));</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">UIInterfaceOrientationIsPortrait</span>([<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.statusBarOrientation</span>)) &#123;</span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.redView</span> mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">                make<span class="variable">.size</span><span class="variable">.mas_equalTo</span>(<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                                 completion:^(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinatorContext</span>&gt; context)&#123;</span><br><span class="line">                                     <span class="comment">// Code here will execute after the rotation has finished.</span></span><br><span class="line">                                     <span class="comment">// Equivalent to placing it in the deprecated method -[didRotateFromInterfaceOrientation:].</span></span><br><span class="line">                                     <span class="comment">// Do any cleanup, if necessary.</span></span><br><span class="line"></span><br><span class="line">                                 &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释非常简单，就不做翻译了，其中，你可以通过 <code>[UIApplication sharedApplication].statusBarOrientation)</code> 来获取当前设备的方向，便于你之后的操作。</p>
<p>嗯，这篇文章很水，而我会在下篇文章：<a href="http://itangqi.me/2017/03/09/handle-orientation-changes-two/">iOS 屏幕旋转的那些事（二）</a> 中具体介绍我遇到的一个坑。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文将讨论的话题是：iOS 屏幕旋转的那些事，文中示例 Demo 请参见：<a href="https://github.com/tangqi92/QTHandleOrientationChanges.git">https://github.com/tangqi92/QTHandleOrientationChanges.git</a>。</p>]]>
    
    </summary>
    
      <category term="FLEX" scheme="http://itangqi.me/tags/FLEX/"/>
    
      <category term="Orientation" scheme="http://itangqi.me/tags/Orientation/"/>
    
      <category term="Rotation" scheme="http://itangqi.me/tags/Rotation/"/>
    
      <category term="UIDevice" scheme="http://itangqi.me/tags/UIDevice/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于 UITableView's Separator Inset 的探究]]></title>
    <link href="http://itangqi.me/2017/02/28/uitableview-cell-separatorinset/"/>
    <id>http://itangqi.me/2017/02/28/uitableview-cell-separatorinset/</id>
    <published>2017-02-27T16:00:00.000Z</published>
    <updated>2017-02-28T11:36:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这是一次关于 UITableView’s Separator Inset 的探究，请结合 Demo：<a href="https://github.com/tangqi92/QTSeparatorInsetTableView.git" target="_blank" rel="external">https://github.com/tangqi92/QTSeparatorInsetTableView.git</a> 阅读本文。</p>
<a id="more"></a>
<hr>
<h2 id="需求">需求</h2><p>我相信，在平日的开发中，<code>UITableView</code> 绝对算得上使用最平凡的 <code>UIKit</code> 控件之一，并且必定会涉及到 <code>UITableView/UITableViewCell</code> 分割线的设置。</p>
<p>下面，我们就来聊一聊，关于 <code>UITableView/UITableViewCell</code> 分割线的相关内容：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/uitableview-cell-separatorinset-01.png" alt=""></p>
<p>如上图所示，按设计师的要求，在 <code>UITableView</code> 中 <code>Cell</code> 的分割线需要距离左右边距各 16pt。</p>
<p>卧槽，这不很简单嘛！</p>
<p>是吗？</p>
<hr>
<h2 id="边距为_0">边距为 0</h2><p>对于如此简单的页面，自定义 Cell 并添加分割线的方式虽然可行，但未免有些小题大做了。所以，在这里我直接使用系统自带的 <code>UITableViewCell</code> 来实现。</p>
<p>天真的我，想都没想，直接设置 <code>self.tableView.separatorInset = UIEdgeInsetsMake(0, 16, 0, 16);</code>，然后分别测试了 iOS 8.x、iOS 9.x、iOS 10.x，结果显示效果一致，完美！</p>
<p>但出于验证自己答案和寻找更多实现方式的目的，我决定看看大家都是如何实现的，于是 Google 一番后，找到了：<a href="http://stackoverflow.com/questions/25770119/ios-8-uitableview-separator-inset-0-not-working" target="_blank" rel="external">iOS 8 UITableView separator inset 0 not working</a> 。该问题的描述是「为何在 iOS 8 中设置 UITableView 分割线边距为 0 不起作用」，我想这不简单嘛，于是 <code>self.tableView.separatorInset = UIEdgeInsetsZero;</code> ，然后做了测试，显示效果见下表：</p>
<table>
<thead>
<tr>
<th>系统版本</th>
<th style="text-align:center">测试用例</th>
<th style="text-align:center">实现效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>iOS 8.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsZero;</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>iOS 9.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsZero;</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>iOS 10.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsZero;</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<p>WTF（黑人问号脸？？？），这是什么情况？看来我真是「Too Young, Too Naive」…于是我又做了如下测试：</p>
<table>
<thead>
<tr>
<th>系统版本</th>
<th style="text-align:center">测试用例</th>
<th style="text-align:center">实现效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>iOS 8.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsMake(0, 5, 0, 5);</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>iOS 9.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsMake(0, 5, 0, 5);</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>iOS 10.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsMake(0, 5, 0, 5);</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>系统版本</th>
<th style="text-align:center">测试用例</th>
<th style="text-align:center">实现效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>iOS 8.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsMake(0, 25, 0, 25);</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td>iOS 9.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsMake(0, 25, 0, 25);</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td>iOS 10.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsMake(0, 25, 0, 25);</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<p>一定是姿势不对，嗯，一定的！</p>
<hr>
<h2 id="历史回顾">历史回顾</h2><p>为了探究其缘由，在经过一番查阅资料后，关于「分割线边距」（Separator Inset），我们可以得到如下总结：</p>
<h3 id="Prior_to_iOS_7-x">Prior to iOS 7.x</h3><p>分割线默认边距为 <code>0</code>。</p>
<h3 id="iOS_7-x">iOS 7.x</h3><p>新增 <a href="https://developer.apple.com/reference/uikit/uitableview/1614851-separatorinset?language=objc" target="_blank" rel="external">separatorInset</a> 属性，默认边距为 <code>15</code>，此时直接设置 <code>separatorInset</code> 值为 <code>UIEdgeInsetsZero</code> 即可。</p>
<p>我们再来看下文档中关于 <code>separatorInset</code> 的解释：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/uitableview-cell-separatorinset-05.png" alt=""></p>
<h3 id="iOS_8-x">iOS 8.x</h3><p>新增 <a href="https://developer.apple.com/reference/uikit/uiview/1622566-layoutmargins?language=objc" target="_blank" rel="external">layoutMargins</a> 属性，如直接设置 <code>separatorInset</code> 为 <code>UIEdgeInsetsZero</code> 无效。</p>
<p>我们再来看下文档中关于 <code>layoutMargins</code> 的解释：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/uitableview-cell-separatorinset-06.png" alt=""></p>
<p>中间又涉及到 <a href="https://developer.apple.com/reference/uikit/uiview/1622653-preservessuperviewlayoutmargins?language=objc" target="_blank" rel="external">preservesSuperviewLayoutMargins</a> 属性，其解释：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/uitableview-cell-separatorinset-08.png" alt=""></p>
<p>简单来讲就是：<code>layoutMargins</code> 是 View 的 <code>bounds</code> 的边距，默认为 <code>8pt</code>。</p>
<p>如果 <code>preservesSuperviewLayoutMargins</code> 属性设置为 <code>YES</code>，那么父控件的 <code>layoutMargins</code> 边距就将会影响其子控件。</p>
<h3 id="iOS_9-x">iOS 9.x</h3><p>新增 <a href="https://developer.apple.com/reference/uikit/uitableview/1614849-celllayoutmarginsfollowreadablew?language=objc" target="_blank" rel="external">cellLayoutMarginsFollowReadableWidth</a> 属性，其解释：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A Boolean value that indicates whether the cell margins are derived from the width of the readable content guide.</span><br></pre></td></tr></table></figure>
<p>该属性的作用：当设置为 <code>YES</code> 时，在 iPad 上，当 TableView 横屏时，会根据内容留有空白，如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/uitableview-cell-separatorinset-09.png" alt=""></p>
<h3 id="iOS_10-x">iOS 10.x</h3><p>直接设置 tableview 的 <code>separatorInset</code> 即可。</p>
<hr>
<h2 id="实现">实现</h2><p>所以，为了能完美实现「分割线边距可控」的需求，我们需要如下操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cell forRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">// If cell margins are derived from the width of the readableContentGuide.</span></span><br><span class="line">    <span class="comment">// NS_AVAILABLE_IOS(9_0)，需进行判断</span></span><br><span class="line">    <span class="comment">// 设置为 NO，防止在横屏时留白</span></span><br><span class="line">    <span class="keyword">if</span> ([tableView respondsToSelector:<span class="keyword">@selector</span>(setCellLayoutMarginsFollowReadableWidth:)]) &#123;</span><br><span class="line">        tableView<span class="variable">.cellLayoutMarginsFollowReadableWidth</span> = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent the cell from inheriting the Table View's margin settings.</span></span><br><span class="line">    <span class="comment">// NS_AVAILABLE_IOS(8_0)，需进行判断</span></span><br><span class="line">    <span class="comment">// 阻止 Cell 继承来自 TableView 相关的设置（LayoutMargins or SeparatorInset），设置为 NO 后，Cell 可以独立地设置其自身的分割线边距而不依赖于 TableView</span></span><br><span class="line">    <span class="keyword">if</span> ([cell respondsToSelector:<span class="keyword">@selector</span>(setPreservesSuperviewLayoutMargins:)]) &#123;</span><br><span class="line">        [cell setPreservesSuperviewLayoutMargins:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove seperator inset.</span></span><br><span class="line">    <span class="comment">// NS_AVAILABLE_IOS(8_0)，需进行判断</span></span><br><span class="line">    <span class="comment">// 移除 Cell 的 layoutMargins（即设置为 0）</span></span><br><span class="line">    <span class="keyword">if</span> ([cell respondsToSelector:<span class="keyword">@selector</span>(setLayoutMargins:)]) &#123;</span><br><span class="line">        [cell setLayoutMargins:<span class="built_in">UIEdgeInsetsZero</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Explictly set your cell's layout margins.</span></span><br><span class="line">    <span class="comment">// NS_AVAILABLE_IOS(7_0)，需进行判断</span></span><br><span class="line">    <span class="comment">// 根据需求设置相应的边距</span></span><br><span class="line">    <span class="keyword">if</span> ([cell respondsToSelector:<span class="keyword">@selector</span>(setSeparatorInset:)]) &#123;</span><br><span class="line">        [cell setSeparatorInset:<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">16</span>, <span class="number">0</span>, <span class="number">16</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好啦，以上就是由一个简单的需求「设置分割线边距」引发的一系列探究，希望对你有所帮助。</p>
<hr>
<h2 id="疑问">疑问</h2><p>对于 iOS 10.x 直接设置 <code>self.tableView.separatorInset = UIEdgeInsetsMake(0, xx, 0, xx);</code> 便能实现效果，我到目前仍没有找到明确的答案，如果你正巧看到这，又正巧知道原因，希望能告知我一下，先在此表示感谢：）</p>
<hr>
<h2 id="参考">参考</h2><ol>
<li><a href="http://stackoverflow.com/questions/25770119/ios-8-uitableview-separator-inset-0-not-working" target="_blank" rel="external">iOS 8 UITableView separator inset 0 not working</a></li>
<li><a href="http://johnszumski.com/blog/hiding-table-separators-on-a-cell-by-cell-basis" target="_blank" rel="external">Hiding Table Separators on a Cell-by-Cell Basis</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>这是一次关于 UITableView’s Separator Inset 的探究，请结合 Demo：<a href="https://github.com/tangqi92/QTSeparatorInsetTableView.git">https://github.com/tangqi92/QTSeparatorInsetTableView.git</a> 阅读本文。</p>]]>
    
    </summary>
    
      <category term="Inset" scheme="http://itangqi.me/tags/Inset/"/>
    
      <category term="Margin" scheme="http://itangqi.me/tags/Margin/"/>
    
      <category term="Separator" scheme="http://itangqi.me/tags/Separator/"/>
    
      <category term="UITableView" scheme="http://itangqi.me/tags/UITableView/"/>
    
      <category term="UITableViewCell" scheme="http://itangqi.me/tags/UITableViewCell/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UITableViewCell 中嵌套 UICollectionView 的实现]]></title>
    <link href="http://itangqi.me/2017/02/21/putting-a-uicollectionview-in-a-uitableviewcell/"/>
    <id>http://itangqi.me/2017/02/21/putting-a-uicollectionview-in-a-uitableviewcell/</id>
    <published>2017-02-20T16:00:00.000Z</published>
    <updated>2017-02-21T07:09:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>自从去年来到花瓣实习以后，因为时间与精力（其实就是懒）的原因，这半年多没有写过一篇技术相关的文章。不过，随着项目的逐渐进展，我想，有必要对一些知识点进行总结与回顾了。与此同时，如果能帮助到大家就最好不过了：）</p>
<a id="more"></a>
<p>本文中的参考 Demo：<a href="https://github.com/tangqi92/QTTableCollectionView" target="_blank" rel="external">https://github.com/tangqi92/QTTableCollectionView</a>，请结合 Demo 阅读本文。</p>
<hr>
<h2 id="需求">需求</h2><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/putting-a-uicollectionview-in-a-uitableviewcell-01.png" alt=""></p>
<p>这是 <strong>花瓣 4.0</strong> 中「个人主页」里的「关注」页面，我想，你一定会非常熟悉这样的界面布局：竖向与横向滚动列表的结合，我们熟悉的 <strong>App Store</strong>，其首页便是代表之一。</p>
<hr>
<h2 id="分析">分析</h2><p>本文的实现方式是：UITableView + UICollectionView 的结合（其实后来发现，仅仅使用 UICollectionView 就可以实现，不管啦~）。</p>
<p>于是，我们将页面简化，可以得到下图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/putting-a-uicollectionview-in-a-uitableviewcell-03.png" alt=""></p>
<p>现在，我们来分析下 Layout 结构：最外层当然是 UITableView，然后其中每个 UITableViewCell 中包含着一个 UICollectionView，而其中的 UICollectionViewCell 有 3 种不同的样式（既红、绿、蓝三种样式）。于是，我们又得到了下图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/putting-a-uicollectionview-in-a-uitableviewcell-04.png" alt=""></p>
<p>没错，我们将 UITableView 与 UICollectionView 的 Delegate 与 DataSource 都由 TableViewController 处理，是希望 UITableViewCell 中不要出现不必要的代码。</p>
<hr>
<h2 id="实现">实现</h2><p>下面，我们以 <a href="https://github.com/tangqi92/QTTableCollectionView" target="_blank" rel="external">https://github.com/tangqi92/QTTableCollectionView</a> 为例进行讲解。首先，来看下项目的目录结构：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/putting-a-uicollectionview-in-a-uitableviewcell-06.png" alt=""></p>
<h3 id="Model">Model</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QTExploreModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 请根据自身需求，定义相关 Model 类与其属性。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><code>QTExploreModel</code> \ <code>QTBoardModel</code> \ <code>QTUserModel</code> 3 个 Model 类，在这里仅是象征性作用，请根据实际项目需求定义。</p>
<h3 id="View">View</h3><h4 id="自定义_UICollectionViewCell">自定义 UICollectionViewCell</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QTExploresCollectionViewCell</span> : <span class="title">UICollectionViewCell</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) QTExploreModel *exploreModel;</span><br><span class="line"><span class="comment">/// 该方仅法用于测试。</span></span><br><span class="line">- (<span class="keyword">void</span>)setupModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QTExploresCollectionViewCell</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 请根据自身需求，自定义 CollectionViewCell。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *coverView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QTExploresCollectionViewCell</span></span></span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> initViews];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.layer</span><span class="variable">.cornerRadius</span> = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.layer</span><span class="variable">.masksToBounds</span> = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)initViews &#123;</span><br><span class="line">    _coverView = [<span class="built_in">UIView</span> new];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.contentView</span> addSubview:_coverView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">    [_coverView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make<span class="variable">.edges</span><span class="variable">.equalTo</span>(<span class="keyword">self</span><span class="variable">.contentView</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setExploreModel:(QTExploreModel *)exploreModel &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 数据填充</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupModel &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.coverView</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><code>QTExploresCollectionViewCell</code> \ <code>QTBoardsCollectionViewCell</code> \ <code>QTUsersCollectionViewCell</code> 3 个自定义 UICollectionViewCell，也请根据实际项目需求自行定义。</p>
<h4 id="自定义_UICollectionView">自定义 UICollectionView</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 3 种类型的 Cell。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, CollectionViewCellType) &#123;</span><br><span class="line">    CellTypeExplores = <span class="number">0</span>,</span><br><span class="line">    CellTypeBoards,</span><br><span class="line">    CellTypeUsers</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QTCollectionView</span> : <span class="title">UICollectionView</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// indexPath 用于查询相应的 Model，并填充至 Cell。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *indexPath;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) CollectionViewCellType collectionViewCellType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><code>indexPath</code> 用于记录 UICollectionView 所处的位置，而 <code>CollectionViewCellType</code> 用于区分不同类型的 UICollectionViewCell（当然，你可以直接使用 indexPath.section（0、1、2） 用以区别，只是我个人比较倾向使用枚举而已）。</p>
<h4 id="自定义_UITableViewCell">自定义 UITableViewCell</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> ExploreCollectionViewCellID = <span class="string">@"ExploreCollectionViewCellID"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> BoardCollectionViewCellID = <span class="string">@"BoardCollectionViewCellID"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> UserCollectionViewCellID = <span class="string">@"UserCollectionViewCellID"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QTTableViewCell</span> : <span class="title">UITableViewCell</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// UITableViewCell 中嵌套 CollectionView。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) QTCollectionView *collectionView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 设置 CollectionView 的 DataSource 与 Delegate。</span></span><br><span class="line">- (<span class="keyword">void</span>)setCollectionViewDataSourceDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">UICollectionViewDataSource</span>, <span class="built_in">UICollectionViewDelegate</span>, <span class="built_in">UICollectionViewDelegateFlowLayout</span>&gt;)dataSourceDelegate indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>本文前面已经提过，该界面实现的关键便在于 <code>UITableViewCell</code> 中嵌套 <code>UICollectionView</code>，并将 <code>UICollectionView</code> 的 Delegate 与 DataSource 交由 <code>UITableViewController</code> 处理。在这里，我们使用 <code>- (void)setCollectionViewDataSourceDelegate:indexPath:</code> 处理。下面，我们再来看下 <code>QTTableViewCell</code> 的具体实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QTTableViewCell</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithStyle:(<span class="built_in">UITableViewCellStyle</span>)style reuseIdentifier:(<span class="built_in">NSString</span> *)reuseIdentifier &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">self</span> = [<span class="keyword">super</span> initWithStyle:style reuseIdentifier:reuseIdentifier])) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 UICollectionViewFlowLayout 进行布局。</span></span><br><span class="line">    <span class="comment">// 注册 UICollectionViewCell。</span></span><br><span class="line">    <span class="comment">// 其他初始化操作。</span></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make<span class="variable">.edges</span><span class="variable">.equalTo</span>(<span class="keyword">self</span><span class="variable">.contentView</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCollectionViewDataSourceDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">UICollectionViewDataSource</span>, <span class="built_in">UICollectionViewDelegate</span>&gt;)dataSourceDelegate indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.dataSource</span> = dataSourceDelegate;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.delegate</span> = dataSourceDelegate;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.indexPath</span> = indexPath;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> setContentOffset:<span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.contentOffset</span> animated:<span class="literal">NO</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> reloadData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="Controller">Controller</h3><h4 id="UITableViewController_的实现">UITableViewController 的实现</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView willDisplayCell:(QTTableViewCell *)cell forRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">// 为 TableViewCell 中的 CollectionView 设置不同的 collectionViewCellType 用以区别，此处一共 3 种样式。</span></span><br><span class="line">    <span class="keyword">if</span> (indexPath<span class="variable">.section</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        cell<span class="variable">.collectionView</span><span class="variable">.collectionViewCellType</span> = CellTypeExplores;</span><br><span class="line">        <span class="built_in">NSInteger</span> index = cell<span class="variable">.collectionView</span><span class="variable">.indexPath</span><span class="variable">.row</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> horizontalOffset = [<span class="keyword">self</span><span class="variable">.contentOffsetDictionaryOfExplores</span>[[@(index) stringValue]] floatValue];</span><br><span class="line">        <span class="comment">// 设置 CollectionView 的 ContentOffset，在'- (void)scrollViewDidScroll:(UIScrollView *)scrollView;' 中存储的。</span></span><br><span class="line">        [cell<span class="variable">.collectionView</span> setContentOffset:<span class="built_in">CGPointMake</span>(horizontalOffset, <span class="number">0</span>)];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (indexPath<span class="variable">.section</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        cell<span class="variable">.collectionView</span><span class="variable">.collectionViewCellType</span> = CellTypeBoards;</span><br><span class="line">        <span class="built_in">NSInteger</span> index = cell<span class="variable">.collectionView</span><span class="variable">.indexPath</span><span class="variable">.row</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> horizontalOffset = [<span class="keyword">self</span><span class="variable">.contentOffsetDictionaryOfBoards</span>[[@(index) stringValue]] floatValue];</span><br><span class="line">        <span class="comment">// 设置 CollectionView 的 ContentOffset。</span></span><br><span class="line">        [cell<span class="variable">.collectionView</span> setContentOffset:<span class="built_in">CGPointMake</span>(horizontalOffset, <span class="number">0</span>)];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (indexPath<span class="variable">.section</span> == <span class="number">2</span>) &#123;</span><br><span class="line">        cell<span class="variable">.collectionView</span><span class="variable">.collectionViewCellType</span> = CellTypeUsers;</span><br><span class="line">        <span class="built_in">NSInteger</span> index = cell<span class="variable">.collectionView</span><span class="variable">.indexPath</span><span class="variable">.row</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> horizontalOffset = [<span class="keyword">self</span><span class="variable">.contentOffsetDictionaryOfUsers</span>[[@(index) stringValue]] floatValue];</span><br><span class="line">        <span class="comment">// 设置 CollectionView 的 ContentOffset。</span></span><br><span class="line">        [cell<span class="variable">.collectionView</span> setContentOffset:<span class="built_in">CGPointMake</span>(horizontalOffset, <span class="number">0</span>)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !!!: 设置 CollectionView 的 DataSource 与 Delegate 及所处的 indexPath。</span></span><br><span class="line">    [cell setCollectionViewDataSourceDelegate:<span class="keyword">self</span> indexPath:indexPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住，在 UITableViewCell 中的 CollectionView 是在 Cell 之后初始化的，也就是在初始化这个 Cell 的之后要立即设置这个 Cell 中 CollectionView 的数据源跟代理。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(QTCollectionView *)collectionView cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="built_in">UICollectionViewCell</span> *cell = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (collectionView<span class="variable">.collectionViewCellType</span> == CellTypeExplores) &#123;</span><br><span class="line">        cell = [collectionView dequeueReusableCellWithReuseIdentifier:ExploreCollectionViewCellID forIndexPath:indexPath];</span><br><span class="line">        <span class="keyword">if</span> ([cell isKindOfClass:[QTExploresCollectionViewCell class]]) &#123;</span><br><span class="line">            QTExploresCollectionViewCell *cellExplore = (QTExploresCollectionViewCell *) cell;</span><br><span class="line">            [cellExplore setupModel];</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 获取到相应的 Model 后进行赋值操作</span></span><br><span class="line">            <span class="comment">//            if (self.dataSourceExplores.count &gt; 0) &#123;</span></span><br><span class="line">            <span class="comment">//                cellExplore.exploreModel = self.dataSourceExplores[indexPath.row];</span></span><br><span class="line">            <span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collectionView<span class="variable">.collectionViewCellType</span> == CellTypeBoards) &#123;</span><br><span class="line">        cell = [collectionView dequeueReusableCellWithReuseIdentifier:BoardCollectionViewCellID forIndexPath:indexPath];</span><br><span class="line">        <span class="keyword">if</span> ([cell isKindOfClass:[QTBoardsCollectionViewCell class]]) &#123;</span><br><span class="line">            QTBoardsCollectionViewCell *cellBoard = (QTBoardsCollectionViewCell *) cell;</span><br><span class="line">            [cellBoard setupModel];</span><br><span class="line">            <span class="comment">//            if (self.dataSourceBoards.count &gt; 0) &#123;</span></span><br><span class="line">            <span class="comment">//                cellBoard.boardModel = self.dataSourceBoards[indexPath.row];</span></span><br><span class="line">            <span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collectionView<span class="variable">.collectionViewCellType</span> == CellTypeUsers) &#123;</span><br><span class="line">        cell = [collectionView dequeueReusableCellWithReuseIdentifier:UserCollectionViewCellID forIndexPath:indexPath];</span><br><span class="line">        <span class="keyword">if</span> ([cell isKindOfClass:[QTUsersCollectionViewCell class]]) &#123;</span><br><span class="line">            QTUsersCollectionViewCell *cellUser = (QTUsersCollectionViewCell *) cell;</span><br><span class="line">            [cellUser setupModel];</span><br><span class="line">            <span class="comment">//            if (self.dataSourceUsers.count &gt; 0) &#123;</span></span><br><span class="line">            <span class="comment">//                cellUser.userModel = self.dataSourceUsers[indexPath.row];</span></span><br><span class="line">            <span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    <span class="keyword">if</span> (![scrollView isKindOfClass:[<span class="built_in">UICollectionView</span> class]])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGFloat</span> horizontalOffset = scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span>;</span><br><span class="line">    QTCollectionView *collectionView = (QTCollectionView *) scrollView;</span><br><span class="line">    <span class="built_in">NSInteger</span> index = collectionView<span class="variable">.indexPath</span><span class="variable">.row</span>;</span><br><span class="line">    <span class="comment">// 根据 collectionViewCellType 存储对应的偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (collectionView<span class="variable">.collectionViewCellType</span> == CellTypeExplores) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.contentOffsetDictionaryOfExplores</span>[[@(index) stringValue]] = @(horizontalOffset);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collectionView<span class="variable">.collectionViewCellType</span> == CellTypeBoards) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.contentOffsetDictionaryOfBoards</span>[[@(index) stringValue]] = @(horizontalOffset);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collectionView<span class="variable">.collectionViewCellType</span> == CellTypeUsers) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.contentOffsetDictionaryOfUsers</span>[[@(index) stringValue]] = @(horizontalOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 Cell 的重用机制，我们需要通过辅助手段，记住每个 UICollectionView 中滑动的偏移量，这里通过：<code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView</code> 实现。</p>
<p>整个代码比较简单，辅助上注释，相信并不难理解。大功告成，我们来看下最后的实现效果吧：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/putting-a-uicollectionview-in-a-uitableviewcell-07.png" alt=""></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/putting-a-uicollectionview-in-a-uitableviewcell-09.png" alt=""></p>
<hr>
<h2 id="感谢">感谢</h2><p>本文绝大部分思想来自 <a href="https://ashfurrow.com/blog/putting-a-uicollectionview-in-a-uitableviewcell/" target="_blank" rel="external">Putting a UICollectionView in a UITableViewCell</a>，再次表示感谢！</p>
<p>如果你是个 Swifter，这里提供一篇基于 Swift 的文章 <a href="https://www.thorntech.com/2015/08/want-your-swift-app-to-scroll-in-two-directions-like-netflix-heres-how/" target="_blank" rel="external">https://www.thorntech.com/2015/08/want-your-swift-app-to-scroll-in-two-directions-like-netflix-heres-how/</a> 以供参考。</p>
<hr>
<h2 id="参考">参考</h2><ol>
<li><a href="https://ashfurrow.com/blog/putting-a-uicollectionview-in-a-uitableviewcell/" target="_blank" rel="external">Putting a UICollectionView in a UITableViewCell</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>自从去年来到花瓣实习以后，因为时间与精力（其实就是懒）的原因，这半年多没有写过一篇技术相关的文章。不过，随着项目的逐渐进展，我想，有必要对一些知识点进行总结与回顾了。与此同时，如果能帮助到大家就最好不过了：）</p>]]>
    
    </summary>
    
      <category term="UICollectionView" scheme="http://itangqi.me/tags/UICollectionView/"/>
    
      <category term="UITableView" scheme="http://itangqi.me/tags/UITableView/"/>
    
      <category term="UITableViewCell" scheme="http://itangqi.me/tags/UITableViewCell/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Bye 2016, Hi 2017]]></title>
    <link href="http://itangqi.me/2016/12/31/bye2016-hi2017/"/>
    <id>http://itangqi.me/2016/12/31/bye2016-hi2017/</id>
    <published>2016-12-30T16:00:00.000Z</published>
    <updated>2016-12-31T06:57:43.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>过去的如果就这么过去了，以后只会越来越糟。——《驴得水》</p>
</blockquote>
<a id="more"></a>
<h2 id="技术">技术</h2><h3 id="1_月_—_2_月">1 月 — 2 月</h3><p>为了迎接 3 月份的实习生面试，这 2 个月基本上就是在不断地刷题中度过的。</p>
<p>对了，想要进大厂，数据结构与算法一定要过关，别问我为什么这么说。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/IMG_1930%203.JPG" alt=""></p>
<h3 id="3_月_—_5_月">3 月 — 5 月</h3><p>正式开启了长达 3 个月之久的实习生求职之旅，虽然一路磕磕绊绊，但却也收获了许多宝贵的经验。</p>
<p>最开始，经历了豆瓣顺利到让人怀疑的面试，最终顺利拿到 Offer。</p>
<p>紧接着，接连跪在了百度与腾讯的在线笔试上，开始怀疑人生。</p>
<p>再后来，面对阿里内推与现场面试这两次机会时，都没能把握住。</p>
<p>幸运的是，我遇到了<a href="http://huaban.com/" target="_blank" rel="external">花瓣</a>。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/IMG_0997.JPG" alt=""></p>
<h3 id="6_月">6 月</h3><p>最轻松的一个月，闲暇时开始 <a href="https://github.com/tangqi92/GankYou" target="_blank" rel="external">GankYou</a> 的开发，随后由于工作的原因，没能持续更新下去，希望 17 年自己能把 Side Project 坚持下去。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/meizhi.png" alt=""></p>
<h3 id="7_月_—_9_月">7 月 — 9 月</h3><p>来到花瓣实习，经历了陶叔叔离职，产生过离开的想法，不过最终决定留下。</p>
<p>随后在士辛的指导下，参与了阔别三年之久的花瓣 Android <a href="http://www.wandoujia.com/apps/com.huaban.android" target="_blank" rel="external">3.0</a> 版本的开发，有幸见证了用户从零一步步增长到几十万的过程。</p>
<p>由于没有历史包袱，3.0 版本是完全基于 Kotlin 编写的，感觉很爽啊！但期间也踩了不少坑，之后会专门写篇文章来进行总结。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/665d097e49420fdbd0221fe7956b1820-for-7743-o_1arfsrcjt1h02tat1ogr1kkf1s3514-uid-12202.jpeg" alt=""></p>
<h3 id="10_月_—_12_月">10 月 — 12 月</h3><p>花瓣 Android 由士辛继续迭代，而我也正式转向 iOS，独立负责花瓣 iOS 4.0 版本的改版。4.0 采用了全新的设计，相应模块也进行了改版，目前为止已经进入内测阶段。</p>
<p>第一次独立负责项目，从一开始的畏畏缩缩，到现在的游刃有余，这是我飞速进步的 3 个月。我有个小小的愿望，那就是希望能通过自己的不断地努力，把花瓣 iOS 不断做得更好，能得到更多人的喜欢与肯定。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/IMG_1933.PNG" alt=""></p>
<h2 id="生活">生活</h2><h3 id="1_月_—_6_月">1 月 — 6 月</h3><p>下学期基本上就没去上过课，心思全在找实习上。</p>
<p>对于研二选择实习的我而言，其实这就是整个研究生生涯亦是整个学生生涯，最后的校园时光了，很高兴能与一群志同道合的小伙伴们一起度过。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/Enlighsst.jpg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/IMG_0638.JPG" alt=""></p>
<h3 id="7_月_—_12_月">7 月 — 12 月</h3><p>选择一个人住，选择自己想要的生活。</p>
<p>开始健身，开始自己做饭，开始改变穿衣风格。</p>
<p>感到累了，迷惘了，就回家，回到那个最温暖的地方。</p>
<p>感谢陶叔叔对我的赏识，让我有幸加入花瓣；感谢士辛在技术上的指点，让我快速成长起来；感谢雅金在设计与产品上的追求，让我更加有动力将花瓣做得更加精致；感谢花瓣的所有人，让我很有归属感。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/Enlight%2031.jpg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/Enlight%2032.jpg" alt=""></p>
<h2 id="2017">2017</h2><blockquote>
<p>永远保持真诚，保持高尚的品行。把每天过成你的最后一天，活得充实、不留遗憾，有冒险精神、要英勇，但也要尽情享受，因为人生本短。——《神奇队长》</p>
</blockquote>
<h2 id="书单列表">书单列表</h2><ol>
<li><a href="https://book.douban.com/subject/26630830/" target="_blank" rel="external">程序员面试宝典</a></li>
<li><a href="https://book.douban.com/subject/25910559/" target="_blank" rel="external">剑指Offer</a></li>
<li><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="external">图解HTTP</a></li>
<li><a href="https://book.douban.com/subject/24284008/" target="_blank" rel="external">Objective-C基础教程</a></li>
<li><a href="https://book.douban.com/subject/19967897/" target="_blank" rel="external">Objective-C 程序设计</a></li>
<li><a href="https://book.douban.com/subject/24720270/" target="_blank" rel="external">Objective-C高级编程</a></li>
<li><a href="https://book.douban.com/subject/25829244/" target="_blank" rel="external">Effective Objective-C 2.0</a></li>
<li><a href="https://book.douban.com/subject/26599538/" target="_blank" rel="external">Android开发艺术探索</a></li>
<li><a href="http://producter.io/" target="_blank" rel="external">Producter</a></li>
<li><a href="https://book.douban.com/subject/3523041/" target="_blank" rel="external">平凡的世界（全三册）</a></li>
</ol>
<h2 id="推荐单品">推荐单品</h2><ol>
<li><a href="http://you.163.com/item/detail?id=1037011" target="_blank" rel="external">安睡慢回弹记忆绵床垫</a></li>
<li><a href="https://detail.tmall.com/item.htm?spm=a1z10.3-b-s.w4011-14571099812.64.jqDlt6&amp;id=13230519823&amp;rn=41ae3101ca27fd6ebef56811aefb1222&amp;abbucket=18&amp;skuId=50444570013" target="_blank" rel="external">飞利浦电动牙刷HX6730</a></li>
</ol>
<h2 id="心愿单">心愿单</h2><ol>
<li>坚持健身</li>
<li>自己做饭</li>
<li>早睡早起</li>
<li>论文顺利开题</li>
<li>拿到心仪的 Offer</li>
<li>做自己，做喜欢的事</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>过去的如果就这么过去了，以后只会越来越糟。——《驴得水》</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Review" scheme="http://itangqi.me/tags/Review/"/>
    
      <category term="Summary" scheme="http://itangqi.me/tags/Summary/"/>
    
      <category term="Life" scheme="http://itangqi.me/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[近况]]></title>
    <link href="http://itangqi.me/2016/08/14/what-is-going-on/"/>
    <id>http://itangqi.me/2016/08/14/what-is-going-on/</id>
    <published>2016-08-13T16:00:00.000Z</published>
    <updated>2016-08-14T12:27:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这是一篇流水账，主要记录下过去两个月的时间里，我在生活和工作中经历的一些事与感悟。</p>
<a id="more"></a>
<hr>
<h2 id="最后的校园时光">最后的校园时光</h2><blockquote>
<p>习惯幕起幕落，总以为明天还很多。当我渐渐习惯并开始享受读研的日子时，我却到了不得不得和她说「再见」的时候。</p>
</blockquote>
<p>在 6 月初拿到实习 Offer 并决定不再面试其他公司后，我终于结束了长达 3 个月的实习生求职之旅（此处泪流满面.jpg）。同时，作为实验室最后一个确定实习意向的我，也终于能放下心中悬着的石头，和小伙伴们一起尽情地享受最后宝贵的校园时光了。</p>
<p>所以，在最后大半个月的时间里，我们总会找各种理由，隔三差五出去聚餐。亦或者在实验室，三五成群打牌、打游戏或者看电影（平时肯定不会这样哒），我们尽可能用照片记录下这一切，因为我们心里都清楚，这段弥足珍贵的时光，将一去不复返。如果说，读研给我留下了什么？与那些貌似高大尚其实华而不实的课程、与那些枯燥乏味且强制要听的讲座、与那些只会剥削利用学生劳动力的教授相比，那绝对是一群友爱的小伙伴。你能相信吗？即使现在我们散落在全国各地，但我们每周末都会约定一起进行视屏聊天。可以说，能拥有这样一群小伙伴真的非常幸福。</p>
<hr>
<h2 id="拥抱变化">拥抱变化</h2><blockquote>
<p>如果说，为什么选择花瓣？那我会毫不避讳地说：“我是冲着陶叔叔来的~”</p>
</blockquote>
<p>是的，正因为花瓣 iOS 端负责人是陶叔叔，所以我相信，若能在他的指导下工作，我一定能快速的成长。</p>
<p>可当我怀揣着雄心壮志，准备大干一番的时候，我却得知了陶叔叔即将离职的消息，而那是在我正式报道的第一天。突如其来的「变化」让我措手不及，我清楚的记得，当我听到这个消息的时候，我脑子是一片空白的。陶叔叔说他离职还有半个月的时间，不管接下来我怎么选择，这段日子，该学习的还要学习，该工作的还要工作。同时他也给了我很多中肯的意见，但他也始终强调，最终的决定一定是我自己拿。</p>
<p>那么，既然有了「变化」，就要有一颗积极的心去「拥抱变化」，一方面我每天照常努力学习与工作，另一方面我给自己列举了很多可能性，在纠结与权衡半个月之后，我决定留在花瓣。因为我相信花瓣，也相信自己，这是一个机会，我希望我能把握住它。</p>
<p>最后仍要感谢下陶叔叔，如果不是他，我也许就不会选择花瓣。虽然只和他共事短短半个月的时间，但他对我真的非常的好，身怀绝技却又平易近人（其实是有些逗逼啦~）。从他身上学到了不仅仅是技术，还有很多很多，祝陶叔叔之后一切顺利，以后常聚，记得请我吃饭啊，哈哈~</p>
<hr>
<h2 id="花瓣">花瓣</h2><blockquote>
<p>放弃了豆瓣，错过了阿里，选择了花瓣，这一切都是「缘」。</p>
</blockquote>
<p>花瓣是个小团队，所以在花瓣，你既要当开发，又要当测试，还要兼职卖萌当客服解答用户的疑问。我当然不是在抱怨，反而是很享受这个过程，因为在这有一种「归属感」，只要你想，你能在花瓣做任何事。团队非常友爱，相处起来非常融洽，上个星期，我还在公司过了生日。</p>
<p>过去的一个月，我都在参与花瓣 Android 的开发，虽然非常繁忙但却又感到非常幸运，因为能参与到一个全新的项目中（由于没有历史包袱，这次我们是从零开始重写），有很多想做却没机会做的事可以去实现。关于项目的具体细节，之后会有专门的文章来讲述，其实我和小伙伴是有计划搭建公司的技术博客，希望之后能付诸于行动吧~</p>
<p>花瓣 Android 正式版即将上线了，如果你想尝鲜的话，可以在这里获取<a href="http://fir.im/huabanAndroid" target="_blank" rel="external">最新测试版</a>（求轻喷 ≧▽≦）</p>
<p>关于接下来的计划，一方面，是继续迭代花瓣 Android 客户端，我和小伙伴「士辛」都有着共同的愿景，就是希望能做一款令自己满意的精致的应用，希望我们能实现吧~另一方面，是希望能推进花瓣 iOS 客户端新版本的开发工作，毕竟自己更热爱 iOS。但不管怎么，眼下的仍需要踏踏实实，一步一脚印走下去，加油吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>这是一篇流水账，主要记录下过去两个月的时间里，我在生活和工作中经历的一些事与感悟。</p>]]>
    
    </summary>
    
      <category term="Diary" scheme="http://itangqi.me/tags/Diary/"/>
    
      <category term="Summary" scheme="http://itangqi.me/tags/Summary/"/>
    
      <category term="Life" scheme="http://itangqi.me/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 中的垃圾回收]]></title>
    <link href="http://itangqi.me/2016/06/12/garbage-collection-in-java/"/>
    <id>http://itangqi.me/2016/06/12/garbage-collection-in-java/</id>
    <published>2016-06-11T16:00:00.000Z</published>
    <updated>2016-06-22T04:28:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>说来惭愧，作为一名前 Android 开发者，对于 Java 的理解理应十分透彻才对。可不瞒你说，就在写这篇文章之前，你要是问我关于 Java 中垃圾回收（GC）的问题，我准一脸懵逼，哈哈（我居然还有脸笑）~</p>
<p>所以呢，在后继学习 iOS 开发的过程中，我特别注重原理的掌握。当然，如果你问我 Objective-C 中的内存管理机制，我肯定是有所了解的，不信你看：<a href="http://itangqi.me/2016/03/10/the-notes-of-learning-arc/">《Objective-C 高级编程》读书笔记之 ARC</a>。</p>
<blockquote>
<p>出来混，迟早是要还的。</p>
</blockquote>
<p>我想，现在也是时候把在 Java 那欠下的债清一清了，今天就来先来补一补——Java 中的垃圾回收机制。</p>
<a id="more"></a>
<hr>
<h2 id="什么是垃圾回收">什么是垃圾回收</h2><p>乍一看，垃圾回收所做的事情应当恰如其名——查找并清除垃圾。事实上却恰恰相反。垃圾回收会跟踪所有仍在使用的对象，然后将剩余的对象标记为垃圾。牢记了这点之后，我们再来深入地了解下这个被称为「垃圾回收」的自动化内存回收在 JVM 中到底是如何实现的。</p>
<h3 id="手动内存管理">手动内存管理</h3><p>在介绍现代版的垃圾回收之前，我们先来简单地回顾下需要手动地显式分配及释放内存的那些日子。如果你忘了去释放内存，那么这块内存就无法重用了。这块内存被占有了却没被使用。这种场景被称之为<strong>内存泄露</strong>。</p>
<p>内存泄露曾经是个非常普遍的问题。你只能通过不断地修复自己的代码来与它们进行抗争。因此，需要有一种更优雅的方式来自动释放无用内存，以便减少人为错误的可能性。这种自动化过程又被称为垃圾回收（简称 GC）。</p>
<h3 id="自动内存管理">自动内存管理</h3><p>第一代的垃圾回收器是 1959 年 Lisp 引入的，这项技术迄今为止一直在不断演进。</p>
<h4 id="引用计数">引用计数</h4><p>咦，这不是 Objective-C 中的概念吗？其实许多语言比如说 Perl，Python 以及 PHP，采用的都是这种方式。这个通过一张图可以很容易说明：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-07.png" alt=""></p>
<p>绿色的云代表的是程序中仍在使用的对象。从技术层面上来说，这有点像是正在执行的某个方法里面的局部变量，亦或是静态变量之类的。不同编程语言的情况可能会不一样，因此这并不是我们关注的重点。</p>
<p>蓝色的圆圈代表的是内存中的对象，可以看到有多少对象引用了它们。灰色圆圈的对象是已经没有任何人引用的了。因此，它们属于垃圾对象，可以被垃圾回收器清理掉。</p>
<p>看起来还不错对吧？没错，不过这里存在着一个重大的缺陷。很容易会出现一些<strong>孤立的环（detached cycle）</strong>，它们中的对象都不在任何域内，但彼此却互相引用导致引用数不为 0。下面便是一个例子：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-08.png" alt=""></p>
<p>看到了吧，红色部分其实就是应用程序不再使用的垃圾对象。由于引用计数的缺陷，因此会存在内存泄露。</p>
<p>有几种方法可以解决这一问题，比如 OC 中便可以使用 <code>weak</code> 引用来解决，接下来让我们来看下 JVM 所采用的方法。</p>
<h4 id="标记删除">标记删除</h4><p>首先，JVM 对于对象<strong>可达性</strong>的定义要明确一些。它可不像前面那样用绿色的云便含糊了事的，而是有着非常明确及具体的垃圾回收根对象（Garbage Collection Roots）的定义：</p>
<ul>
<li>局部变量</li>
<li>活动线程</li>
<li>静态字段</li>
<li>JNI 引用</li>
</ul>
<p>JVM 通过标记删除的算法来记录所有可达（存活）对象，同时确保不可达对象的那些内存能够被重用。这包含两个步骤：</p>
<ul>
<li>标记：是指遍历所有可达对象，然后在本地内存中记录这些对象的信息</li>
<li>删除：会确保不可达对象的内存地址可以在下一次内存分配中使用</li>
</ul>
<p>JVM 中的不同 GC 算法，比如说 Parallel Scavenge，Parallel Mark+Copy，CMS 都是这一算法的不同实现，只是各阶段略有不同而已，从概念上来讲仍然是对应着上面所说的那两个步骤。</p>
<p>这种实现最重要的就是不会再出现泄露的对象环了：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-09.png" alt=""></p>
<p>缺点就是应用程序的线程需要被<strong>暂停</strong>才能完成回收，如果引用一直在变的话你是无法进行计数的。这个应用程序被暂停以便 JVM 可以收拾家务的情况又被称为 <strong>Stop The World pause</strong>(STW)。这种暂停被触发的可能性有很多，不过垃圾回收应该是最常见的一种。</p>
<blockquote>
<p>因为垃圾回收的时候，需要整个的引用状态保持不变，否则判定是判定垃圾，等我稍后回收的时候它又被引用了，这就全乱套了。所以，GC 的时候，其他所有的程序执行处于暂停状态，卡住了。<br>幸运的是，这个卡顿是非常短（尤其是新生代），对程序的影响微乎其微 （关于其他 GC 比如并发 GC 之类的，在此不讨论）。<br>所以 GC 的卡顿问题由此而来，也是情有可原，暂时无可避免。</p>
</blockquote>
<hr>
<h2 id="碎片及整理（Fragmenting_and_Compacting）">碎片及整理（Fragmenting and Compacting）</h2><p>JVM 在清除不可达对象之后，还得确保它们所在的空间是可以进行复用的。对象删除会导致碎片的出现，这有点类似于磁盘碎片，这会带来两个问题：</p>
<ul>
<li>写操作会变得更加费时，因为查找下一个可用空闲块已不再是一个简单操作</li>
<li>JVM 在创建新对象的，会在连续的区块中分配内存。因此如果碎片已经严重到没有一个空闲块能足够容纳新创建的对象时，内存分配便会报错</li>
</ul>
<p>为了避免此类情形，JVM 需要确保碎片化在可控范围内。因此，在垃圾回收的过程中，除了进行标记和删除外，还有一个「内存去碎片化」的过程。在这个过程当中，会给可达对象重新分配空间，让它们互相紧挨着对方，这样便可以去除碎片。下图展示的便是这一过程：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-10.png" alt=""></p>
<hr>
<h2 id="分代假设">分代假设</h2><p>如前所述，垃圾回收需要完全中止应用运行。显然，对象越多，回收的时间也越长。那么我们能不能在更小的内存区域上进行回收呢？通过可行性调查，一组研究人员发现应用中绝大多数的内存分配会分为两大类：</p>
<ul>
<li>绝大部分的对象很快会变为不可用状态</li>
<li>还有一些，它们的存活时间通常也不会很长</li>
</ul>
<p>这些结论最终构成了弱分代假设（Weak Generational Hypothesis）。基于这一假设，虚拟机内的内存被分为两类，新生代（Young Generation)及老生代（Old Generation)。后者又被称为年老代（Tenured Generation）。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-11.png" alt=""></p>
<p>有了各自独立的可清除区域后，这才出现了众多不同的回收算法，正是它们一直以来在持续提升着 GC 的性能。</p>
<p>这并不说明这样的方式是没有问题的。比如说，不同分代中的对象可能彼此间有引用，在进行分代回收时，它们便为视为是「事实上」的 GC 根对象（GC roots)。</p>
<p>而更为重要的是，分代假设对于某些应用来说并不成立。由于 GC 算法主要是为那些「快速消失」或者「永久存活」的对象而进行的优化，因此对于那些生命周期「适中」的对象，JVM 就显得无能为力了。</p>
<hr>
<h2 id="内存池">内存池</h2><p>在堆里面进行内存池的划分对大家来说应该是非常熟悉的了。不过大家可能不太清楚的是在不同的内存池中，垃圾回收是如何履行它的职责的。值得注意的是，虽然不同的 GC 算法细节实现上有所不同，但是本文中所提到的概念却是大同小异的。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-04.png" alt=""></p>
<h3 id="Eden_区">Eden 区</h3><p>新对象被创建时，通常便会被分配到 Eden 区。由于通常都会有多个线程在同时分配大量的对象，因此 Eden 区又被进一步划分成一个或多个线程本地分配缓冲（Thread Local Allocation Buffer，简称 TLAB）。有了这些缓冲区使得 JVM 中大多数对象的分配都可以在各个线程自己对应的 TLAB 中完成，从而避免了线程间昂贵的同步开销。</p>
<p>如果在 TLAB 中无法完成分配（通常是由于没有足够的空间），便会到 Eden 区的共享空间中进行分配。如果这里还是没有足够的空间，则会触发一次新生代垃圾回收的过程来释放空间。如果垃圾回收后 Eden 区还是没有足够的空间，那么这个对象便会到老生代中去分配。</p>
<p>当进行 Eden 区的回收时，垃圾回收器会从根对象开始遍历所有的可达对象，并将它们标记为存活状态。</p>
<p>前面我们已经提到，对象间可能会存在跨代引用，因此最直观的做法便是扫描其它分区到 Eden 区的所有引用。但不幸的是这么做会做成分代的做法变得毫无意义。JVM 对此有它自己的妙招：卡片式标记（card-marking）。基本的做法是，JVM 将 Eden 区中可能存在老生代引用的对象标记为「脏」对象。关于这点<a href="http://psy-lob-saw.blogspot.jp/2014/10/the-jvm-write-barrier-card-marking.html" target="_blank" rel="external">Nitsan</a> 的博客这里有更进一步的介绍。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-05.png" alt=""></p>
<p>标记完成后，所有存活对象会被复制到其中的一个 Survivor 区。于是整个 Eden 区便可认为是清空了，又可以重新用来分配对象了。这一过程便被称为标记复制（Mark and Copy）：存活对象先被标记，随后被复制到 Survivor 区中。</p>
<h3 id="Survivor_区">Survivor 区</h3><p>紧挨着 Eden 的是两个 Survivor 区，分别是 ‘from’ 区和 ‘to’ 区。值得一提的是其中的一个 Survivor 区始终都是空的。</p>
<p>空的 Survivor 区会在下一次新生代 GC 的时候迎来它的居民。整个新生代中的所有存活对象（包含 Eden 区以及那个非空的名为 ‘from’ 的 Survivor 区）都会被复制到 ‘to’ 区中。一旦完成之后，对象便都跑到 ‘to’ 区中而 ‘from’ 区则被清空了。这时两者的角色便会发生调转。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-06.png" alt=""></p>
<p>存活对象会不断地在两个存活区之间来回地复制，直到其中的一些对象被认为是已经成熟，「足够老」了。请记住这点，基于分代假设，已经存活了一段时间的对象，在相当长的一段时间内仍可能继续存活。</p>
<p>这些「年老」的对象会被提升至老年代空间。出现对象提升的时候，这些对象则不会再被复制到另一个存活区，而是直接复制到老年代中，它们会一直待到不再被引用为止。</p>
<p>垃圾回收器会跟踪每个对象历经的回收次数，来判断它们是否已经「足够年老」，可以传播至老年代中。在一轮 GC 完成之后，每个分区中存活下来的对象的计数便会增加。当一个对象的年龄超过了一个特定的年老阈值之后，它便会被提升到老年代中。</p>
<p>JVM 会动态地调整实际的年龄阈值，不过通过指定 -XX:+MaxTenuringThreshold 参数可以给该值设置一个上限。将 -XX:+MaxTenuringThreshold 设置为 0 则立即触发对象提升，而不会复制到存活区中。在现代的 JVM 中，这个值默认会被设置为 15 个 GC 周期。在 HotSpot 虚拟机中这也是该值的上限。</p>
<p>如果存活区的大小不足以存放所有的新生代存活对象，则会出现过早提升。</p>
<h3 id="老生代">老生代</h3><p>老生代的内存空间的实现则更为复杂。老生代的空间通常都会非常大，里面存放的对象都是不太可能会被回收的。</p>
<p>老生代的 GC 比新生代的 GC 发生的频率要少得多。由于老生代中的多数对象都被认为是存活的，也就不会存在标记-复制操作了。在 GC 中，这些对象会被挪到一起以减少碎片。老生代的回收算法通常都是根据不同的理论来构建的。不过大体上都会分成如下几步：</p>
<ul>
<li>标记可达对象，设置 GC 根对象可达的所有对象后的标记位</li>
<li>删除不可达对象</li>
<li>整理老生代空间的对象，将存活对象复制到老生代开始的连续空间内。</li>
</ul>
<p>从以上描述中可知，为了避免过度碎片化，老生代的 GC 是明确需要进行整理操作的。</p>
<h3 id="持久代">持久代</h3><p>在 Java 8 以前还有一个特殊的空间叫做持久代（Permanent Generation）。这是元数据比如类相关数据存放的地方。除此之外，像驻留的字符串（internalized string）也会被存放在持久代中。这的确给Java开发人员带来了不少麻烦事，因为很难评估这究竟会使用到多少空间。评估不到位偏会抛出 java.lang.OutOfMemoryError: Permgen space 的异常。只要不是真的因为内存泄漏而引起的 OutOfMemoryError 异常，可以通过增加持久代空间的大小来解决这一问题，比如下例中的把持久代最大空间设置为 256MB：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:MaxPermSize=<span class="number">256</span>m com.mycompany.MyApplication</span><br></pre></td></tr></table></figure>
<h3 id="元空间">元空间</h3><p>由于元数据空间大小的预测是件繁琐且低效的工作，于是 Java 8 中干脆就去掉了持久代，转而推出了元空间。从此以后，那些个杂七杂八的东西便都存储到正常的 Java 堆了。</p>
<p>但是，类定义如今则是存储到了元空间里。它存储在本地内存中，不会与堆 内存相混杂。默认情况下，元空间的大小只受限于Java进程的可用本地内存的大小。这大大解放了开发人员，他们不会再因为多增加了一个类而引发 java.lang.OutOfMemoryError: Permgen space 异常了。值得注意的是，虽然看似元空间大小毫无限制了，但这一些并非是没有代价的——如果任由元空间无节制地增长，你可能会面临的是频繁的内存交换（swapping）或者是本地内存分配失败。</p>
<p>如果你希望避免此类情况，可以像下例中这样限制一下元空间的大小，将它设置成比如 256 MB：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:MaxMetaspaceSize=<span class="number">256</span>m com.mycompany.MyApplication</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="新生代_GC（Minor_GC）vs-_老生代_GC（Major_GC）vs-_Full_GC">新生代 GC（Minor GC）vs. 老生代 GC（Major GC）vs. Full GC</h2><p>清除堆内存不同区域的垃圾回收事件又被称为新生代 GC，老生代 GC，以及 Full GC 事件。下面我们将介绍一下不同事件的区别在哪里。不过你会发现其实各自的差别并不是那么重要。</p>
<p>重要的是我们希望知道应用是否到达它的服务能力上限了，而这又只能去监控应用的处理延时或者吞吐量。只有在这个时间GC事件才能派上用场。这些事件的关键之处在于它们是否停止了应用的运行，以及停了多久。</p>
<p>不过由于新生代 GC，老生代 GC，Full GC 这几个术语被广泛使用却又没有一个清晰的定义，我们还是先来详细地介绍一下它们的区别再说吧。</p>
<h3 id="新生代_GC">新生代 GC</h3><p>新生代垃圾的回收被称作 Minor GC。这个定义非常清晰，理解起来也不会有什么歧义。不过当处理新生代GC事件时，还是有一些有意思的东西值得注意的：</p>
<ol>
<li>只要 JVM 无法为新创建的对象分配空间，就肯定会触发新生代 GC，比方说 Eden 区满了。因此对象创建得越频繁，新生代 GC 肯定也更频繁</li>
<li>一旦内存池满了，它的所有内容就会被拷贝走，指针又将重新归零。因此和经典的标记（Mark），清除（Sweep），整理（Compact）的过程不同的是，Eden 区和 Survivor 区的清理只涉及到标记和拷贝。在它们中是不会出现碎片的。写指针始终在当前使用区的顶部</li>
<li>在一次新生代 GC 事件中，通常不涉及到年老代。年老代到年轻代的引用被认为是 GC 的根对象。而在标记阶段中，从年轻代到年老代的引用则会被忽略掉</li>
<li>和通常所理解的不一样的是，所有的新生代 GC 都会触发 stop-the-world 暂停，这会中断应用程序的线程。对绝大多数应用而言，暂停的时间是可以忽略不计的</li>
</ol>
<p>现在来看新生代 GC 还是很清晰的——每一次新生代 GC 都会对年轻代进行垃圾清除。</p>
<h3 id="老年代_GC_与_Full_GC">老年代 GC 与 Full GC</h3><p>你会发现关于这两种 GC 其实并没有明确的定义。JVM 规范或者垃圾回收相关的论文中都没有提及。不过从直觉来说，根据新生代 GC（Minor GC）清理的是新生代空间的认识来看，不难得出以下推论（这里应当从英文出发来理解，Minor, Major 与 Full GC，翻译过来的名称已经带有明显的释义了）：</p>
<ul>
<li>Major GC 清理的是老年代的空间</li>
<li>Full GC 清理的是整个堆——包括新生代与老年代空间</li>
</ul>
<p>因此我们从实际的 GC 日志中所看到的是这样——其实没有什么两次所谓的 Full GC，只有一次清理年老代空间的 Major GC 而已。</p>
<hr>
<h2 id="垃圾回收算法">垃圾回收算法</h2><h3 id="标记清除算法（Mark-Sweep）">标记清除算法（Mark-Sweep）</h3><p>通过名字就应该猜到了，就是标记哪些是可回收的，然后进行清除回收处理。</p>
<p>标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-12.png" alt=""></p>
<blockquote>
<p>优点：简单，易实现<br>缺点：容易产生内存碎片，对于后面分配大空间时，找不到足够的空间，而主动会触发一次内存回收，增加内存回收的次数。</p>
</blockquote>
<h3 id="复制算法">复制算法</h3><p>此方法将内存按容量分为两块，例如 A、B 两块，每次只使用其中的一块，当要进行回收操作时，将 A 中还存活的对象复制到 B 块中（假设上次使用 A），然后对 A 中所有对象清空就又构成一个完整的内存块。这种方法就避免了标记清除的内存碎片问题。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-13.png" alt=""></p>
<blockquote>
<p>优点：快速高效，不会产生内存碎片。<br>缺点：可用内存会减少一半，因为是按照均分的。</p>
</blockquote>
<p><strong>注意： 效率也与存活对象的多少有关，如果存活对象多，复制就多，效率就低了。</strong></p>
<h3 id="标记整理算法（Mark-Compact）">标记整理算法（Mark-Compact）</h3><p>标记整理算法就是在标记清除方法的基础上进行了优化，主要是在标记完成后将这些存活的对象向一端移动，然后将末尾边界后的所有内存空间清除。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-14.png" alt=""></p>
<blockquote>
<p>优点： 适合存活对象多的，不产生内存碎片</p>
</blockquote>
<h3 id="分代回收算法">分代回收算法</h3><p>分代回收算法其实不算一种新的算法，而是根据复制算法和标记整理算法的的特点综合而成。这种综合是考虑到 Java 的语言特性的。</p>
<p>下面来回顾一下两种老算法的适用场景：</p>
<blockquote>
<p>复制算法：适用于存活对象很少，回收对象多<br>标记整理算法: 适用用于存活对象多，回收对象少</p>
</blockquote>
<p>于是，我们根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Old Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法：</p>
<blockquote>
<p>新生代：由于新生代产生很多临时对象，大量对象需要进行回收，所以采用复制算法是最高效的。<br>老年代：回收的对象很少，都是经过几次标记后都不是可回收的状态转移到老年代的，所以仅有少量对象需要回收，故采用标记清除或者标记整理算法。</p>
</blockquote>
<p>所以以上整个过程就达到了最高效的回收办法——分代回收算法</p>
<h4 id="深入理解分代回收算法">深入理解分代回收算法</h4><p><strong>为什么不是一块 Survivor 区而是两块？</strong></p>
<blockquote>
<p>这里涉及到一个新生代和老年代的存活周期的问题，比如一个对象在新生代经历 15 次（仅供参考）GC，就可以移到老年代了。问题来了，当我们第一次 GC 的时候，我们可以把 Eden 区的存活对象放到 Survivor A区，但是第二次 GC 的时候，Survivor A 区的存活对象也需要再次用 Copying 算法，放到 Survivor B 区上，而把刚刚的 Survivor A 区和 Eden 区清除。第三次 GC 时，又把 Survivor B 区的存活对象复制到 Survivor A 区，如此反复。</p>
</blockquote>
<p>所以，这里就需要两块 Survivor 区来回倒腾。</p>
<p><strong>为什么 Eden 区这么大而 Survivor 区要分的少一点？</strong></p>
<blockquote>
<p>新创建的对象都是放在 Eden 区，这是很频繁的，尤其是大量的局部变量产生的临时对象，这些对象绝大部分都应该马上被回收，能存活下来被转移到 Survivor 区的往往不多。所以，设置较大的 Eden 区和较小的 Survivor 区是合理的，大大提高了内存的使用率，缓解了 Copying 算法的缺点。</p>
</blockquote>
<p>新的问题又来了，从 Eden 区往 Survivor 区转移的时候 Survivor 区不够了怎么办？——直接放到老年代去。</p>
<p><strong>Eden 区和两块 Survivor 区的工作流程？</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配了一个又一个对象</span></span><br><span class="line">放到 Eden 区</span><br><span class="line"><span class="comment">// 不好，Eden 区满了，只能 GC（新生代 GC：Minor GC）了</span></span><br><span class="line">把 Eden 区的存活对象 <span class="keyword">copy</span> 到 Survivor A 区，然后清空 Eden 区（本来 Survivor B 区也需要清空的，不过本来就是空的）</span><br><span class="line"><span class="comment">// 又分配了一个又一个对象</span></span><br><span class="line">放到 Eden 区</span><br><span class="line"><span class="comment">// 不好，Eden 区又满了，只能 GC（新生代 GC：Minor GC）了</span></span><br><span class="line">把 Eden 区和 Survivor A 区的存活对象 <span class="keyword">copy</span> 到 Survivor B 区，然后清空 Eden 区和 Survivor A 区</span><br><span class="line"><span class="comment">// 又分配了一个又一个对象</span></span><br><span class="line">放到 Eden 区</span><br><span class="line"><span class="comment">// 不好，Eden 区又满了，只能 GC（新生代GC：Minor GC）了</span></span><br><span class="line">把 Eden 区和 Survivor B 区的存活对象 <span class="keyword">copy</span> 到 Survivor A 区，然后清空 Eden 区和 Survivor B 区</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 有的对象来回在 Survivor A 区或者 B 区呆了比如 15 次，就被分配到老年代 Old 区</span></span><br><span class="line"><span class="comment">// 有的对象太大，超过了 Eden 区，直接被分配在 Old 区</span></span><br><span class="line"><span class="comment">// 有的存活对象，放不下 Survivor 区，也被分配到 Old 区</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 在某次 Minor GC 的过程中突然发现：</span></span><br><span class="line"><span class="comment">// 不好，老年代 Old 区也满了，这是一次大 GC（老年代 GC：Major GC）</span></span><br><span class="line">Old 区慢慢的整理一番，空间又够了</span><br><span class="line"><span class="comment">// 继续 Minor GC</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>以上为了说明原理，只是最简化版本。</p>
<hr>
<h2 id="小结">小结</h2><p>至此，关于 Java 虚拟机垃圾回收（GC）的讲解就告一段落了，后面要补的知识还很多，路还很长，一步一脚印咯：D</p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://plumbr.eu/handbook/what-is-garbage-collection" target="_blank" rel="external">JAVA Garbage Collection Handbook</a></li>
<li><a href="http://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">理解Java垃圾回收机制</a></li>
<li><a href="http://stackoverflow.com/questions/7874342/what-is-the-difference-between-objective-c-automatic-reference-counting-and-garb****" target="_blank" rel="external">What is the difference between Objective-C automatic reference counting and garbage collection?</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>说来惭愧，作为一名前 Android 开发者，对于 Java 的理解理应十分透彻才对。可不瞒你说，就在写这篇文章之前，你要是问我关于 Java 中垃圾回收（GC）的问题，我准一脸懵逼，哈哈（我居然还有脸笑）~</p>
<p>所以呢，在后继学习 iOS 开发的过程中，我特别注重原理的掌握。当然，如果你问我 Objective-C 中的内存管理机制，我肯定是有所了解的，不信你看：<a href="http://itangqi.me/2016/03/10/the-notes-of-learning-arc/">《Objective-C 高级编程》读书笔记之 ARC</a>。</p>
<blockquote>
<p>出来混，迟早是要还的。</p>
</blockquote>
<p>我想，现在也是时候把在 Java 那欠下的债清一清了，今天就来先来补一补——Java 中的垃圾回收机制。</p>]]>
    
    </summary>
    
      <category term="GC" scheme="http://itangqi.me/tags/GC/"/>
    
      <category term="JVM" scheme="http://itangqi.me/tags/JVM/"/>
    
      <category term="Java" scheme="http://itangqi.me/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[抓包工具 Charles 使用心得]]></title>
    <link href="http://itangqi.me/2016/05/30/tips-for-using-charles/"/>
    <id>http://itangqi.me/2016/05/30/tips-for-using-charles/</id>
    <published>2016-05-29T16:00:00.000Z</published>
    <updated>2016-05-30T15:01:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>虽然实习工作还没有着落，但学习还是要继续的嘛，今天就来学习使用下 Mac 下截取网络封包的工具：<a href="http://www.charlesproxy.com/" target="_blank" rel="external">Charles</a>。</p>
<p>我想，如果你是个善于利用搜索引擎的人，那么在 Google 中输入「Charles 使用」等相应的关键字，便会出现一大把文章。<br>不过呢，之所以会有这篇文章，就是因为今天在安装和初步使用的过程中，遇到了些问题，而目前搜索出来的绝大数文章并没有提及（或者解决办法已经过时）。所以，我在此记录下来，希望能帮助到通过搜索找到这的朋友们。</p>
<a id="more"></a>
<hr>
<h2 id="付费_&amp;_正版">付费 &amp; 正版</h2><blockquote>
<p>Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，使用过程中不定时会中断 5 秒钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。</p>
</blockquote>
<p>关于价格，见下表：</p>
<table>
<thead>
<tr>
<th>License</th>
<th style="text-align:center">Pricing</th>
</tr>
</thead>
<tbody>
<tr>
<td>1-4 User Licenses</td>
<td style="text-align:center">US$50 / license</td>
</tr>
<tr>
<td>5+ User Licenses</td>
<td style="text-align:center">US$40 / license (20% discount)</td>
</tr>
<tr>
<td>10+ User Licenses</td>
<td style="text-align:center">US$30 / license (40% discount)</td>
</tr>
<tr>
<td>Site License</td>
<td style="text-align:center">US$400</td>
</tr>
<tr>
<td>Multi-Site License</td>
<td style="text-align:center">US$700</td>
</tr>
</tbody>
</table>
<p>50 刀的价格虽然不白菜，但试用版并未阉割功能，只是在使用体验上稍差，这可称得上良心啊。虽然我暂时不会购买，但我依然会使用正版，希望你也如此。</p>
<hr>
<h2 id="VPN">VPN</h2><p>当我打开 Charles（Mac OS X Proxy 已选择），按理说，我立刻就能看见源源不断的网络请求出现在 Charles 的界面中啦，可为什么始终是一片空白呢？</p>
<p>一番搜索，终于在这里 <a href="http://stackoverflow.com/questions/25697849/charles-proxy-not-working-with-chrome" target="_blank" rel="external">Charles proxy not working with Chrome</a> 找到了答案：</p>
<blockquote>
<p>For anyone else using VPN: Charles must be turned on before VPN. So quitting VPN after turning on Charles won’t work either.</p>
</blockquote>
<p>没办法，为了正常使用 Charles，只能暂时把梯子撤了：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-01.png" alt=""></p>
<hr>
<h2 id="乱码">乱码</h2><p>刚开始用着挺好的啊，怎么一言不合，就来个乱码呢？</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-08.png" alt=""></p>
<p>于是，便在 Google 中输入「Charles 乱码」，我保证，你能搜到的绝对是这样的答案：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-09.jpg" alt=""></p>
<p>可我告诉你，反正我尝试了在各种地方进行添加，最后都没有成功。<br>而我最终解决了乱码的问题，但根本没有涉及到 <code>Info.plist</code>。你只要确保，我接下来提及的问题，你有正确进行设置。</p>
<h3 id="安装_SSL_证书">安装 SSL 证书</h3><h4 id="Mac_端">Mac 端</h4><blockquote>
<p>首先去 <a href="http://www.charlesproxy.com/ssl.zip" target="_blank" rel="external">http://www.charlesproxy.com/ssl.zip</a> 下载 CA 证书文件，然后双击 .crt 文件，选择「总是信任」按钮，在钥匙串访问中即可看到添加成功的证书。</p>
</blockquote>
<p>看看，人家说的多么简单啊，可事实呢？当我访问上述网址时，出现的是如下的文字：</p>
<blockquote>
<p>If you are running Charles v3.10 or later, please go to Charles and consult the SSL Proxying submenu in the Help menu, for instructions on installing your new Charles Root Certificate.</p>
</blockquote>
<p>我那蹩脚的英文告诉我：如果你使用的是 v3.10 及之后的版本，安装方法已经变了，正确的姿势：启动 Charles 软件，在菜单中找到 Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate. 如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-02.png" alt=""><a href="http://blog.devtang.com/2015/11/14/charles-introduction/" target="_blank" rel="external">图片来自</a></p>
<p>随后是这样的：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-03.jpg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-04.jpg" alt=""><a href="https://gitsea.com/2015/11/11/charles-https-%E6%8A%93%E5%8C%85-mac/" target="_blank" rel="external">图片来自</a></p>
<h4 id="iPhone_端">iPhone 端</h4><p>步骤：Help -&gt; SSL Proxying -&gt;Install Charles Root Certificate on a Mobile Device…</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-07.png" alt=""></p>
<h3 id="Mac_上的设置">Mac 上的设置</h3><ol>
<li><p>在 Charles 的工具栏上点击设置按钮，选择 SSL Proxy Settings，选中 Enable SSL Proxying。（别急，选完先别关掉）</p>
</li>
<li><p>SSL 选项卡的 Locations 里填写要抓包的域名和端口，点击 Add 按钮，在弹出的表单中 Host 填写域名。比如填api.instagram.com，Port 填 443</p>
</li>
</ol>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-11.jpg" alt=""><a href="https://gitsea.com/2015/11/11/charles-https-%E6%8A%93%E5%8C%85-mac/" target="_blank" rel="external">图片来自</a></p>
<p><strong>关于乱码，如果没有做这项操作，则肯定会出现乱码。而至于否是在 <code>Info.plist</code> 中添加 <code>UTF-8</code> 的字段，反正最后我没加，但一切正常。</strong></p>
<p>所以这个坑，我也是无意间解决的。</p>
<h3 id="iPhone_上的设置">iPhone 上的设置</h3><blockquote>
<p>首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”-&gt;”Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图所示：</p>
</blockquote>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-05.png" alt=""></p>
<p>然后就是在 iPhone 上的一系列操作，又是很简单，有木有！</p>
<p>可是，为什么尼玛我怎么试都不成果呢？！iPhone 上浏览器网址都打不开了….于是又尝试了另一种方式，在终端敲入 <code>ifconfig en0</code>：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-06.jpg" alt=""><a href="http://zhangfei.tk/2016/02/18/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/" target="_blank" rel="external">图片来自</a></p>
<p>Done! 终于可以愉快的玩耍了：）</p>
<hr>
<h2 id="参考">参考</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>虽然实习工作还没有着落，但学习还是要继续的嘛，今天就来学习使用下 Mac 下截取网络封包的工具：<a href="http://www.charlesproxy.com/">Charles</a>。</p>
<p>我想，如果你是个善于利用搜索引擎的人，那么在 Google 中输入「Charles 使用」等相应的关键字，便会出现一大把文章。<br>不过呢，之所以会有这篇文章，就是因为今天在安装和初步使用的过程中，遇到了些问题，而目前搜索出来的绝大数文章并没有提及（或者解决办法已经过时）。所以，我在此记录下来，希望能帮助到通过搜索找到这的朋友们。</p>]]>
    
    </summary>
    
      <category term="Charles" scheme="http://itangqi.me/tags/Charles/"/>
    
      <category term="Tips" scheme="http://itangqi.me/tags/Tips/"/>
    
      <category term="Mac" scheme="http://itangqi.me/categories/Mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 3.0 源码阅读笔记（七）]]></title>
    <link href="http://itangqi.me/2016/05/20/the-notes-of-learning-afnetworking-seven/"/>
    <id>http://itangqi.me/2016/05/20/the-notes-of-learning-afnetworking-seven/</id>
    <published>2016-05-19T16:00:00.000Z</published>
    <updated>2016-05-28T07:42:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>自 iOS 9 发布之后，由于新特性 <a href="https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html" target="_blank" rel="external">App Transport Security</a> 的引入，在默认行为下是不能发送 HTTP 请求的。很多网站都在转用 HTTPS，而 <code>AFNetworking</code> 中的 <code>AFSecurityPolicy</code> 就是为了阻止<a href="https://zh.wikipedia.org/zh/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" target="_blank" rel="external">中间人攻击</a>，以及其它漏洞的工具。</p>
<p><code>AFSecurityPolicy</code> 主要作用就是验证 HTTPS 请求的证书是否有效，如果应用中有一些敏感信息或者涉及交易信息，一定要使用 HTTPS 来保证交易或者用户信息的安全。</p>
<a id="more"></a>
<hr>
<h2 id="AFSSLPinningMode">AFSSLPinningMode</h2><p>使用 <code>AFSecurityPolicy</code> 时，总共有三种验证服务器是否被信任的方式：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, AFSSLPinningMode) &#123;</span><br><span class="line">    AFSSLPinningModeNone,</span><br><span class="line">    AFSSLPinningModePublicKey,</span><br><span class="line">    AFSSLPinningModeCertificate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="AFSSLPinningModeNone"><code>AFSSLPinningModeNone</code></h3><ul>
<li>这个模式不做本地证书验证（不做 SSL Pinning 操作）</li>
<li>直接从客户端系统中的受信任颁发机构 CA 列表中去验证</li>
</ul>
<h3 id="AFSSLPinningModePublicKey"><code>AFSSLPinningModePublicKey</code></h3><ul>
<li>客户端需要一份证书文件的拷贝</li>
<li>验证时只验证证书里的公钥，不验证证书的有效期等信息</li>
<li>即使伪造证书的公钥，也不能解密传输的数据，必须要私钥</li>
</ul>
<h3 id="AFSSLPinningModeCertificate"><code>AFSSLPinningModeCertificate</code></h3><ul>
<li>客户端需要一份证书文件的拷贝</li>
<li>第一步验证、先验证证书的域名/有效期等信息</li>
<li>第二步验证、对比服务端返回的证书跟客户端存储的证书是否一致</li>
</ul>
<hr>
<h2 id="初始化以及设置">初始化以及设置</h2><p>在使用 <code>AFSecurityPolicy</code> 验证服务端是否受到信任之前，要对其进行初始化，使用初始化方法时，主要目的是设置<strong>验证服务器是否受信任的方式</strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> policyWithPinningMode:pinningMode withPinnedCertificates:[<span class="keyword">self</span> defaultPinnedCertificates]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    securityPolicy<span class="variable">.SSLPinningMode</span> = pinningMode;</span><br><span class="line"></span><br><span class="line">    [securityPolicy setPinnedCertificates:pinnedCertificates];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里没有什么地方值得解释的。不过在调用 <code>pinnedCertificate</code> 的 setter 方法时，会从全部的证书中<strong>取出公钥</strong>保存到 <code>pinnedPublicKeys</code> 属性中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    _pinnedCertificates = pinnedCertificates;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.pinnedCertificates</span>) &#123;</span><br><span class="line">        <span class="built_in">NSMutableSet</span> *mutablePinnedPublicKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity:[<span class="keyword">self</span><span class="variable">.pinnedCertificates</span> count]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificate <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.pinnedCertificates</span>) &#123;</span><br><span class="line">            <span class="keyword">id</span> publicKey = AFPublicKeyForCertificate(certificate);</span><br><span class="line">            <span class="keyword">if</span> (!publicKey) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            [mutablePinnedPublicKeys addObject:publicKey];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pinnedPublicKeys</span> = [<span class="built_in">NSSet</span> setWithSet:mutablePinnedPublicKeys];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pinnedPublicKeys</span> = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里调用了 <code>AFPublicKeyForCertificate</code> 对证书进行操作，返回一个公钥。</p>
<hr>
<h2 id="操作_SecTrustRef">操作 SecTrustRef</h2><p>对 <code>serverTrust</code> 的操作的函数基本上都是 C 的 API，都定义在 <code>Security</code> 模块中，先来分析一下在上一节中 <code>AFPublicKeyForCertificate</code> 的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> AFPublicKeyForCertificate(<span class="built_in">NSData</span> *certificate) &#123;</span><br><span class="line">    <span class="comment">// 1. 初始化临时变量</span></span><br><span class="line">    <span class="keyword">id</span> allowedPublicKey = <span class="literal">nil</span>;</span><br><span class="line">    SecCertificateRef allowedCertificate;</span><br><span class="line">    SecCertificateRef allowedCertificates[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">CFArrayRef</span> tempCertificates = <span class="literal">nil</span>;</span><br><span class="line">    SecPolicyRef policy = <span class="literal">nil</span>;</span><br><span class="line">    SecTrustRef allowedTrust = <span class="literal">nil</span>;</span><br><span class="line">    SecTrustResultType result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 因为此处传入的 certificate 参数是 NSData 类型的，所以使用 `SecCertificateCreateWithData` 通过 DER 表示的数据生成一个 `SecCertificateRef` 对象，然后判断返回值是否为 `NULL`</span></span><br><span class="line">    allowedCertificate = SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificate);</span><br><span class="line">    __Require_Quiet(allowedCertificate != <span class="literal">NULL</span>, _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通过上面的 `allowedCertificate` 创建一个 `CFArray`</span></span><br><span class="line">    allowedCertificates[<span class="number">0</span>] = allowedCertificate;</span><br><span class="line">    tempCertificates = <span class="built_in">CFArrayCreate</span>(<span class="literal">NULL</span>, (<span class="keyword">const</span> <span class="keyword">void</span> **)allowedCertificates, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建一个默认的符合 X509 标准的 `SecPolicyRef`，通过默认的 `SecPolicyRef` 和证书创建一个 `SecTrustRef` 用于信任评估，对该对象进行信任评估，确认生成的 `SecTrustRef` 是值得信任的，这里使用的 __Require_noErr_Quiet 和上面的宏差不多，只是会根据返回值判断是否存在错误</span></span><br><span class="line">    policy = SecPolicyCreateBasicX509();</span><br><span class="line">    __Require_noErr_Quiet(SecTrustCreateWithCertificates(tempCertificates, policy, &amp;allowedTrust), _<span class="keyword">out</span>);</span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 获取公钥，这里的 __bridge_transfer 会将结果桥接成 NSObject 对象，然后将 SecTrustCopyPublicKey 返回的指针释放</span></span><br><span class="line">    allowedPublicKey = (__bridge_transfer <span class="keyword">id</span>)SecTrustCopyPublicKey(allowedTrust);</span><br><span class="line"></span><br><span class="line">_<span class="keyword">out</span>:</span><br><span class="line">    <span class="comment">// 6. 释放各种 C 语言指针</span></span><br><span class="line">    <span class="keyword">if</span> (allowedTrust) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(allowedTrust);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (policy) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(policy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tempCertificates) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(tempCertificates);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allowedCertificate) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(allowedCertificate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> allowedPublicKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 2 处，使用了一个非常神奇的宏 <code>__Require_Quiet</code>，它会判断 <code>allowedCertificate != NULL</code> 是否成立，如果 <code>allowedCertificate</code> 为空就会跳到 <code>_out</code> 标签处继续执行。</li>
<li>关于 DER 的概念：可参见 <a href="https://en.wikipedia.org/wiki/X.690#DER_encoding" target="_blank" rel="external">Wikipedia</a> 或者 <a href="http://blog.csdn.net/taolinke/article/details/6248968" target="_blank" rel="external">如何查看证书的16进制DER编码，及证书的各个域DER格式</a>。</li>
</ul>
<blockquote>
<p>每一个 <code>SecTrustRef</code> 的对象都是包含多个 <code>SecCertificateRef</code> 和 <code>SecPolicyRef</code>。其中 <code>SecCertificateRef</code> 可以使用 DER 进行表示，并且其中存储着公钥信息。</p>
</blockquote>
<p>对它的操作还有 <code>AFCertificateTrustChainForServerTrust</code> 和 <code>AFPublicKeyTrustChainForServerTrust</code> 但是它们几乎调用了相同的 API：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    <span class="comment">// 1. 使用 SecTrustGetCertificateCount 函数获取到 serverTrust 中需要评估的证书链中的证书数目，并保存到 certificateCount 中</span></span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line">    <span class="comment">// 2. 使用 SecTrustGetCertificateAtIndex 函数获取到证书链中的每个证书，并添加到 trustChain 中，最后返回 trustChain</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line">        <span class="comment">// 3. 使用 SecCertificateCopyData 从证书中或者 DER 表示的数据</span></span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="built_in">NSData</span> *)SecCertificateCopyData(certificate)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="验证服务端是否受信">验证服务端是否受信</h2><p>验证服务端是否守信是通过 <code>- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code> 方法进行的，也是 <code>AFSecurityPolicy</code> 类中的核心方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#1：不能隐式地信任自己签发的证书</span></span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#2：设置 policy</span></span><br><span class="line">    </span><br><span class="line">    <span class="preprocessor">#3：验证证书是否有效</span></span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#4：根据 SSLPinningMode 对服务端进行验证</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-_不能隐式地信任自己签发的证书">1. 不能隐式地信任自己签发的证书</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span><span class="variable">.allowInvalidCertificates</span> &amp;&amp; <span class="keyword">self</span><span class="variable">.validatesDomainName</span> &amp;&amp; (<span class="keyword">self</span><span class="variable">.SSLPinningMode</span> == AFSSLPinningModeNone || [<span class="keyword">self</span><span class="variable">.pinnedCertificates</span> count] == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"In order to validate a domain name for self signed certificates, you MUST use pinning."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).<br>Instead, add your own (self-signed) CA certificate to the list of trusted anchors.</p>
</blockquote>
<p>所以如果没有提供证书或者不验证证书，并且还设置 <code>allowInvalidCertificates</code> 为<strong>真</strong>，满足上面的所有条件，说明这次的验证是不安全的，会直接返回 <code>NO</code>。</p>
<h3 id="2-_设置_policy">2. 设置 policy</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.validatesDomainName</span>) &#123;</span><br><span class="line">    [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要验证域名的话，就以域名为参数创建一个 <code>SecPolicyRef</code>，否则会创建一个符合 X509 标准的默认 <code>SecPolicyRef</code> 对象。</p>
<h3 id="3-_验证证书的有效性">3. 验证证书的有效性</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.SSLPinningMode</span> == AFSSLPinningModeNone) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.allowInvalidCertificates</span> || AFServerTrustIsValid(serverTrust);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class="keyword">self</span><span class="variable">.allowInvalidCertificates</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果<strong>只根据信任列表中的证书</strong>进行验证，即 <code>self.SSLPinningMode == AFSSLPinningModeNone</code>。如果允许无效的证书的就会直接返回 <code>YES</code>。不允许就会对服务端信任进行验证</p>
</li>
<li><p>如果服务器信任无效，并且不允许无效证书，就会返回 <code>NO</code></p>
</li>
</ul>
<h3 id="4-_根据_SSLPinningMode_对服务器信任进行验证">4. 根据 <code>SSLPinningMode</code> 对服务器信任进行验证</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">self</span><span class="variable">.SSLPinningMode</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> AFSSLPinningModeNone:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AFSSLPinningModeNone_直接返回_NO"><code>AFSSLPinningModeNone</code> 直接返回 <code>NO</code></h4><h4 id="AFSSLPinningModeCertificate-1"><code>AFSSLPinningModeCertificate</code></h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.pinnedCertificates</span>) &#123;</span><br><span class="line">    [pinnedCertificates addObject:(__bridge_transfer <span class="keyword">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</span><br><span class="line">&#125;</span><br><span class="line">SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it's the Root CA)</span></span><br><span class="line"><span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line">            </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.pinnedCertificates</span> containsObject:trustChainCertificate]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>从 <code>self.pinnedCertificates</code> 中获取 DER 表示的数据</li>
<li>使用 <code>SecTrustSetAnchorCertificates</code> 为服务器信任设置证书</li>
<li>判断服务器信任的有效性</li>
<li>使用 <code>AFCertificateTrustChainForServerTrust</code> 获取服务器信任中的全部 DER 表示的证书</li>
<li>如果 <code>pinnedCertificates</code> 中有相同的证书，就会返回 <code>YES</code></li>
</ol>
<h4 id="AFSSLPinningModePublicKey-1"><code>AFSSLPinningModePublicKey</code></h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.pinnedPublicKeys</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">            trustedPublicKeyCount += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这部分的实现和上面的差不多，区别有两点：</p>
<ol>
<li>会从服务器信任中获取公钥</li>
<li><code>pinnedPublicKeys</code> 中的公钥与服务器信任中的公钥相同的数量大于 0，就会返回真</li>
</ol>
<hr>
<h2 id="与_AFURLSessionManager_协作">与 AFURLSessionManager 协作</h2><p>在代理协议 <code>- URLSession:didReceiveChallenge:completionHandler:</code> 或者 <code>- URLSession:task:didReceiveChallenge:completionHandler:</code> 代理方法被调用时会运行这段代码</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([challenge<span class="variable">.protectionSpace</span><span class="variable">.authenticationMethod</span> isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.securityPolicy</span> evaluateServerTrust:challenge<span class="variable">.protectionSpace</span><span class="variable">.serverTrust</span> forDomain:challenge<span class="variable">.protectionSpace</span><span class="variable">.host</span>]) &#123;</span><br><span class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">        credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge<span class="variable">.protectionSpace</span><span class="variable">.serverTrust</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengeRejectProtectionSpace</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NSURLAuthenticationChallenge</code> 表示一个认证的挑战，提供了关于这次认证的全部信息。它有一个非常重要的属性 <code>protectionSpace</code>，这里保存了需要认证的保护空间, 每一个 <code>NSURLProtectionSpace</code> 对象都保存了主机地址，端口和认证方法等重要信息。</p>
<p>在上面的方法中，如果保护空间中的认证方法为 <code>NSURLAuthenticationMethodServerTrust</code>，那么就会使用在上一小节中提到的方法 <code>- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code> 对保护空间中的 <code>serverTrust</code> 以及域名 <code>host</code> 进行认证</p>
<p>根据认证的结果，会在 <code>completionHandler</code> 中传入不同的 <code>disposition</code> 和 <code>credential</code> 参数。</p>
<hr>
<h2 id="小结">小结</h2><ul>
<li><code>AFSecurityPolicy</code> 同样也作为一个<strong>即插即用</strong>的模块，在 AFNetworking 中作为验证 HTTPS 证书是否有效的模块存在，在 iOS 对 HTTPS 日渐重视的今天，在我看来，使用 HTTPS 会成为今后 API 开发的标配。</li>
</ul>
<hr>
<h2 id="总结">总结</h2><p>到这里，AFNetworking 源码阅读之旅（UIKit+AFNetworking 除外）就要告一段落了，定有许多不足与遗憾。不过没关系，就让我们去实践中将理论升华，想必到时候一定会有一番新的体会。</p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/AFNetworking/%E9%AA%8C%E8%AF%81%20HTTPS%20%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%81%E4%B9%A6%EF%BC%88%E4%BA%94%EF%BC%89.md" target="_blank" rel="external">验证 HTTPS 请求的证书（五）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>自 iOS 9 发布之后，由于新特性 <a href="https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html">App Transport Security</a> 的引入，在默认行为下是不能发送 HTTP 请求的。很多网站都在转用 HTTPS，而 <code>AFNetworking</code> 中的 <code>AFSecurityPolicy</code> 就是为了阻止<a href="https://zh.wikipedia.org/zh/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击</a>，以及其它漏洞的工具。</p>
<p><code>AFSecurityPolicy</code> 主要作用就是验证 HTTPS 请求的证书是否有效，如果应用中有一些敏感信息或者涉及交易信息，一定要使用 HTTPS 来保证交易或者用户信息的安全。</p>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://itangqi.me/tags/AFNetworking/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="Source Code" scheme="http://itangqi.me/tags/Source-Code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 3.0 源码阅读笔记（六）]]></title>
    <link href="http://itangqi.me/2016/05/17/the-notes-of-learning-afnetworking-six/"/>
    <id>http://itangqi.me/2016/05/17/the-notes-of-learning-afnetworking-six/</id>
    <published>2016-05-16T16:00:00.000Z</published>
    <updated>2016-05-28T07:41:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p><code>AFNetworkReachabilityManager</code> 是对 <code>SystemConfiguration</code> 模块的封装，苹果的文档中也有一个类似的项目 <a href="https://developer.apple.com/library/ios/samplecode/reachability/" target="_blank" rel="external">Reachability</a> 这里对网络状态的监控跟苹果官方的实现几乎是完全相同的。</p>
<p>同样在 GitHub 上有一个类似的项目叫做 <a href="https://github.com/tonymillion/Reachability" target="_blank" rel="external">Reachability</a> 不过这个项目<strong>由于命名的原因可能会在审核时被拒绝</strong>。</p>
<p>无论是 <code>AFNetworkReachabilityManager</code>，苹果官方的项目或者说 GitHub 上的 Reachability，它们的实现都是类似的，而在这里我们会以 <code>AFNetworking</code> 中的 <code>AFNetworkReachabilityManager</code> 为例来说明在 iOS 开发中，我们是怎样监控网络状态的。</p>
<a id="more"></a>
<hr>
<h2 id="AFNetworkReachabilityManager_的使用和实现">AFNetworkReachabilityManager 的使用和实现</h2><p><code>AFNetworkReachabilityManager</code> 的使用还是非常简单的，只需要三个步骤，就基本可以完成对网络状态的监控：</p>
<ol>
<li><a href="#init">初始化 <code>AFNetworkReachabilityManager</code></a></li>
<li><a href="#monitor">调用 <code>startMonitoring</code> 方法开始对网络状态进行监控</a></li>
<li><a href="#block">设置 <code>networkReachabilityStatusBlock</code> 在每次网络状态改变时, 调用这个 block</a></li>
</ol>
<h3 id="初始化_AFNetworkReachabilityManager"><a id="init"></a>初始化 AFNetworkReachabilityManager</h3><p>在初始化方法中，使用 <code>SCNetworkReachabilityCreateWithAddress</code> 或者 <code>SCNetworkReachabilityCreateWithName</code> 生成一个 <code>SCNetworkReachabilityRef</code> 的引用：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)managerForDomain:(<span class="built_in">NSString</span> *)domain &#123;</span><br><span class="line">    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(k<span class="built_in">CFAllocatorDefault</span>, [domain UTF8String]);</span><br><span class="line"></span><br><span class="line">    AFNetworkReachabilityManager *manager = [[<span class="keyword">self</span> alloc] initWithReachability:reachability];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)managerForAddress:(<span class="keyword">const</span> <span class="keyword">void</span> *)address &#123;</span><br><span class="line">    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithAddress(k<span class="built_in">CFAllocatorDefault</span>, (<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *)address);</span><br><span class="line">    AFNetworkReachabilityManager *manager = [[<span class="keyword">self</span> alloc] initWithReachability:reachability];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>这两个方法会通过一个<strong>域名</strong>或者一个 <code>sockaddr_in</code> 的指针生成一个 <code>SCNetworkReachabilityRef</code></li>
<li>调用 <code>- [AFNetworkReachabilityManager initWithReachability:]</code> 将生成的 <code>SCNetworkReachabilityRef</code> 引用传给 <code>networkReachability</code></li>
<li>设置一个默认的 <code>networkReachabilityStatus</code></li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.networkReachability</span> = <span class="built_in">CFBridgingRelease</span>(reachability);</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.networkReachabilityStatus</span> = AFNetworkReachabilityStatusUnknown;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当调用 <code>CFBridgingRelease(reachability)</code> 后，会把 <code>reachability</code> 桥接成一个 NSObject 对象赋值给 <code>self.networkReachability</code>，然后释放原来的 CoreFoundation 对象。</p>
</blockquote>
<h3 id="监控网络状态"><a id="monitor"></a>监控网络状态</h3><p>在初始化 <code>AFNetworkReachabilityManager</code> 后，会调用 <code>startMonitoring</code> 方法开始监控网络状态：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startMonitoring &#123;</span><br><span class="line">    <span class="comment">// 1. 先调用 `- stopMonitoring` 方法，如果之前设置过对网络状态的监听，使用 `SCNetworkReachabilityUnscheduleFromRunLoop` 方法取消之前在 Main Runloop 中的监听</span></span><br><span class="line">    [<span class="keyword">self</span> stopMonitoring];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.networkReachability</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 2. 创建一个在每次网络状态改变时的回调</span></span><br><span class="line">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">        strongSelf<span class="variable">.networkReachabilityStatus</span> = status;</span><br><span class="line">        <span class="keyword">if</span> (strongSelf<span class="variable">.networkReachabilityStatusBlock</span>) &#123;</span><br><span class="line">            strongSelf<span class="variable">.networkReachabilityStatusBlock</span>(status);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> networkReachability = <span class="keyword">self</span><span class="variable">.networkReachability</span>;</span><br><span class="line">    <span class="comment">// 3. 创建一个 `SCNetworkReachabilityContext`，其中的 `callback` 就是上一步中的创建的 block 对象</span></span><br><span class="line">    SCNetworkReachabilityContext context = &#123;<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="comment">// 4. 当目标的网络状态改变时，会调用传入的回调</span></span><br><span class="line">    SCNetworkReachabilitySetCallback((__bridge SCNetworkReachabilityRef)networkReachability, AFNetworkReachabilityCallback, &amp;context);</span><br><span class="line">    <span class="comment">// 5. 在 Main Runloop 中对应的模式开始监控网络状态</span></span><br><span class="line">    SCNetworkReachabilityScheduleWithRunLoop((__bridge SCNetworkReachabilityRef)networkReachability, <span class="built_in">CFRunLoopGetMain</span>(), k<span class="built_in">CFRunLoopCommonModes</span>);</span><br><span class="line">    <span class="comment">// 6. 获取当前的网络状态，调用 callback</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>),^&#123;</span><br><span class="line">        SCNetworkReachabilityFlags flags;</span><br><span class="line">        <span class="keyword">if</span> (SCNetworkReachabilityGetFlags((__bridge SCNetworkReachabilityRef)networkReachability, &amp;flags)) &#123;</span><br><span class="line">            AFPostReachabilityStatusChange(flags, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1. 关于 <code>AFNetworkReachabilityStatus</code></strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, AFNetworkReachabilityStatus) &#123;</span><br><span class="line">    AFNetworkReachabilityStatusUnknown          = -<span class="number">1</span>,</span><br><span class="line">    AFNetworkReachabilityStatusNotReachable     = <span class="number">0</span>,</span><br><span class="line">    AFNetworkReachabilityStatusReachableViaWWAN = <span class="number">1</span>,</span><br><span class="line">    AFNetworkReachabilityStatusReachableViaWiFi = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2. 关于 <code>SCNetworkReachabilityContext</code></strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 SCNetworkReachabilityContext 结构体时，需要调用 SCDynamicStore 的创建函数，而此创建函数会根据 version 来创建出不同的结构体，SCNetworkReachabilityContext 对应的 version 是 0</span></span><br><span class="line">    <span class="built_in">CFIndex</span>		version;</span><br><span class="line">    <span class="comment">// 下面两个block（release 和 retain）的参数就是 info，此处表示的是网络状态处理的回调函数</span></span><br><span class="line">    <span class="keyword">void</span> *		__nullable info;</span><br><span class="line">    <span class="comment">// 该 retain block 用于对 info 进行 retain，下面那个 AFNetworkReachabilityRetainCallback 核心就是调用了 Block_copy（用于 retain 一个 block 函数，即在堆空间新建或直接引用一个 block 拷贝）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>	* __nonnull (* __nullable retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="comment">// 该 release block 用于对 info 进行 release，下面那个 AFNetworkReachabilityReleaseCallback 核心就是调用了 Block_release（用于 release 一个 block 函数，即将 block 从堆空间移除或移除相应引用）</span></span><br><span class="line">    <span class="keyword">void</span>		(* __nullable release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="comment">// 提供 info 的 description，此处调用为 NULL</span></span><br><span class="line">    <span class="built_in">CFStringRef</span>	__nonnull (* __nullable copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">&#125; SCNetworkReachabilityContext;</span><br></pre></td></tr></table></figure>
<p>在下一节中会介绍上面所提到的一些 C 函数以及各种回调。</p>
<h3 id="设置_networkReachabilityStatusBlock_以及回调"><a id="block"></a>设置 networkReachabilityStatusBlock 以及回调</h3><p>在 Main Runloop 中对网络状态进行监控之后，在每次网络状态改变，就会调用 <code>AFNetworkReachabilityCallback</code> 函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> AFNetworkReachabilityCallback(SCNetworkReachabilityRef __unused target, SCNetworkReachabilityFlags flags, <span class="keyword">void</span> *info) &#123;</span><br><span class="line">    AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会从 <code>info</code> 中取出之前存在 <code>context</code> 中的 <code>AFNetworkReachabilityStatusBlock</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">    strongSelf<span class="variable">.networkReachabilityStatus</span> = status;</span><br><span class="line">    <span class="keyword">if</span> (strongSelf<span class="variable">.networkReachabilityStatusBlock</span>) &#123;</span><br><span class="line">        strongSelf<span class="variable">.networkReachabilityStatusBlock</span>(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>取出这个 block 之后，传入 <code>AFPostReachabilityStatusChange</code> 函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block) &#123;</span><br><span class="line">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (block) &#123;</span><br><span class="line">            block(status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSNotificationCenter</span> *notificationCenter = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *userInfo = @&#123; AFNetworkingReachabilityNotificationStatusItem: @(status) &#125;;</span><br><span class="line">        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:<span class="literal">nil</span> userInfo:userInfo];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>调用 <code>AFNetworkReachabilityStatusForFlags</code> 获取当前的网络可达性状态</li>
<li><strong>在主线程中异步执行</strong>上面传入的 <code>callback</code> block（设置 <code>self</code> 的网络状态，调用 <code>networkReachabilityStatusBlock</code>）</li>
<li>发送 <code>AFNetworkingReachabilityDidChangeNotification</code> 通知.</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(SCNetworkReachabilityFlags flags) &#123;</span><br><span class="line">    <span class="comment">// 该网络地址可达</span></span><br><span class="line">    <span class="built_in">BOOL</span> isReachable = ((flags &amp; kSCNetworkReachabilityFlagsReachable) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 该网络地址虽然可达，但是需要先建立一个 connection</span></span><br><span class="line">    <span class="built_in">BOOL</span> needsConnection = ((flags &amp; kSCNetworkReachabilityFlagsConnectionRequired) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 该网络虽然也需要先建立一个 connection，但是它是可以自动去 connect 的</span></span><br><span class="line">    <span class="built_in">BOOL</span> canConnectionAutomatically = (((flags &amp; kSCNetworkReachabilityFlagsConnectionOnDemand ) != <span class="number">0</span>) || ((flags &amp; kSCNetworkReachabilityFlagsConnectionOnTraffic) != <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 不需要用户交互，就可以 connect 上（用户交互一般指的是提供网络的账户和密码）</span></span><br><span class="line">    <span class="built_in">BOOL</span> canConnectWithoutUserInteraction = (canConnectionAutomatically &amp;&amp; (flags &amp; kSCNetworkReachabilityFlagsInterventionRequired) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果 isReachable==YES，那么就需要判断是不是得先建立一个 connection，如果需要，那就认为不可达，或者虽然需要先建立一个 connection，但是不需要用户交互，那么认为也是可达的</span></span><br><span class="line">    <span class="built_in">BOOL</span> isNetworkReachable = (isReachable &amp;&amp; (!needsConnection || canConnectWithoutUserInteraction));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  AFNetworkReachabilityStatus 就四种状态 Unknown、NotReachable、ReachableViaWWAN、ReachableViaWiFi，这四种状态字面意思很好理解，这里就不赘述了</span></span><br><span class="line">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusUnknown;</span><br><span class="line">    <span class="keyword">if</span> (isNetworkReachable == <span class="literal">NO</span>) &#123;</span><br><span class="line">        status = AFNetworkReachabilityStatusNotReachable;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#if	TARGET_OS_IPHONE</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; kSCNetworkReachabilityFlagsIsWWAN) != <span class="number">0</span>) &#123;</span><br><span class="line">        status = AFNetworkReachabilityStatusReachableViaWWAN;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        status = AFNetworkReachabilityStatusReachableViaWiFi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>flags</code> 是一个 <code>SCNetworkReachabilityFlags</code>，它的不同位代表了不同的网络可达性状态，通过 <code>flags</code> 的位操作，获取当前的状态信息 <code>AFNetworkReachabilityStatus</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(uint32_t, SCNetworkReachabilityFlags) &#123;</span><br><span class="line">    kSCNetworkReachabilityFlagsTransientConnection = <span class="number">1</span>&lt;&lt;<span class="number">0</span>,</span><br><span class="line">    kSCNetworkReachabilityFlagsReachable = <span class="number">1</span>&lt;&lt;<span class="number">1</span>,</span><br><span class="line">    kSCNetworkReachabilityFlagsConnectionRequired = <span class="number">1</span>&lt;&lt;<span class="number">2</span>,</span><br><span class="line">    kSCNetworkReachabilityFlagsConnectionOnTraffic = <span class="number">1</span>&lt;&lt;<span class="number">3</span>,</span><br><span class="line">    kSCNetworkReachabilityFlagsInterventionRequired = <span class="number">1</span>&lt;&lt;<span class="number">4</span>,</span><br><span class="line">    kSCNetworkReachabilityFlagsConnectionOnDemand = <span class="number">1</span>&lt;&lt;<span class="number">5</span>, <span class="comment">// __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_3_0)</span></span><br><span class="line">    kSCNetworkReachabilityFlagsIsLocalAddress = <span class="number">1</span>&lt;&lt;<span class="number">16</span>,</span><br><span class="line">    kSCNetworkReachabilityFlagsIsDirect = <span class="number">1</span>&lt;&lt;<span class="number">17</span>,</span><br><span class="line"><span class="preprocessor">#if  TARGET_OS_IPHONE</span></span><br><span class="line">    kSCNetworkReachabilityFlagsIsWWAN = <span class="number">1</span>&lt;&lt;<span class="number">18</span>,</span><br><span class="line"><span class="preprocessor">#endif  // TARGET_OS_IPHONE</span></span><br><span class="line"></span><br><span class="line">    kSCNetworkReachabilityFlagsConnectionAutomatic = kSCNetworkReachabilityFlagsConnectionOnTraffic</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里就是在 <code>SystemConfiguration</code> 中定义的全部的网络状态的标志位。</p>
<hr>
<h2 id="与_AFNetworking_协作">与 AFNetworking 协作</h2><p>其实 <code>AFNetworkReachabilityManager</code> 与 <code>AFNetworking</code> 整个框架并没有太多的耦合。正相反，它在整个框架中作为一个<strong>即插即用</strong>的类使用，每一个 <code>AFURLSessionManager</code> 都会持有一个 <code>AFNetworkReachabilityManager</code> 的实例。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.reachabilityManager</span> = [AFNetworkReachabilityManager sharedManager];</span><br></pre></td></tr></table></figure>
<p>这是整个框架中除了 <code>AFNetworkReachabilityManager.h/m</code> 文件，<strong>唯一一个</strong>引用到这个类的地方。</p>
<hr>
<h2 id="总结">总结</h2><ul>
<li><code>AFNetworkReachabilityManager</code> 实际上只是对底层 <code>SystemConfiguration</code> 库中的 C 函数封装的类（类似于 GCD），它为我们隐藏了 C 语言的实现，提供了统一且简洁的 Objective-C 语言接口</li>
<li>它是 <code>AFNetworking</code> 中一个即插即用的模块</li>
</ul>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/AFNetworking/AFNetworkReachabilityManager%20%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%EF%BC%88%E5%9B%9B%EF%BC%89.md" target="_blank" rel="external">AFNetworkReachabilityManager 监控网络状态（四）</a></li>
<li><a href="http://www.cnblogs.com/polobymulberry/p/5174298.html" target="_blank" rel="external">【原】AFNetworking源码阅读（六）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p><code>AFNetworkReachabilityManager</code> 是对 <code>SystemConfiguration</code> 模块的封装，苹果的文档中也有一个类似的项目 <a href="https://developer.apple.com/library/ios/samplecode/reachability/">Reachability</a> 这里对网络状态的监控跟苹果官方的实现几乎是完全相同的。</p>
<p>同样在 GitHub 上有一个类似的项目叫做 <a href="https://github.com/tonymillion/Reachability">Reachability</a> 不过这个项目<strong>由于命名的原因可能会在审核时被拒绝</strong>。</p>
<p>无论是 <code>AFNetworkReachabilityManager</code>，苹果官方的项目或者说 GitHub 上的 Reachability，它们的实现都是类似的，而在这里我们会以 <code>AFNetworking</code> 中的 <code>AFNetworkReachabilityManager</code> 为例来说明在 iOS 开发中，我们是怎样监控网络状态的。</p>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://itangqi.me/tags/AFNetworking/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="Source Code" scheme="http://itangqi.me/tags/Source-Code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 3.0 源码阅读笔记（五）]]></title>
    <link href="http://itangqi.me/2016/05/15/the-notes-of-learning-afnetworking-five/"/>
    <id>http://itangqi.me/2016/05/15/the-notes-of-learning-afnetworking-five/</id>
    <published>2016-05-14T16:00:00.000Z</published>
    <updated>2016-05-28T07:41:22.000Z</updated>
    <content type="html"><![CDATA[<h2 id="AFURLRequestSerialization">AFURLRequestSerialization</h2><p><code>AFURLRequestSerialization</code> 定义为协议，其主要工作是对发出的 HTTP 请求进行处理：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLRequestSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (nullable <span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(nullable <span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>遵循该协议的类同时也要遵循 NSObject、NSSecureCoding 和 NSCopying 这三个协议，以实现 Objective-C 对象的基本行为、安全编码以及拷贝。</p>
<a id="more"></a>
<h3 id="AFHTTPRequestSerializer">AFHTTPRequestSerializer</h3><p>而在 <code>AFURLRequestSerialization</code> 模块中，最为重要的类便是 <code>AFHTTPRequestSerializer</code>，其主要作用为：</p>
<ol>
<li>处理查询的 URL 参数</li>
<li>设置 HTTP 头部字段</li>
<li>设置请求的属性</li>
<li>分块上传</li>
</ol>
<blockquote>
<p>这篇文章不会对其中涉及分块上传的部分进行分析，因为其中涉及到了多个类的功能，比较复杂，如果有兴趣可以研究一下。</p>
</blockquote>
<h3 id="处理查询参数">处理查询参数</h3><p>处理查询参数这部分主要是通过 <code>AFQueryStringPair</code> 还有一些 <strong>C 函数</strong>来完成的，这个类有两个属性 <code>field</code> 和 <code>value</code> 对应 HTTP 请求的查询 URL 中的参数。</p>
<p>我们来看初始化方法，其中的 <code>- (NSString *)URLEncodedStringValue</code> 方法会返回 <code>key=value</code> 这种格式，同时使用 <code>AFPercentEscapedStringFromString</code> 函数来对 <code>field</code> 和 <code>value</code> 进行处理，将其中的 <code>:#[]@!$&amp;&#39;()*+,;=</code> 等字符转换为百分号表示的形式：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithField:(<span class="keyword">id</span>)field value:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.field</span> = field;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.value</span> = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)URLEncodedStringValue &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.value</span> || [<span class="keyword">self</span><span class="variable">.value</span> isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFPercentEscapedStringFromString([<span class="keyword">self</span><span class="variable">.field</span> description]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@=%@"</span>, AFPercentEscapedStringFromString([<span class="keyword">self</span><span class="variable">.field</span> description]), AFPercentEscapedStringFromString([<span class="keyword">self</span><span class="variable">.value</span> description])];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分代码还负责返回查询参数，将 <code>AFQueryStringPair</code> 或者 <code>key</code> <code>value</code> 转换为以下这种形式：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username = dravenss&amp;password=<span class="number">123456</span>&amp;hello<span class="string">[world]</span>=helloworld</span><br></pre></td></tr></table></figure>
<p>它的实现主要依赖于一个递归函数 <code>AFQueryStringPairsFromKeyAndValue</code>，如果当前的 <code>value</code> 是一个集合类型的话，那么它就会不断地递归调用自己：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromKeyAndValue(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutableQueryStringComponents = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSSortDescriptor</span> *sortDescriptor = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"description"</span> ascending:<span class="literal">YES</span> selector:<span class="keyword">@selector</span>(compare:)];	 </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后返回一个数组</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    username = draveness,</span><br><span class="line">    password = <span class="number">123456</span>,</span><br><span class="line">    hello[world] = helloworld</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>得到这个数组之后就会调用 <code>AFQueryStringFromParameters</code> 使用 <code>&amp;</code> 来拼接它们：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * AFQueryStringFromParameters(<span class="built_in">NSDictionary</span> *parameters) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutablePairs = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (AFQueryStringPair *pair <span class="keyword">in</span> AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [mutablePairs componentsJoinedByString:<span class="string">@"&amp;"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置_HTTP_头部字段">设置 HTTP 头部字段</h3><p><code>AFHTTPRequestSerializer</code> 在头文件中提供了一些属性方便我们设置 HTTP 头部字段。同时，在类的内部，它提供了 <code>- [AFHTTPRequestSerializer setValue:forHTTPHeaderField:]</code> 方法来设置 HTTP 头部，其实它的实现都是基于一个名为 <code>mutableHTTPRequestHeaders</code> 的属性的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="built_in">NSString</span> *)value</span><br><span class="line">forHTTPHeaderField:(<span class="built_in">NSString</span> *)field</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mutableHTTPRequestHeaders</span> setValue:value forKey:field];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)valueForHTTPHeaderField:(<span class="built_in">NSString</span> *)field &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.mutableHTTPRequestHeaders</span> valueForKey:field];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在设置 HTTP 头部字段时，都会存储到这个可变字典中。而当真正使用时，会用 <code>HTTPRequestHeaders</code> 这个方法，来获取对应版本的不可变字典：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span> *)HTTPRequestHeaders &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:<span class="keyword">self</span><span class="variable">.mutableHTTPRequestHeaders</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了这里，可以来分析一下，这个类是如何设置一些我们平时常用的头部字段的。首先是 <code>User-Agent</code>，在 <code>AFHTTPRequestSerializer</code> 刚刚初始化时，就会根据当前编译的平台生成一个 <code>userAgent</code> 字符串：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userAgent = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@/%@ (%@; iOS %@; Scale/%0.2f)"</span>, [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)k<span class="built_in">CFBundleExecutableKey</span>] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)k<span class="built_in">CFBundleIdentifierKey</span>], [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][<span class="string">@"CFBundleShortVersionString"</span>] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)k<span class="built_in">CFBundleVersionKey</span>], [[<span class="built_in">UIDevice</span> currentDevice] model], [[<span class="built_in">UIDevice</span> currentDevice] systemVersion], [[<span class="built_in">UIScreen</span> mainScreen] scale]];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> setValue:userAgent forHTTPHeaderField:<span class="string">@"User-Agent"</span>];</span><br></pre></td></tr></table></figure>
<p>设置验证字段时，可以使用 <code>- [AFHTTPRequestSerializer setAuthorizationHeaderFieldWithUsername:password:]</code> 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAuthorizationHeaderFieldWithUsername:(<span class="built_in">NSString</span> *)username</span><br><span class="line">                                       password:(<span class="built_in">NSString</span> *)password</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSData</span> *basicAuthCredentials = [[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@:%@"</span>, username, password] dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *base64AuthCredentials = [basicAuthCredentials base64EncodedStringWithOptions:(<span class="built_in">NSDataBase64EncodingOptions</span>)<span class="number">0</span>];</span><br><span class="line">    [<span class="keyword">self</span> setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Basic %@"</span>, base64AuthCredentials] forHTTPHeaderField:<span class="string">@"Authorization"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置请求的属性">设置请求的属性</h3><p>还有一些 <code>NSURLRequest</code> 的属性是通过另一种方式来设置的，AFNetworking 为这些功能提供了接口：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> allowsCellularAccess;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSURLRequestCachePolicy</span> cachePolicy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> HTTPShouldHandleCookies;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> HTTPShouldUsePipelining;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSURLRequestNetworkServiceType</span> networkServiceType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> timeoutInterval;</span><br></pre></td></tr></table></figure>
<p>它们都会通过 <code>AFHTTPRequestSerializerObservedKeyPaths</code> 的调用而返回：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFHTTPRequestSerializerObservedKeyPaths() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSArray</span> *_AFHTTPRequestSerializerObservedKeyPaths = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _AFHTTPRequestSerializerObservedKeyPaths = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(allowsCellularAccess)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(cachePolicy)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldHandleCookies)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldUsePipelining)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(networkServiceType)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(timeoutInterval))];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _AFHTTPRequestSerializerObservedKeyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这些属性被设置时，会触发 KVO，然后将新的属性存储在一个名为 <code>mutableObservedChangedKeyPaths</code> 的字典中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(__unused <span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">                       context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == AFHTTPRequestSerializerObserverContext) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeNewKey</span>] isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.mutableObservedChangedKeyPaths</span> removeObject:keyPath];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.mutableObservedChangedKeyPaths</span> addObject:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后会在生成 <code>NSURLRequest</code> 的时候设置这些属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class="line">mutableRequest<span class="variable">.HTTPMethod</span> = method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.mutableObservedChangedKeyPaths</span> containsObject:keyPath]) &#123;</span><br><span class="line">        [mutableRequest setValue:[<span class="keyword">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这个方法的的具体实现会在下一节中介绍。</p>
<h3 id="工作流程">工作流程</h3><p><code>AFHTTPRequestSerializer</code> 会在 <code>AHHTTPSessionManager</code> 初始化时一并初始化，这时它会根据当前系统环境预设置一些 HTTP 头部字段 <code>Accept-Language</code> <code>User-Agent</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.stringEncoding</span> = <span class="built_in">NSUTF8StringEncoding</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mutableHTTPRequestHeaders</span> = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#1: 设置接收语言，用户代理，略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.HTTPMethodsEncodingParametersInURI</span> = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"GET"</span>, <span class="string">@"HEAD"</span>, <span class="string">@"DELETE"</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mutableObservedChangedKeyPaths</span> = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="built_in">NSSelectorFromString</span>(keyPath)]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:keyPath options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:AFHTTPRequestSerializerObserverContext];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时它还对一些属性进行 KVO，确保它们在改变后更新 <code>NSMutableURLRequest</code> 中对应的属性。</p>
<p>在初始化之后，如果调用了 <code>- [AFHTTPSessionManager dataTaskWithHTTPMethod:URLString:parameters:uploadProgress:downloadProgress:success:failure:]</code>，就会进入 <code>AFHTTPRequestSerializer</code> 的这一方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                     error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(method);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(URLString);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</span><br><span class="line">    <span class="comment">// 1. 对参数进行检查</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(url);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class="line">    <span class="comment">// 2. 设置 HTTP 方法</span></span><br><span class="line">    mutableRequest<span class="variable">.HTTPMethod</span> = method;</span><br><span class="line">    <span class="comment">// 3. 通过 `mutableObservedChangedKeyPaths` 字典设置 `NSMutableURLRequest` 的属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.mutableObservedChangedKeyPaths</span> containsObject:keyPath]) &#123;</span><br><span class="line">            [mutableRequest setValue:[<span class="keyword">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 HTTP 头部字段和查询参数</span></span><br><span class="line">    mutableRequest = [[<span class="keyword">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>- [AFHTTPRequestSerializer  requestBySerializingRequest:withParameters:error:]</code> 方法主要做了以下几件事情：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class="line">    <span class="comment">// 1. 通过 `HTTPRequestHeaders` 字典设置头部字段</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.HTTPRequestHeaders</span> enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> field, <span class="keyword">id</span> value, <span class="built_in">BOOL</span> * __unused stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *query = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.queryStringSerialization</span>) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError;</span><br><span class="line">            query = <span class="keyword">self</span><span class="variable">.queryStringSerialization</span>(request, parameters, &amp;serializationError);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    *error = serializationError;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">self</span><span class="variable">.queryStringSerializationStyle</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">                    <span class="comment">// 2. 调用 `AFQueryStringFromParameters` 将参数转换为查询参数</span></span><br><span class="line">                    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 将 parameters 添加到 URL 或者 HTTP body 中</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.HTTPMethodsEncodingParametersInURI</span> containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query) &#123;</span><br><span class="line">            mutableRequest<span class="variable">.URL</span> = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest<span class="variable">.URL</span> absoluteString] stringByAppendingFormat:mutableRequest<span class="variable">.URL</span><span class="variable">.query</span> ? <span class="string">@"&amp;%@"</span> : <span class="string">@"?%@"</span>, query]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class="line">        <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">            query = <span class="string">@""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@"Content-Type"</span>]) &#123;</span><br><span class="line">            [mutableRequest setValue:<span class="string">@"application/x-www-form-urlencoded"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span><span class="variable">.stringEncoding</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 将 parameters 添加到 URL 或者 HTTP body 中</span></span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="小结">小结</h2><ul>
<li><code>AFURLResponseSerialization</code> 负责对返回的数据进行序列化</li>
<li><code>AFURLRequestSerialization</code> 负责生成 <code>NSMutableURLRequest</code>，为请求设置 HTTP 头部，管理发出的请求</li>
</ul>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/AFNetworking/%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%20AFURLSerialization%EF%BC%88%E4%B8%89%EF%BC%89.md" target="_blank" rel="external">处理请求和响应 AFURLSerialization（三）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="AFURLRequestSerialization">AFURLRequestSerialization</h2><p><code>AFURLRequestSerialization</code> 定义为协议，其主要工作是对发出的 HTTP 请求进行处理：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLRequestSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (nullable <span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(nullable <span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>遵循该协议的类同时也要遵循 NSObject、NSSecureCoding 和 NSCopying 这三个协议，以实现 Objective-C 对象的基本行为、安全编码以及拷贝。</p>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://itangqi.me/tags/AFNetworking/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="Source Code" scheme="http://itangqi.me/tags/Source-Code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 3.0 源码阅读笔记（四）]]></title>
    <link href="http://itangqi.me/2016/05/13/the-notes-of-learning-afnetworking-four/"/>
    <id>http://itangqi.me/2016/05/13/the-notes-of-learning-afnetworking-four/</id>
    <published>2016-05-12T16:00:00.000Z</published>
    <updated>2016-05-28T07:40:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>通过前面的文章，我们已经知道 <code>AFNetworking</code> 是对 <code>NSURLSession</code> 的封装，也了解它是如何发出请求的，在这里我们<strong>对发出请求以及接收响应的过程</strong>进行序列化，这涉及到两个<strong>模块</strong>：</p>
<ul>
<li><a href="#afurlresponseserialization">AFURLResponseSerialization</a></li>
<li><a href="#afurlrequestserialization">AFURLRequestSerialization</a></li>
</ul>
<p>前者是处理响应的模块，将请求返回的数据解析成对应的格式。而后者的主要作用是修改请求（主要是 HTTP 请求）的头部，提供了一些语义明确的接口设置 HTTP 头部字段。</p>
<p>我们首先会对 <code>AFURLResponseSerialization</code> 进行简单的介绍，因为这个模块使用在 <code>AFURLSessionManager</code> 也就是核心类中，而后者 <code>AFURLRequestSerialization</code> 主要用于 <code>AFHTTPSessionManager</code> 中，因为它主要用于<strong>修改 HTTP 头部</strong>。</p>
<a id="more"></a>
<hr>
<h2 id="AFURLResponseSerialization">AFURLResponseSerialization</h2><p>在了解模块中类的具体实现之前，先看一下模块的结构图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-afnetworking-four-02.png" alt=""></p>
<p><code>AFURLResponseSerialization</code> 定义为协议，且协议的内容非常简单，只有一个必须实现的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLResponseSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (nullable <span class="keyword">id</span>)responseObjectForResponse:(nullable <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(nullable <span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>遵循该协议的类同时也要遵循 NSObject、NSSecureCoding 和 NSCopying 这三个协议，以实现 Objective-C 对象的基本行为、安全编码以及拷贝。</p>
<p><strong>注</strong>：</p>
<ol>
<li>模块中的所有类都遵循 <code>AFURLResponseSerialization</code> 协议</li>
<li><code>AFHTTPResponseSerializer</code> 为模块中最终要的根类</li>
</ol>
<h3 id="AFHTTPResponseSerializer">AFHTTPResponseSerializer</h3><p>下面我们对模块中最重要的根类，也就是 <code>AFHTTPResponseSerializer</code> 的实现进行分析。它是在 <code>AFURLResponseSerialization</code> 模块中最基本的类（因为 <code>AFURLResponseSerialization</code> 只是一个协议）</p>
<h4 id="初始化">初始化</h4><p>首先，依然从实例化方法入手：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)serializer &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.stringEncoding</span> = <span class="built_in">NSUTF8StringEncoding</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.acceptableStatusCodes</span> = [<span class="built_in">NSIndexSet</span> indexSetWithIndexesInRange:<span class="built_in">NSMakeRange</span>(<span class="number">200</span>, <span class="number">100</span>)];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.acceptableContentTypes</span> = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是对 HTTP 响应进行序列化，所以这里设置了 <code>stringEncoding</code> 为 <code>NSUTF8StringEncoding</code> 而且没有对接收的内容类型加以限制。</p>
<p>将 <code>acceptableStatusCodes</code> 设置为从 200 到 299 之间的状态码, 因为只有这些状态码表示<strong>获得了有效的响应</strong>。</p>
<p><strong>补充</strong>：<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="external">HTTP状态码</a></p>
<h4 id="验证响应的有效性">验证响应的有效性</h4><p><code>AFHTTPResponseSerializer</code> 中方法的实现最长，并且最重要的就是 <code>- [AFHTTPResponseSerializer validateResponse:data:error:]</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">                    data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                   error:(<span class="built_in">NSError</span> * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> responseIsValid = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">NSError</span> *validationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 简单的为空判断和类型判断，注意如果 response 为空或类型不对，反而 responseValid 为 YES</span></span><br><span class="line">    <span class="keyword">if</span> (response &amp;&amp; [response isKindOfClass:[<span class="built_in">NSHTTPURLResponse</span> class]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.acceptableContentTypes</span> &amp;&amp; ![<span class="keyword">self</span><span class="variable">.acceptableContentTypes</span> containsObject:[response MIMEType]]) &#123;</span><br><span class="line">truetruetrue<span class="preprocessor">#1: 返回内容类型无效</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.acceptableStatusCodes</span> &amp;&amp; ![<span class="keyword">self</span><span class="variable">.acceptableStatusCodes</span> containsIndex:(<span class="built_in">NSUInteger</span>)response<span class="variable">.statusCode</span>] &amp;&amp; [response URL]) &#123;</span><br><span class="line">truetruetrue<span class="preprocessor">#2: 返回状态码无效</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error &amp;&amp; !responseIsValid) &#123;</span><br><span class="line">        *error = validationError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseIsValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法根据在初始化方法中初始化的属性 <code>acceptableContentTypes</code> 和 <code>acceptableStatusCodes</code> 来判断当前响应是否有效。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([data length] &gt; <span class="number">0</span> &amp;&amp; [response URL]) &#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">                                              <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Request failed: unacceptable content-type: %@"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>), [response MIMEType]],</span><br><span class="line">                                              <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],</span><br><span class="line">                                              AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                                            &#125; mutableCopy];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorCannotDecodeContentData</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">responseIsValid = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>
<p>其中第一、二部分的代码非常相似，出现错误时通过 <code>AFErrorWithUnderlyingError</code> 生成格式化之后的错误，最后设置 <code>responseIsValid</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">                                   <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Request failed: %@ (%ld)"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>), [<span class="built_in">NSHTTPURLResponse</span> localizedStringForStatusCode:response<span class="variable">.statusCode</span>], (<span class="keyword">long</span>)response<span class="variable">.statusCode</span>],</span><br><span class="line">                                   <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],</span><br><span class="line">                                   AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                           &#125; mutableCopy];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (data) &#123;</span><br><span class="line">    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorBadServerResponse</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line"></span><br><span class="line">responseIsValid = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>
<p>第二部分的代码讲解略。</p>
<h4 id="协议的实现">协议的实现</h4><p>主要看 <code>AFURLResponseSerialization</code> 协议的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用上面的方法对响应进行验证，然后返回数据，并没有复杂的逻辑。</p>
<h3 id="AFJSONResponseSerializer">AFJSONResponseSerializer</h3><p>接下来，看一下 <code>AFJSONResponseSerializer</code> 这个继承自 <code>AFHTTPResponseSerializer</code> 类的实现。</p>
<p>初始化方法只是在调用父类的初始化方法之后更新了 <code>acceptableContentTypes</code> 属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.acceptableContentTypes</span> = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"application/json"</span>, <span class="string">@"text/json"</span>, <span class="string">@"text/javascript"</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="协议的实现-1">协议的实现</h4><p>这个类中与父类差别最大的就是对 <code>AFURLResponseSerialization</code> 协议的实现。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="preprocessor">#1: 验证请求</span></span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#2: 解决一个由只包含一个空格的响应引起的 bug, 略</span></span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#3: 序列化 JSON</span></span><br><span class="line">true</span><br><span class="line">    <span class="preprocessor">#4: 移除 JSON 中的 null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>验证请求的有效性</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (![<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决一个空格引起的 bug，见 <a href="https://github.com/rails/rails/issues/1742" target="_blank" rel="external">https://github.com/rails/rails/issues/1742</a></p>
</li>
<li><p>序列化 JSON</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line">  <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">  <span class="comment">// Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</span></span><br><span class="line">  <span class="comment">// See https://github.com/rails/rails/issues/1742</span></span><br><span class="line">  <span class="built_in">BOOL</span> isSpace = [data isEqualToData:[<span class="built_in">NSData</span> dataWithBytes:<span class="string">" "</span> length:<span class="number">1</span>]];</span><br><span class="line">  <span class="keyword">if</span> (data<span class="variable">.length</span> &gt; <span class="number">0</span> &amp;&amp; !isSpace) &#123;</span><br><span class="line">      responseObject = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="keyword">self</span><span class="variable">.readingOptions</span> error:&amp;serializationError];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除 JSON 中的 null</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">true<span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.removesKeysWithNullValues</span> &amp;&amp; responseObject) &#123;</span><br><span class="line">true    responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span><span class="variable">.readingOptions</span>);</span><br><span class="line">true&#125;</span><br><span class="line">true``` </span><br><span class="line"></span><br><span class="line">其中移除 JSON 中 null 的函数 `AFJSONObjectByRemovingKeysWithNullValues` 是一个递归调用的函数：</span><br><span class="line"></span><br><span class="line">```objectivec</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> AFJSONObjectByRemovingKeysWithNullValues(<span class="keyword">id</span> JSONObject, <span class="built_in">NSJSONReadingOptions</span> readingOptions) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSArray</span> class]]) &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:[(<span class="built_in">NSArray</span> *)JSONObject count]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> value <span class="keyword">in</span> (<span class="built_in">NSArray</span> *)JSONObject) &#123;</span><br><span class="line">            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableArray : [<span class="built_in">NSArray</span> arrayWithArray:mutableArray];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSDictionary</span> class]]) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *mutableDictionary = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:JSONObject];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> &lt;<span class="built_in">NSCopying</span>&gt; key <span class="keyword">in</span> [(<span class="built_in">NSDictionary</span> *)JSONObject allKeys]) &#123;</span><br><span class="line">            <span class="keyword">id</span> value = (<span class="built_in">NSDictionary</span> *)JSONObject[key];</span><br><span class="line">            <span class="keyword">if</span> (!value || [value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">                [mutableDictionary removeObjectForKey:key];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> class]] || [value isKindOfClass:[<span class="built_in">NSDictionary</span> class]]) &#123;</span><br><span class="line">                mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableDictionary : [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:mutableDictionary];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JSONObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中移除 <code>null</code> 靠的就是 <code>[mutableDictionary removeObjectForKey:key]</code> 这一行代码。</p>
<p><strong>注</strong>：</p>
<ul>
<li><code>AFXMLParserResponseSerializer</code> 、 <code>AFXMLDocumentResponseSerializer</code> 、<code>AFPropertyListResponseSerializer</code> 、 AFImageResponseSerializer 及 <code>AFCompoundResponseSerializer</code> 将留给感兴趣的同学。</li>
</ul>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/AFNetworking/%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%20AFURLSerialization%EF%BC%88%E4%B8%89%EF%BC%89.md" target="_blank" rel="external">处理请求和响应 AFURLSerialization（三）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>通过前面的文章，我们已经知道 <code>AFNetworking</code> 是对 <code>NSURLSession</code> 的封装，也了解它是如何发出请求的，在这里我们<strong>对发出请求以及接收响应的过程</strong>进行序列化，这涉及到两个<strong>模块</strong>：</p>
<ul>
<li><a href="#afurlresponseserialization">AFURLResponseSerialization</a></li>
<li><a href="#afurlrequestserialization">AFURLRequestSerialization</a></li>
</ul>
<p>前者是处理响应的模块，将请求返回的数据解析成对应的格式。而后者的主要作用是修改请求（主要是 HTTP 请求）的头部，提供了一些语义明确的接口设置 HTTP 头部字段。</p>
<p>我们首先会对 <code>AFURLResponseSerialization</code> 进行简单的介绍，因为这个模块使用在 <code>AFURLSessionManager</code> 也就是核心类中，而后者 <code>AFURLRequestSerialization</code> 主要用于 <code>AFHTTPSessionManager</code> 中，因为它主要用于<strong>修改 HTTP 头部</strong>。</p>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://itangqi.me/tags/AFNetworking/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="Source Code" scheme="http://itangqi.me/tags/Source-Code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 3.0 源码阅读笔记（三）]]></title>
    <link href="http://itangqi.me/2016/05/09/the-notes-of-learning-afnetworking-three/"/>
    <id>http://itangqi.me/2016/05/09/the-notes-of-learning-afnetworking-three/</id>
    <published>2016-05-08T16:00:00.000Z</published>
    <updated>2016-05-28T07:39:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p><code>AFURLSessionManager</code> 绝对可以称得上是 AFNetworking 的核心，所以本文篇幅会相对长一点，但我保证绝对是满满的干货~</p>
<a id="more"></a>
<hr>
<h2 id="AFURLSessionManager">AFURLSessionManager</h2><p>首先，在 <code>AFURLSessionManager.h</code> 中关于 <code>AFURLSessionManager</code> 的概述：</p>
<blockquote>
<p><code>AFURLSessionManager</code> creates and manages an <code>NSURLSession</code> object based on a specified <code>NSURLSessionConfiguration</code> object, which conforms to <code>&lt;NSURLSessionTaskDelegate&gt;</code>, <code>&lt;NSURLSessionDataDelegate&gt;</code>, <code>&lt;NSURLSessionDownloadDelegate&gt;</code>, and <code>&lt;NSURLSessionDelegate&gt;</code>.</p>
</blockquote>
<p>最终可以归结为以下几点：</p>
<ol>
<li><a href="#NSURLSession">负责创建和管理 <code>NSURLSession</code></a></li>
<li><a href="#NSURLSessionTask">管理 <code>NSURLSessionTask</code></a></li>
<li><a href="#NSURLSessionDelegate">实现 <code>NSURLSessionDelegate</code> 等协议中的代理方法</a></li>
<li><a href="#AFURLSessionManagerTaskDelegate">使用 <code>AFURLSessionManagerTaskDelegate</code> 管理进度</a></li>
<li><a href="#_AFURLSessionTaskSwizzling">使用 <code>_AFURLSessionTaskSwizzling</code> 调剂方法</a></li>
<li><a href="#AFSecurityPolocy">引入 <code>AFSecurityPolicy</code> 保证请求的安全</a></li>
<li><a href="#AFNetworkReachabilityManager">引入 <code>AFNetworkReachabilityManager</code> 监控网络状态</a></li>
</ol>
<hr>
<h2 id="创建和管理_NSURLSession"><a id="NSURLSession"></a>创建和管理 <code>NSURLSession</code></h2><p>按惯例，我们由 <code>AFURLSessionManager</code> 的初始化方法：<code>- (instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</code> 进行展开：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">        configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.sessionConfiguration</span> = configuration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.operationQueue</span> = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.operationQueue</span><span class="variable">.maxConcurrentOperationCount</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.session</span> = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span><span class="variable">.sessionConfiguration</span> delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span><span class="variable">.operationQueue</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.responseSerializer</span> = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.securityPolicy</span> = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if !TARGET_OS_WATCH</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.reachabilityManager</span> = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mutableTaskDelegatesKeyedByTaskIdentifier</span> = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.lock</span> = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.lock</span><span class="variable">.name</span> = AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.session</span> getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDataTask</span> *task <span class="keyword">in</span> dataTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForDataTask:task uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionUploadTask</span> *uploadTask <span class="keyword">in</span> uploadTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDownloadTask</span> *downloadTask <span class="keyword">in</span> downloadTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:<span class="literal">nil</span> destination:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要完成如下工作：</p>
<ol>
<li>初始化<strong>会话配置</strong>（NSURLSessionConfiguration），默认为 <code>defaultSessionConfiguration</code></li>
<li>设置相应的 <code>OperationQueue</code>，决定请求过程中的一系列事件在哪个 <code>OperationQueue</code> 回调，这里是设置了最大并发量为 1 的队列，也就相当于串行队列了。(AFNetworing 2.0 版本是设置了一条常驻线程来响应所有网络请求的 delegate 事件)</li>
<li>初始化会话（session），并设置会话的代理及代理队列，delegate 用来处理请求中的各种事件，可以设置为 nil 使用系统提供的 delegate，但是要想支持后台传输数据必须提供自定义实现的 delegate；另外，<code>NSURLSession</code> 对象是强引用了 delegate，如果程序最终没有调用  <code>invalidateAndCancel</code> 方法来 invalidate 该 session 的话，则会造成内存泄漏</li>
<li>初始化管理<strong>响应序列化</strong>（AFJSONResponseSerializer），<strong>安全认证</strong>（AFSecurityPolicy）以及<strong>监控网络状态</strong>（AFNetworkReachabilityManager）的实例</li>
<li>初始化保存 data task 的字典（mutableTaskDelegatesKeyedByTaskIdentifier）</li>
</ol>
<hr>
<h2 id="管理_NSURLSessionTask"><a id="NSURLSessionTask"></a>管理 <code>NSURLSessionTask</code></h2><p>接下来，在获得了 <code>AFURLSessionManager</code> 的实例之后，我们可以通过以下方法创建 <code>NSURLSessionDataTask</code> 的实例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> Creates an `NSURLSessionDataTask` with the specified request.</span><br><span class="line"></span><br><span class="line"> @param request The HTTP request for the request.</span><br><span class="line"> @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any.</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里省略了一些返回 <code>NSURLSessionTask</code> 的方法，因为这些接口的形式都是差不多的。</p>
<p><strong>扩展</strong>：<a href="http://stackoverflow.com/questions/32452889/difference-between-nullable-nullable-and-nullable-in-objective-c" target="_blank" rel="external">Difference between nullable, __nullable and _Nullable in Objective-C</a></p>
<p>下面，我们将以 <code>- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</code> 方法的实现为例，分析它是如何实例化并返回一个 <code>NSURLSessionTask</code> 的实例的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [<span class="keyword">self</span><span class="variable">.session</span> dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要完成如下工作：</p>
<ol>
<li>调用 <code>- [NSURLSession dataTaskWithRequest:]</code> 方法传入 <code>NSURLRequest</code></li>
<li>调用 <code>- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</code> 方法返回一个 <code>AFURLSessionManagerTaskDelegate</code> 对象</li>
<li>将 <code>completionHandler</code> <code>uploadProgressBlock</code> 和 <code>downloadProgressBlock</code> 传入该对象并在相应事件发生时进行回调</li>
</ol>
<blockquote>
<p><code>url_session_manager_create_task_safely</code> 的调用是因为苹果框架中的一个 bug <a href="https://github.com/AFNetworking/AFNetworking/issues/2093" target="_blank" rel="external">#2093</a>，如果有兴趣可以看一下，在这里就不具体说明了。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">                uploadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">    delegate<span class="variable">.manager</span> = <span class="keyword">self</span>;</span><br><span class="line">    delegate<span class="variable">.completionHandler</span> = completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask<span class="variable">.taskDescription</span> = <span class="keyword">self</span><span class="variable">.taskDescriptionForSessionTasks</span>;</span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    delegate<span class="variable">.uploadProgressBlock</span> = uploadProgressBlock;</span><br><span class="line">    delegate<span class="variable">.downloadProgressBlock</span> = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中同时调用了另一个方法 <code>- [AFURLSessionManager setDelegate:forTask:]</code> 来设置代理：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#1: 检查参数, 略</span></span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.lock</span> lock];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mutableTaskDelegatesKeyedByTaskIdentifier</span>[@(task<span class="variable">.taskIdentifier</span>)] = delegate;</span><br><span class="line">    [delegate setupProgressForTask:task];</span><br><span class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.lock</span> unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如上面所提到的，<code>AFURLSessionManager</code> 就是通过字典 <code>mutableTaskDelegatesKeyedByTaskIdentifier</code> 来存储并管理每一个 <code>NSURLSessionTask</code>，它以 <code>taskIdentifier</code> 为键存储 task。</p>
<p>该方法使用 <code>NSLock</code> 来保证不同线程使用 <code>mutableTaskDelegatesKeyedByTaskIdentifier</code> 时，不会出现<strong>线程竞争</strong>的问题（既线程同步）。</p>
<p>同时调用 <a href="#setupProgressForTask">- setupProgressForTask:</a>，我们会在下面具体介绍这个方法。</p>
<hr>
<h2 id="实现_NSURLSessionDelegate_等协议中的代理方法"><a id="NSURLSessionDelegate"></a>实现 <code>NSURLSessionDelegate</code> 等协议中的代理方法</h2><p>首先，<code>NSURLSession</code> 的代理对象结构如下：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-afnetworking-three-01.png" alt=""></p>
<p>接下来，我们来看下具体的代理方法：</p>
<ul>
<li><code>NSURLSessionDelegate</code></li>
<li><code>NSURLSessionTaskDelegate</code>，遵守 <code>NSURLSessionDelegate</code> 协议</li>
<li><p><code>NSURLSessionDataDelegate</code>，遵守 <code>NSURLSessionTaskDelegate</code> 协议，是网络请求通常遵循的协议，常用的方法：</p>
<ul>
<li><p>接受到服务响应时调用的方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 必须在该方法中对服务器的响应进行授权，才能继续接收服务器返回的数据，调用如下函数</span><br><span class="line">* completionHandler（NSURLSessionResponseAllow）</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接收到服务器返回的数据时调用的方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* data：服务返回的数据，通常为 JSON 格式数据</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>请求完成时调用的方法（成功或失败）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(nullable <span class="built_in">NSError</span> *)error</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 若出现错误，error 中存放错误信息</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>NSURLSessionDownloadDelegate（通常用于下载大量数据），遵守 NSURLSessionTaskDelegate 协议，常用的方法：</p>
<ul>
<li><p>写入数据到临时文件时调用的方法（服务器返回一点就写入一点）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:	(int64_t)totalBytesExpectedToWrite</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* totalBytesWritten，已写入数据的总长度</span><br><span class="line">* totalBytesExpectedToWrite：总共要写入数据的总长度</span><br><span class="line">* 可以在该方法中计算下载进度</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遇到错误的时候调用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line"><span class="comment">/**</span><br><span class="line">*error：若遇到错误，则保存错误信息</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用于断点下载的方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* fileOffset：继续下载时，文件的开始位置</span><br><span class="line">* expectedTotalBytes：剩余的数据总数</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下载完成时调用的方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* location：下载的文件保存的临时位置</span><br><span class="line">* 需要将下载的文件保存在可以长期保存的位置</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="使用_AFURLSessionManagerTaskDelegate_管理进度"><a id="AFURLSessionManagerTaskDelegate"></a>使用 <code>AFURLSessionManagerTaskDelegate</code> 管理进度</h2><p>在上面我们提到过 <code>AFURLSessionManagerTaskDelegate</code> 类，它主要为 task 提供<strong>进度管理</strong>功能，并在 task 结束时<strong>回调</strong>， 也就是调用在 <code>- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</code> 等方法中传入的 <code>completionHandler</code>。</p>
<p><a id="setupProgressForTask"></a>我们首先分析一下 <code>AFURLSessionManagerTaskDelegate</code> 是如何对进度进行跟踪的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupProgressForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#1：设置在上传进度或者下载进度状态改变时的回调</span></span><br><span class="line">true</span><br><span class="line">    <span class="preprocessor">#2：KVO</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的实现有两个部分，一部分是对代理持有的两个属性 <code>uploadProgress</code> 和 <code>downloadProgress</code> 设置回调</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> __typeof__(task) weakTask = task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span><span class="variable">.uploadProgress</span><span class="variable">.totalUnitCount</span> = task<span class="variable">.countOfBytesExpectedToSend</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.uploadProgress</span> setCancellable:<span class="literal">YES</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.uploadProgress</span> setCancellationHandler:^&#123;</span><br><span class="line">   __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">   [strongTask cancel];</span><br><span class="line">&#125;];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.uploadProgress</span> setPausable:<span class="literal">YES</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.uploadProgress</span> setPausingHandler:^&#123;</span><br><span class="line">   __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">   [strongTask suspend];</span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.uploadProgress</span> respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">   [<span class="keyword">self</span><span class="variable">.uploadProgress</span> setResumingHandler:^&#123;</span><br><span class="line">       __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">       [strongTask resume];</span><br><span class="line">   &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只有对 <code>uploadProgress</code> 设置回调的代码，设置 <code>downloadProgress</code> 与这里完全相同</p>
<blockquote>
<p>主要目的是在对应 <code>NSProgress</code> 的状态改变时，调用 <code>resume</code> <code>suspend</code> 等方法改变 task 的状态。</p>
</blockquote>
<p>第二部分是对 task 和 <code>NSProgress</code> 属性进行键值观测：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[task addObserver:<span class="keyword">self</span></span><br><span class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))</span><br><span class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">         context:<span class="literal">NULL</span>];</span><br><span class="line">[task addObserver:<span class="keyword">self</span></span><br><span class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))</span><br><span class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">         context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">[task addObserver:<span class="keyword">self</span></span><br><span class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))</span><br><span class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">         context:<span class="literal">NULL</span>];</span><br><span class="line">[task addObserver:<span class="keyword">self</span></span><br><span class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))</span><br><span class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">         context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.downloadProgress</span> addObserver:<span class="keyword">self</span></span><br><span class="line">                       forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                          options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                          context:<span class="literal">NULL</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.uploadProgress</span> addObserver:<span class="keyword">self</span></span><br><span class="line">                     forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                        options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                        context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>
<p>在 <code>observeValueForKeypath:ofObject:change:context:</code> 方法中改变进度，并调用 block</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> ([object isKindOfClass:[<span class="built_in">NSURLSessionTask</span> class]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))]) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.downloadProgress</span><span class="variable">.completedUnitCount</span> = [change[<span class="string">@"new"</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))]) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.downloadProgress</span><span class="variable">.totalUnitCount</span> = [change[<span class="string">@"new"</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))]) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.uploadProgress</span><span class="variable">.completedUnitCount</span> = [change[<span class="string">@"new"</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))]) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.uploadProgress</span><span class="variable">.totalUnitCount</span> = [change[<span class="string">@"new"</span>] longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span><span class="variable">.downloadProgress</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.downloadProgressBlock</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.downloadProgressBlock</span>(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span><span class="variable">.uploadProgress</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.uploadProgressBlock</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.uploadProgressBlock</span>(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象的某些属性改变时更新 <code>NSProgress</code> 对象或使用 block 传递 <code>NSProgress</code> 对象 <code>self.uploadProgressBlock(object)</code>。</p>
<h3 id="代理方法_URLSession:task:didCompleteWithError:">代理方法 <code>URLSession:task:didCompleteWithError:</code></h3><p>在每一个 <code>NSURLSessionTask</code> 结束时，都会在代理方法 <code>URLSession:task:didCompleteWithError:</code> 中：</p>
<ol>
<li>调用传入的 <code>completionHander</code> block</li>
<li>发出 <code>AFNetworkingTaskDidCompleteNotification</code> 通知</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="preprocessor">#1：获取数据, 存储 `responseSerializer` 和 `downloadFileURL`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    	<span class="preprocessor">#2：在存在错误时调用 `completionHandler`</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">truetrue<span class="preprocessor">#3：调用 `completionHandler`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是整个代理方法的骨架，先看一下最简单的第一部分代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">NSMutableDictionary</span> *userInfo = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager<span class="variable">.responseSerializer</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体可以查看 #issue 2672。这里主要是针对大文件的时候，性能提升会很明显</span></span><br><span class="line"><span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.mutableData</span>) &#123;</span><br><span class="line">   data = [<span class="keyword">self</span><span class="variable">.mutableData</span> <span class="keyword">copy</span>];</span><br><span class="line">   <span class="comment">// 此处不再需要 mutableData 了</span></span><br><span class="line">   <span class="keyword">self</span><span class="variable">.mutableData</span> = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.downloadFileURL</span>) &#123;</span><br><span class="line">   userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = <span class="keyword">self</span><span class="variable">.downloadFileURL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (data) &#123;</span><br><span class="line">   userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看第二部分：这部分代码从 <code>mutableData</code> 中取出了数据，设置了 <code>userInfo</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 task 出错了，处理 error 信息</span></span><br><span class="line"><span class="comment">// 所以对应的观察者在处理 error 的时候，比如可以先判断 userInfo[AFNetworkingTaskDidCompleteErrorKey] 是否有值，有值的话，就说明是要处理 error</span></span><br><span class="line">userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">dispatch_group_async(manager<span class="variable">.completionGroup</span> ?: url_session_manager_completion_group(), manager<span class="variable">.completionQueue</span> ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.completionHandler</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.completionHandler</span>(task<span class="variable">.response</span>, responseObject, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果当前 <code>manager</code> 持有 <code>completionGroup</code> 或者 <code>completionQueue</code> 就使用它们。否则会创建一个 <code>dispatch_group_t</code> 并在主线程中调用 <code>completionHandler</code> 并发送通知（在主线程中）。</p>
<p>最后一部分：如果在执行当前 task 时没有遇到错误，那么先<strong>对数据进行序列化</strong>，然后同样调用 block 并发送通知。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 根据对应的 task 和 data 将 response data 解析成可用的数据格式，比如 JSON serializer 就将 data 解析成 JSON 格式</span></span><br><span class="line">    responseObject = [manager<span class="variable">.responseSerializer</span> responseObjectForResponse:task<span class="variable">.response</span> data:data error:&amp;serializationError];</span><br><span class="line">    <span class="comment">// 注意如果有 downloadFileURL，意味着 data 存放在了磁盘上了，所以此处 responseObject 保存的是 data 存放位置，供后面 completionHandler 处理。没有 downloadFileURL，就直接使用内存中的解析后的 data 数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.downloadFileURL</span>) &#123;</span><br><span class="line">        responseObject = <span class="keyword">self</span><span class="variable">.downloadFileURL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (responseObject) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 序列化的时候出现错误</span></span><br><span class="line">    <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch_group_async(manager<span class="variable">.completionGroup</span> ?: url_session_manager_completion_group(), manager<span class="variable">.completionQueue</span> ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.completionHandler</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.completionHandler</span>(task<span class="variable">.response</span>, responseObject, serializationError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="代理方法_URLSession:dataTask:didReceiveData:_和_-_URLSession:downloadTask:didFinishDownloadingToURL:">代理方法 <code>URLSession:dataTask:didReceiveData:</code> 和 <code>- URLSession:downloadTask:didFinishDownloadingToURL:</code></h3><p>这两个代理方法分别会在收到数据或者完成下载对应文件时调用，作用分别是为 <code>mutableData</code> 追加数据和处理下载的文件：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(__unused <span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mutableData</span> appendData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *fileManagerError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.downloadFileURL</span> = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.downloadTaskDidFinishDownloading</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.downloadFileURL</span> = <span class="keyword">self</span><span class="variable">.downloadTaskDidFinishDownloading</span>(session, downloadTask, location);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.downloadFileURL</span>) &#123;</span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:<span class="keyword">self</span><span class="variable">.downloadFileURL</span> error:&amp;fileManagerError];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fileManagerError) &#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError<span class="variable">.userInfo</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="使用__AFURLSessionTaskSwizzling_调剂方法"><a id="_AFURLSessionTaskSwizzling"></a>使用 <code>_AFURLSessionTaskSwizzling</code> 调剂方法</h2><p><code>_AFURLSessionTaskSwizzling</code> 的唯一功能就是修改 <code>NSURLSessionTask</code> 的 <code>resume</code> 和 <code>suspend</code> 方法，使用下面的方法替换原有的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)af_resume &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@"Does not respond to state"</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_resume];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateRunning</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AF<span class="built_in">NSURLSessionTaskDidResumeNotification</span> object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)af_suspend &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@"Does not respond to state"</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_suspend];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AF<span class="built_in">NSURLSessionTaskDidSuspendNotification</span> object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的目的是为了在方法 <code>resume</code> 或者 <code>suspend</code> 被调用时发出通知。</p>
<p>具体方法调剂的过程是在 <code>+ load</code> 方法中进行的</p>
<blockquote>
<p><code>load</code> 方法只会在整个文件被引入时调用一次</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@"NSURLSessionTask"</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</span><br><span class="line">        <span class="comment">// 首先构建一个 NSURLSession 对象 session，再通过 session 构建出一个 _NSCFLocalDataTask 变量</span></span><br><span class="line">        <span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];</span><br><span class="line"><span class="preprocessor">#pragma GCC diagnostic push</span></span><br><span class="line"><span class="preprocessor">#pragma GCC diagnostic ignored <span class="title">"-Wnonnull"</span></span></span><br><span class="line">        <span class="built_in">NSURLSessionDataTask</span> *localDataTask = [session dataTaskWithURL:<span class="literal">nil</span>];</span><br><span class="line"><span class="preprocessor">#pragma clang diagnostic pop</span></span><br><span class="line">        <span class="comment">// 获取到 af_resume 实现的指针</span></span><br><span class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([<span class="keyword">self</span> class], <span class="keyword">@selector</span>(af_resume)));</span><br><span class="line">        Class currentClass = [localDataTask class];</span><br><span class="line">        <span class="comment">// 检查当前 class 是否实现了 resume。如果实现了，继续第 4 步</span></span><br><span class="line">        <span class="keyword">while</span> (class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume))) &#123;</span><br><span class="line">            <span class="comment">// 获取到当前 class 的父类（superClass）</span></span><br><span class="line">            Class superClass = [currentClass superclass];</span><br><span class="line">            <span class="comment">// 获取到当前 class 对于 resume 实现的指针</span></span><br><span class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line">            <span class="comment">// 获取到父类对于 resume 实现的指针</span></span><br><span class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line">            <span class="comment">// 如果当前 class 对于 resume 的实现和父类不一样（类似 iOS 7 上的情况），并且当前 class 的 resume 实现和 af_resume 不一样，才进行 method swizzling</span></span><br><span class="line">            <span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp;</span><br><span class="line">                originalAFResumeIMP != classResumeIMP) &#123;</span><br><span class="line">                [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置当前操作的 class 为其父类 class，重复步骤 3~8</span></span><br><span class="line">            currentClass = [currentClass superclass];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [localDataTask cancel];</span><br><span class="line">        [session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先用 <code>NSClassFromString(@&quot;NSURLSessionTask&quot;)</code> 判断当前部署的 iOS 版本是否含有类 <code>NSURLSessionTask</code></li>
<li>因为 iOS 7 和 iOS 8 上对于 <code>NSURLSessionTask</code> 的实现不同，所以会通过 <code>- [NSURLSession dataTaskWithURL:]</code> 方法返回一个 <code>NSURLSessionTask</code> 实例</li>
<li>取得当前类 <code>_AFURLSessionTaskSwizzling</code> 中的实现 <code>af_resume</code></li>
<li>如果当前类 <code>currentClass</code> 有 <code>resume</code> 方法<ul>
<li>真：5</li>
<li>假：6</li>
</ul>
</li>
<li>使用 <code>swizzleResumeAndSuspendMethodForClass:</code> 调剂该类的 <code>resume</code> 和 <code>suspend</code> 方法</li>
<li><code>currentClass = [currentClass superclass]</code> </li>
</ol>
<blockquote>
<p>这里复杂的实现是为了解决 bug <a href="https://github.com/AFNetworking/AFNetworking/pull/2702" target="_blank" rel="external">#2702</a></p>
</blockquote>
<hr>
<h2 id="引入_AFSecurityPolicy_保证请求的安全"><a id="AFSecurityPolicy"></a>引入 <code>AFSecurityPolicy</code> 保证请求的安全</h2><p><code>AFSecurityPolicy</code> 是 <code>AFNetworking</code> 用来保证 HTTP 请求安全的类，它被 <code>AFURLSessionManager</code> 持有，如果你在 <code>AFURLSessionManager</code> 的实现文件中搜索 <em>self.securityPolicy</em>，你只会得到三条结果：</p>
<ol>
<li>初始化 <code>self.securityPolicy = [AFSecurityPolicy defaultPolicy]</code></li>
<li>收到连接层的验证请求时</li>
<li>任务接收到验证请求时</li>
</ol>
<p>在 API 调用上，后两者都调用了 <code>- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code> 方法来判断<strong>当前服务器是否被信任</strong>，我们会在接下来的文章中具体介绍这个方法的实现的作用。</p>
<hr>
<h2 id="引入_AFNetworkReachabilityManager_监控网络状态"><a id="AFNetworkReachabilityManager"></a>引入 <code>AFNetworkReachabilityManager</code> 监控网络状态</h2><p>与 <code>AFSecurityPolicy</code> 相同，<code>AFURLSessionManager</code> 对网络状态的监控是由 <code>AFNetworkReachabilityManager</code> 来负责的，它仅仅是持有一个 <code>AFNetworkReachabilityManager</code> 的对象。</p>
<blockquote>
<p>真正需要判断网络状态时，仍然<strong>需要开发者调用对应的 API 获取网络状态</strong>。</p>
</blockquote>
<hr>
<h2 id="小结">小结</h2><ul>
<li><code>AFURLSessionManager</code> 是对 <code>NSURLSession</code> 的封装</li>
<li>它通过 <code>- [AFURLSessionManager dataTaskWithRequest:completionHandler:]</code> 等接口创建 <code>NSURLSessionDataTask</code> 的实例</li>
<li>持有一个字典 <code>mutableTaskDelegatesKeyedByTaskIdentifier</code> 管理这些 data task 实例</li>
<li>引入 <code>AFURLSessionManagerTaskDelegate</code> 来对传入的 <code>uploadProgressBlock</code> <code>downloadProgressBlock</code> <code>completionHandler</code> 在合适的时间进行调用</li>
<li>实现了全部的代理方法来提供 block 接口</li>
<li>通过方法调剂在 data task 状态改变时，发出通知</li>
</ul>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/AFNetworking/AFNetworking%20%E7%9A%84%E6%A0%B8%E5%BF%83%20AFURLSessionManager%EF%BC%88%E4%BA%8C%EF%BC%89.md#NSURLSessionTask" target="_blank" rel="external">AFNetworking 的核心 AFURLSessionManager（二）</a></li>
<li><a href="http://www.cnblogs.com/polobymulberry/p/5160946.html" target="_blank" rel="external">【原】AFNetworking源码阅读（四）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p><code>AFURLSessionManager</code> 绝对可以称得上是 AFNetworking 的核心，所以本文篇幅会相对长一点，但我保证绝对是满满的干货~</p>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://itangqi.me/tags/AFNetworking/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="Source Code" scheme="http://itangqi.me/tags/Source-Code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 3.0 源码阅读笔记（二）]]></title>
    <link href="http://itangqi.me/2016/05/06/the-notes-of-learning-afnetworking-two/"/>
    <id>http://itangqi.me/2016/05/06/the-notes-of-learning-afnetworking-two/</id>
    <published>2016-05-05T16:00:00.000Z</published>
    <updated>2016-05-28T07:30:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>首先，我们来看一下 AFNetworking 框架中主要涉及到了哪些类：</p>
<p><strong>NSURLSession</strong></p>
<ul>
<li><code>AFURLSessionManager</code></li>
<li><code>AFHTTPSessionManager</code></li>
</ul>
<a id="more"></a>
<p><strong>序列化</strong></p>
<ul>
<li><code>AFURLRequestSerialization</code></li>
<li><code>AFURLResponseSerialization</code></li>
</ul>
<p><strong>附加功能</strong></p>
<ul>
<li><code>AFSecurityPolicy</code></li>
<li><code>AFNetworkReachabilityManager</code></li>
</ul>
<!-- more -->
<p>下面，通过一张图来直观地感受下 AF 架构的设计：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-afnetworking-two-01.png" alt=""></p>
<hr>
<h2 id="AFHTTPSessionManager">AFHTTPSessionManager</h2><blockquote>
<p><code>AFHTTPSessionManager</code> is a subclass of <code>AFURLSessionManager</code> with convenience methods for making HTTP requests. When a <code>baseURL</code> is provided, requests made with the <code>GET</code> / <code>POST</code> / et al. convenience methods can be made with relative paths.</p>
</blockquote>
<p>一句话总结：<code>AFHTTPSessionManager</code> 继承于 <code>AFURLSessionManager</code>，并提供了方便的 HTTP 请求方法。</p>
<p>下面，我们通过一段实际代码来感受下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://api.app.net/"</span>]];</span><br><span class="line">[sessionManager GET:<span class="string">@"stream/0/posts/stream/global"</span> parameters:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nonnull responseObject) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"请求成功---%@"</span>, responseObject);</span><br><span class="line">    &#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"请求失败---%@"</span>, error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>通过上面短短几行代码，我们便完成了 GET 请求，有木有很简单！现在是不是很想知道其背后蕴藏的玄机呢？别急，下面就让我们一起来探一探究竟。</p>
<hr>
<h2 id="调用栈">调用栈</h2><h3 id="initWithBaseURL:">initWithBaseURL:</h3><p>首先，我们来探一探 <code>AFHTTPSessionManager</code> 初始化方法 <code>- initWithBaseURL:</code> 的调用栈：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://api.app.net/"</span>]];</span><br></pre></td></tr></table></figure>
<p>我们一路「Command + 左键」，可以归纳出如下结果：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- [AFHTTPSessionManager initWithBaseURL:]</span><br><span class="line">    - [AFHTTPSessionManager initWithBaseURL:sessionConfiguration:]</span><br><span class="line">        - [AFURLSessionManager initWithSessionConfiguration:]</span><br><span class="line">            - [<span class="built_in">NSURLSession</span> sessionWithConfiguration:delegate:delegateQueue:]</span><br><span class="line">            - [AFJSONResponseSerializer serializer] <span class="comment">// 负责序列化响应</span></span><br><span class="line">            - [AFSecurityPolicy defaultPolicy] <span class="comment">// 负责身份认证</span></span><br><span class="line">            - [AFNetworkReachabilityManager sharedManager] <span class="comment">// 查看网络连接情况</span></span><br><span class="line">        - [AFHTTPRequestSerializer serializer] <span class="comment">// 负责序列化请求</span></span><br><span class="line">        - [AFJSONResponseSerializer serializer] <span class="comment">// 负责序列化响应</span></span><br></pre></td></tr></table></figure>
<p>从这个初始化方法的调用栈，我们可以非常清晰地了解这个框架的结构：</p>
<ul>
<li>其中 <code>AFURLSessionManager</code> 是 <code>AFHTTPSessionManager</code> 的父类</li>
<li><code>AFURLSessionManager</code> 负责生成 <code>NSURLSession</code> 的实例，管理 <code>AFSecurityPolicy</code> 和 <code>AFNetworkReachabilityManager</code>，来保证请求的安全和查看网络连接情况，它有一个 <code>AFJSONResponseSerializer</code> 的实例来序列化 HTTP 响应</li>
<li><code>AFHTTPSessionManager</code> 有着<strong>自己的</strong> <code>AFHTTPRequestSerializer</code> 和 <code>AFJSONResponseSerializer</code> 来管理请求和响应的序列化，同时<strong>依赖父类提供的接口</strong>保证安全、监控网络状态，实现发出 HTTP 请求这一核心功能</li>
</ul>
<h4 id="baseURL">baseURL</h4><p>关于 <code>baseURL</code> 一开始我是有点迷糊的，不过源代码中有如下注释：</p>
<blockquote>
<p>For HTTP convenience methods, the request serializer constructs URLs from the path relative to the <code>-baseURL</code>, using <code>NSURL +URLWithString:relativeToURL:</code>, when provided. If <code>baseURL</code> is <code>nil</code>, <code>path</code> needs to resolve to a valid <code>NSURL</code> object using <code>NSURL +URLWithString:</code>.</p>
</blockquote>
<p>并举例进行了说明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *baseURL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/v1/"</span>];</span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"foo"</span> relativeToURL:baseURL];                  <span class="comment">// http://example.com/v1/foo</span></span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"foo?bar=baz"</span> relativeToURL:baseURL];          <span class="comment">// http://example.com/v1/foo?bar=baz</span></span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"/foo"</span> relativeToURL:baseURL];                 <span class="comment">// http://example.com/foo</span></span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"foo/"</span> relativeToURL:baseURL];                 <span class="comment">// http://example.com/v1/foo</span></span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"/foo/"</span> relativeToURL:baseURL];                <span class="comment">// http://example.com/foo/</span></span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example2.com/"</span> relativeToURL:baseURL]; <span class="comment">// http://example2.com/</span></span><br></pre></td></tr></table></figure>
<p>所以，<code>baseURL</code> 为访问的基路径如：<a href="https://api.app.net/，" target="_blank" rel="external">https://api.app.net/，</a> path 是跟在基路径之后的部分路径，如：stream/0/posts/stream/global（因为 AFNetworking 的访问方式才这样划分）。</p>
<h3 id="GET:parameters:process:success:failure:">GET:parameters:process:success:failure:</h3><p>初始化方法很好地揭示了 AFNetworking 整个框架的架构，接下来我们要通过分析另一个方法 <code>- GET:parameters:process:success:failure:</code> 的调用栈，看一下 HTTP 请求是如何发出的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- [AFHTTPSessionManager GET:parameters:process:success:failure:]</span><br><span class="line">    - [AFHTTPSessionManager dataTaskWithHTTPMethod:parameters:uploadProgress:downloadProgress:success:failure:] <span class="comment">// 返回 NSURLSessionDataTask #1</span></span><br><span class="line">        - [AFHTTPRequestSerializer requestWithMethod:URLString:parameters:error:] <span class="comment">// 返回 NSMutableURLRequest</span></span><br><span class="line">        - [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] <span class="comment">// 返回 NSURLSessionDataTask #2</span></span><br><span class="line">            - [<span class="built_in">NSURLSession</span> dataTaskWithRequest:] <span class="comment">// 返回 NSURLSessionDataTask #3</span></span><br><span class="line">            - [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</span><br><span class="line">                - [AFURLSessionManagerTaskDelegate init]</span><br><span class="line">                - [AFURLSessionManager setDelegate:forTask:]</span><br><span class="line">    - [<span class="built_in">NSURLSessionDataTask</span> resume]</span><br></pre></td></tr></table></figure>
<p>在这里 <code>#1</code> <code>#2</code> <code>#3</code> 处返回的是同一个 data task，我们可以看到，在 <code>#3</code> 处调用的方法 <code>- [NSURLSession dataTaskWithRequest:]</code> 和只使用 <code>NSURLSession</code> 发出 HTTP 请求时调用的方法 <code>- [NSURLSession dataTaskWithRequest:completionHandler:]</code> 差不多。在这个地方返回 data task 之后，我们再调用 <code>- resume</code> 方法执行请求，并在某些事件执行时通知代理 <code>AFURLSessionManagerTaskDelegate</code>。</p>
<p>我们在第一篇文章中已经说明过，AFNetworking 3.0 既是在 <code>NSURLSession</code> 之上的高度封装，并提供更加简洁易用的 API。从调用栈的结果来看，将使我们的理解更加清晰。</p>
<hr>
<h2 id="循环引用">循环引用</h2><p>关于在使用 AFNetworking 的过程中出现循环引用的问题，我并没有在实际开发中遇到过（其实我丫的根本就没写过几行代码好嘛（ ＴДＴ）），我是在浏览相关文章时发现这个问题的，所以在此提及一下：</p>
<ul>
<li><a href="https://github.com/AFNetworking/AFNetworking/issues/2149#issuecomment-46842747" target="_blank" rel="external">AFHTTPSessionManager subclass not deallocating - retain cycle?</a></li>
<li><a href="https://github.com/AFNetworking/AFNetworking/issues/3116" target="_blank" rel="external">AFHTTPSessionManager and AFURLSessionManager never deallocated</a></li>
<li><a href="https://github.com/AFNetworking/AFNetworking/issues/2767" target="_blank" rel="external">block retain cycle in AFUrLSessionManager init method</a></li>
</ul>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/AFNetworking/AFNetworking%20%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89.md" target="_blank" rel="external">AFNetworking 概述（一）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>首先，我们来看一下 AFNetworking 框架中主要涉及到了哪些类：</p>
<p><strong>NSURLSession</strong></p>
<ul>
<li><code>AFURLSessionManager</code></li>
<li><code>AFHTTPSessionManager</code></li>
</ul>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://itangqi.me/tags/AFNetworking/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="Source Code" scheme="http://itangqi.me/tags/Source-Code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 3.0 源码阅读笔记（一）]]></title>
    <link href="http://itangqi.me/2016/05/05/the-notes-of-learning-afnetworking-one/"/>
    <id>http://itangqi.me/2016/05/05/the-notes-of-learning-afnetworking-one/</id>
    <published>2016-05-04T16:00:00.000Z</published>
    <updated>2016-05-28T04:28:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在完成 <a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a> 的源码阅读后（可参见系列文章：<a href="http://itangqi.me/2016/03/19/the-notes-of-learning-sdwebimage-one/">SDWebImage 源码阅读笔记</a>），我又将目光瞄向了大名鼎鼎的网络库 <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a>，不过为了能保证源码阅读的流畅性，不至于到时一脸懵逼，在正式开始之前，我又恶补了下网络相关的知识，可参见相关文章：<a href="http://itangqi.me/2016/04/01/from-nsurlconnection-to-nsurlsession/">从 NSURLConnection 到 NSURLSession</a> 与<a href="http://itangqi.me/2016/04/04/the-notes-of-learning-illustrating-http-one/">《图解 HTTP》读书笔记</a>。</p>
<p>好啦，似乎万事具备，就让我们扬帆起航，开启 AFNetworking 源码阅读之旅吧！</p>
<a id="more"></a>
<hr>
<h2 id="概述">概述</h2><p><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a> 官方介绍如下：</p>
<blockquote>
<p>AFNetworking is a delightful networking library for iOS and Mac OS X. It’s built on top of the <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="external">Foundation URL Loading System</a>, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.</p>
</blockquote>
<p>一句话总结：AFNetworking 是一个在 iOS 和 Mac OS X 都令人喜爱的网络库，它是基于 Foundation URL Loading System 进行的一套封装，有着精心设计的模块化架构和丰富的 API 接口。</p>
<hr>
<h2 id="3-0_vs-_2-0">3.0 vs. 2.0</h2><blockquote>
<p>AFNetworking 依靠着开源社区的力量，仍在不断更新中，本系列文章阅读的版本为 <strong>3.1.0</strong>。</p>
</blockquote>
<p>为了迎合 iOS 新版本的升级，AFNetworking 在 3.0 版本中删除了基于 <code>NSURLConnection</code> API 的所有支持。目前 AFNetworking 2.0 官方已经不再提供支持了，其所依赖的 <code>NSURLConnection</code> 系列类也已经被苹果废弃了，意味着苹果官方也不再推荐。因此 AFNetworking 3.0 版本是目前开发的首选（需要兼容旧版本 iOS 的情况下除外）。</p>
<p>尽管 AFNetworking 对外提供的 API 变化不大，这里我们还是需要注意一下 AFNetworking 在 3.0 和 2.0 版本架构上的一个主要变化：</p>
<blockquote>
<p>AFNetworking 3.0 以 Session 为中心，AFNetworking 2.0 以 Operation 为中心。</p>
</blockquote>
<p>这种区别来源与它们下层的依赖，AFNetworking 3.0 依赖的较新的 <code>NSURLSession</code> API，AFNetworking 2.0 依赖于 <code>NSURLConnection</code> 和 <code>NSOperation</code>。</p>
<p>Session 提供了一个较为中心的管理机制，可以通过配置 <code>NSURLSessionConfiguration</code> 来控制一系列请求。而 Operation 则提供了较为分散的管理方法，不同的 Operation 之间没有太大的联系，可以独自进行配置。</p>
<p>如果你对 <code>NSURLConnection</code> 与 <code>NSURLSession</code> 的概念不熟，建议不妨看下我之前的文章：<a href="http://itangqi.me/2016/04/01/from-nsurlconnection-to-nsurlsession/">从 NSURLConnection 到 NSURLSession</a> 补补课：）</p>
<h3 id="新设备要求">新设备要求</h3><p>AFNetworking 3.0 正式支持 iOS 7+，Mac OS X 10.9+，watchOS 2+，tvOS 9 和 Xcode 7。如果你想在针对较旧版本的 SDK 项目中使用 AFNetworking，请检查 <a href="https://github.com/AFNetworking/AFNetworking/blob/master/README.md#requirements" target="_blank" rel="external">README</a> 的兼容性信息。</p>
<h3 id="NSURLConnection_的_API_已被废弃">NSURLConnection 的 API 已被废弃</h3><p>AFNetworking 1.0 建立在 <code>NSURLConnection</code> 的基础 API 之上，AFNetworking 2.0 提供了选择使用 <code>NSURLConnection</code> 的基础 API 或者较新基于 <code>NSURLSession</code> 的 API 的选项。AFNetworking 3.0 现已是完全基于 <code>NSURLSession</code> 的 API，这降低了日后维护的负担，同时支持苹果增强关于 <code>NSURLSession</code> 提供的任何额外功能。由于 Xcode 7 中，<code>NSURLConnection</code> 的 API 已经正式被苹果弃用。虽然该 API 将继续运行，但将没有新功能将被添加，并且苹果已经通知所有基于网络的功能，以充分使 <code>NSURLSession</code> 向前发展。</p>
<p>AFNetworking 2.x 将继续接受严重的 bug 提交和提供安全补丁，但未来不会有新的功能被添加。Alamofire（Swift 下的网络请求）软件基金会建议，所有的项目迁移到基于 <code>NSURLSession</code>的 API。</p>
<h3 id="废弃的类">废弃的类</h3><p>以下的类已从 AFNetworking 3.0 中废弃：</p>
<ul>
<li><code>AFURLConnectionOperation</code></li>
<li><code>AFHTTPRequestOperation</code></li>
<li><code>AFHTTPRequestOperationManager</code></li>
</ul>
<h3 id="修改的类">修改的类</h3><p>以下的类包含基于 <code>NSURLConnection</code> 的 API 的内部实现。他们已经被使用 <code>NSURLSession</code> 重构:</p>
<ul>
<li><code>UIImageView+AFNetworking</code></li>
<li><code>UIWebView+AFNetworking</code></li>
<li><code>UIButton+AFNetworking</code></li>
</ul>
<hr>
<h2 id="迁移">迁移</h2><h3 id="AFHTTPRequestOperationManager_核心代码">AFHTTPRequestOperationManager 核心代码</h3><p>如果你以前使用 <code>AFHTTPRequestOperationManager</code>，你将需要迁移去使用 <code>AFHTTPSessionManager</code>。以下的类在两者过渡间并没有发生变化：</p>
<ul>
<li><code>securityPolicy</code></li>
<li><code>requestSerializer</code></li>
<li><code>responseSerializer</code></li>
</ul>
<h3 id="AFHTTPRequestOperation_核心代码">AFHTTPRequestOperation 核心代码</h3><p>与 <code>NSURLConnection</code> 对象不同，每个共享应用范围的设置如会话管理、缓存策略、Cookie 存储以及 URL 协议等，这些 <code>NSURLSession</code> 对象都可以单独进行配置。使用特定的配置来初始化会话，它可以发送任务来获取数据，并上传或下载文件。</p>
<p>在 AFNetworking 2.0 中，使用 <code>AFHTTPRequestOperation</code>，有可能创建一个没有额外开销的独立的网络请求来获取数据。<code>NSURLSession</code> 则需要更多的开销，为了获得所要请求的数据。</p>
<h3 id="跟踪进程">跟踪进程</h3><p>AFNetworking 3.0 使用 <code>NSProgress</code> 来对 <code>NSURLSessionTasks</code> 进行跟踪。除了在上传/下载的任务中加入了对 block 的支持，<code>AFURLSessionManager</code> 还暴露了两个获得 <code>NSProgress</code> 对象的辅助方法：</p>
<ul>
<li><code>uploadProgressForTask:</code></li>
<li><code>downloadProgressForTask:</code></li>
</ul>
<h3 id="UIKit_的迁移">UIKit 的迁移</h3><p>图片下载已经被重构，以遵循 <a href="https://github.com/alamofire/alamofireimage" target="_blank" rel="external">AlamofireImage</a> 架构与新的 <code>AFImageDownloader</code> 类。这个类的图片下载职责的 delegate 是 UIButton 与 UIImageView 的 Category，并且提供了一些方法，在必要时可以自定义。在 Category 中，下载远程图片的实际方法并没有改变。</p>
<p>UIWebView 的 Category 被重构为使用 <code>AFHTTPSessionManager</code> 作为其网络请求。</p>
<h3 id="UIAlertView_的_Category_被废弃">UIAlertView 的 Category 被废弃</h3><p>从 AFNetworking 3.0 后 <code>UIAlertView</code> 的 Category 因过时而被废弃。并且没有提供  <code>UIAlertController</code> Category 的计划，因为这是应用程序应处理的逻辑，而不是这个库。</p>
<hr>
<h2 id="补充">补充</h2><p>如果你对 AFNetworking 2.0 的实现细节感兴趣，在这里推荐大神 bang 的源码分析：<a href="http://blog.cnbang.net/tech/2320/" target="_blank" rel="external">AFNetworking2.0源码解析</a></p>
<p>在接下来的文章中，我们将正式开始 3.0 的探索：D</p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-3.0-Migration-Guide#new-requirements-ios-7-mac-os-x-109-watchos-2-tvos-9--xcode-7" target="_blank" rel="external">AFNetworking 3.0 Migration Guide</a></li>
<li><a href="https://skyline75489.github.io/post/2016-3-13_ios_networking_layer_design.html" target="_blank" rel="external">浅析 iOS 应用网络层设计</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>在完成 <a href="https://github.com/rs/SDWebImage">SDWebImage</a> 的源码阅读后（可参见系列文章：<a href="http://itangqi.me/2016/03/19/the-notes-of-learning-sdwebimage-one/">SDWebImage 源码阅读笔记</a>），我又将目光瞄向了大名鼎鼎的网络库 <a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>，不过为了能保证源码阅读的流畅性，不至于到时一脸懵逼，在正式开始之前，我又恶补了下网络相关的知识，可参见相关文章：<a href="http://itangqi.me/2016/04/01/from-nsurlconnection-to-nsurlsession/">从 NSURLConnection 到 NSURLSession</a> 与<a href="http://itangqi.me/2016/04/04/the-notes-of-learning-illustrating-http-one/">《图解 HTTP》读书笔记</a>。</p>
<p>好啦，似乎万事具备，就让我们扬帆起航，开启 AFNetworking 源码阅读之旅吧！</p>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://itangqi.me/tags/AFNetworking/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="Source Code" scheme="http://itangqi.me/tags/Source-Code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UICollectionView 学习笔记]]></title>
    <link href="http://itangqi.me/2016/04/21/the-notes-of-learning-uicollectionview/"/>
    <id>http://itangqi.me/2016/04/21/the-notes-of-learning-uicollectionview/</id>
    <published>2016-04-20T16:00:00.000Z</published>
    <updated>2016-05-28T03:47:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近计划着开个新项目，前期工作准备先撸个图片选择器出来。当然核心肯定是 PhotoKit (ASsetsLibrary) 啦，不过那些会在稍后文章中介绍，今天的主角则是 <strong>UICollectionView</strong>。</p>
<a id="more"></a> 
<hr>
<h2 id="简介">简介</h2><p>首先看苹果官方文档 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionView_class/" target="_blank" rel="external">UICollectionView Class Reference</a> 的介绍:</p>
<blockquote>
<p>The UICollectionView class manages an ordered collection of data items and presents them using customizable layouts. Collection views provide the same general function as table views except that a collection view is able to support more than just single-column layouts. Collection views support customizable layouts that can be used to implement multi-column grids, tiled layouts, circular layouts, and many more. You can even change the layout of a collection view dynamically if you want.</p>
</blockquote>
<p>一句话总结就是：<strong>UICollectionView 与 UITableView 相似，却提供了可自定义多列网格（Grild）的功能。</strong></p>
<hr>
<h2 id="核心">核心</h2><ul>
<li><p><strong>Cells</strong>：单元格，用于展示内容的主体</p>
</li>
<li><p><strong>Supplementary Views</strong>：追加视图，相当于 UITableView 中每个 Section 的 Header 或 Footer</p>
</li>
<li><p><strong>Decoration Views</strong>：装饰视图，用于装饰整个 UICollectionView</p>
</li>
</ul>
<p>UICollectionView 最常见的使用场景，想必就是相册（照片墙）的实现与展示了，下面通过一张图来直观地认识 CollectionView 各部分的构成：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-001.png" alt=""></p>
<hr>
<h2 id="实现">实现</h2><p>如果你在之前有了解及使用过 UITableView 的话，那么恭喜你，你将会快速上手 UICollectionView。</p>
<h3 id="UICollectionViewDataSource">UICollectionViewDataSource</h3><p>UICollectionViewDataSource - 负责提供展示的数据，实现下面两个必须的委托方法，其实 UITableView 并无二意，所以在此不做过多介绍了。</p>
<ul>
<li><p><strong>numberOfItemsInSection</strong>：某个 section 里有多少个 item</p>
</li>
<li><p><strong>cellForItemAtIndexPath</strong>：对于某个位置应该显示什么样的 cell，里面会涉及到 cell 的复用，可参见 TableView</p>
</li>
</ul>
<p>其实到这里，CollectionView 就可以正常显示了，对吧，就是这么简单：）</p>
<h3 id="UICollectionViewDelegate">UICollectionViewDelegate</h3><p>UICollectionViewDelegate - 负责用户的交互、Cell 的外形，委托方法和 TableView 相似，可以选择性实现以下委托方法。</p>
<ul>
<li><p><strong>collectionView:shouldHighlightItemAtIndexPath</strong>：是否支持高亮？</p>
</li>
<li><p><strong>collectionView:didHighlightItemAtIndexPath</strong>：如果支持高亮，那么高亮；</p>
</li>
<li><p><strong>collectionView:shouldSelectItemAtIndexPath</strong>：询问是否可以被选中？</p>
</li>
<li><p><strong>collectionView:didUnhighlightItemAtIndexPath</strong>：如果支持高亮，那么现在取消高亮；</p>
</li>
<li><p><strong>collectionView:didSelectItemAtIndexPath</strong>：如果支持可以被选中，那么选中 cell；</p>
</li>
</ul>
<p>下面再通过几张图来更加清晰地理解：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-002.jpg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-003.jpg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-004.jpg" alt=""></p>
<h3 id="UICollectionViewLayout">UICollectionViewLayout</h3><p>在布局上，与 UITableView 直接使用系统提供的样式不同，UICollectionView 使用的是 UICollectionViewLayout 来自定义布局样式。</p>
<p>在苹果官方文档：<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/" target="_blank" rel="external">UICollectionViewLayout Class Reference</a> 中对其做了如下解释:</p>
<blockquote>
<p>The UICollectionViewLayout class is an abstract base class that you subclass and use to generate layout information for a collection view. The job of a layout object is to determine the placement of cells, supplementary views, and decoration views inside the collection view’s bounds and to report that information to the collection view when asked. The collection view then applies the provided layout information to the corresponding views so that they can be presented onscreen.</p>
</blockquote>
<p>这里做下简短的总结：</p>
<ol>
<li><p>UICollectionViewLayout 是一个抽象基类，你需要继承自他，来为 CollectionView 生成 Layout 信息。Layout 对象的作用是决定 Cells，Supplementary Views 和 Decoration Views 在 CollectionView 中的布局位置。当然啦，如果你不想折腾，苹果也贴心的为你准备了 UICollectionViewFlowLayout - 流水式布局效果。</p>
</li>
<li><p>UICollectionView 的显示效果几乎全部由 UICollectionViewLayout 负责，而真正存储着每一个 Cell 的位置、大小等属性的是 UICollectionViewLayoutAttributes 。每一个 Cell 对应着一个属于自己的 UICollectionViewLayoutAttributes，而 UICollectionViewLayout 正是利用 UICollectionViewLayoutAttributes 里存在的信息对每一个 Cell 进行布局。</p>
</li>
</ol>
<p>下面通过一张图来了解 UICollectionView 的构成：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-005.jpg" alt=""></p>
<h2 id="总结">总结</h2><p>可以说 UICollectionView 是 iOS 开发中必不可少的 UIKit 控件之一。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionView_class/" target="_blank" rel="external">UICollectionView Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/" target="_blank" rel="external">UICollectionViewLayout Class Reference</a></li>
<li><a href="http://www.appcoda.com/ios-programming-uicollectionview-tutorial/" target="_blank" rel="external">Create Grid Layout Using UICollectionView in iOS 6</a></li>
<li><a href="http://my.oschina.net/sunqichao/blog/182623" target="_blank" rel="external">UICollectionView 使用 介绍</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>最近计划着开个新项目，前期工作准备先撸个图片选择器出来。当然核心肯定是 PhotoKit (ASsetsLibrary) 啦，不过那些会在稍后文章中介绍，今天的主角则是 <strong>UICollectionView</strong>。</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="UICollectionView" scheme="http://itangqi.me/tags/UICollectionView/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初探 iOS 事件分发机制]]></title>
    <link href="http://itangqi.me/2016/04/18/the-first-meet-with-event-delivery/"/>
    <id>http://itangqi.me/2016/04/18/the-first-meet-with-event-delivery/</id>
    <published>2016-04-17T16:00:00.000Z</published>
    <updated>2016-05-28T08:34:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>今天看到一道面试题：<code>UIWindow</code> 与 <code>UIView</code> 有何区别？</p>
<p>关于问题的答案，你可以自行 Google。要说这篇文章的由来，是因为答案中说到：<strong>UIWindow 管理和协调着事件的分发</strong>，这一点引起了我的疑问。</p>
<p>那么，在 iOS 中，事件分发机制的概念与具体的流程是怎么样子的呢？如果你之前也未曾了解，亦或是一知半解，不如今天就和我一起学习下事件分发机制吧！</p>
<a id="more"></a>
<hr>
<h2 id="UIEvent">UIEvent</h2><p><code>UIEvent</code> 表示用户交互的事件对象，在其类文件中，我们可以看到有一个枚举类型的属性  <code>UIEventType</code>，这个属性表示了当前的响应事件类型（Event Type）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  UIEvent.h</span></span><br><span class="line"><span class="comment">//  UIKit</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2005-2015 Apple Inc. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIEventType</span> type</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIEventType</span>) &#123;</span><br><span class="line">    <span class="built_in">UIEventTypeTouches</span>,</span><br><span class="line">    <span class="built_in">UIEventTypeMotion</span>,</span><br><span class="line">    <span class="built_in">UIEventTypeRemoteControl</span>,</span><br><span class="line">    <span class="built_in">UIEventTypePresses</span> <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">9</span>_0),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>触控事件（UIEventTypeTouches）：单点、多点触控以及各种手势操作；</li>
<li>传感器事件（UIEventTypeMotion）：重力、加速度传感器等；</li>
<li>远程控制事件（UIEventTypeRemoteControl）：远程遥控 iOS 设备多媒体播放等；</li>
<li>按压事件（UIEventTypePresses）：3D Touch（iOS 9）；</li>
</ol>
<p>本文主要针对 Touch events 的分发进行讲解。</p>
<hr>
<h2 id="UITouch">UITouch</h2><p><code>UITouch</code> 表示单个点击，其类文件中，我们同样可以看到有一个枚举类型的属性 <code>UITouchPhase</code>，这个属性是用来表示当前点击的状态：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UITouchPhase</span> phase;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">UITouchPhase</span>,<span class="built_in">UITouchPhase</span>&#123;</span><br><span class="line">    <span class="built_in">NSTouchPhaseBegin</span>,</span><br><span class="line">    <span class="built_in">NSTouchPhaseMoved</span>,</span><br><span class="line">    <span class="built_in">NSTouchPhaseStationary</span>,</span><br><span class="line">    <span class="built_in">NSTouchPhaseEnded</span>,</span><br><span class="line">    <span class="built_in">NSTouchPhaseCanceled</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些状态包括点击开始、移动、停止不动、结束和取消五个状态。</p>
<p>每次点击发生的时候，点击对象都放在一个集合中传入 <code>UIResponder</code> 的回调方法中，我们通过集合中对象获取用户点击的位置。</p>
<h3 id="UITouch_方法">UITouch 方法</h3><p>可以通过以下方法获取用户点击的位置：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取点击坐标点</span></span><br><span class="line">-(<span class="built_in">CGPoint</span>) locationInView:(<span class="built_in">UIView</span> *)view;</span><br><span class="line"><span class="comment">//获取上个点击位置的坐标点</span></span><br><span class="line">-(<span class="built_in">CGPoint</span>) previousLocationInView:(<span class="built_in">UIView</span> *)view;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Responder_Object">Responder Object</h2><p>Responder Object（响应者对象）是能够响应并处理事件的对象，是构成 Responder Chain（响应链）和事件传递链的节点。</p>
<p>在 iOS 中，只有 <code>UIResponder</code>类的子类才能响应事件，而我们熟知的 <code>UIApplication</code>/<code>UIView</code>/<code>UIViewController</code> 都是 <code>UIResponder</code> 的子类，<code>UIResponder</code> 声明了用于处理事件的接口，并定义了默认的行为：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(nullable <span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(nullable <span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(nullable <span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(nullable <span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(nullable <span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure>
<p>这四个方法分别处理触摸开始事件、触摸移动事件、触摸终止事件、以及触摸跟踪取消事件。</p>
<p>再来看下 <code>UIResponder</code> 的继承链：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-event-delivery-01.png" alt=""></p>
<h3 id="First_Responder">First Responder</h3><p>First Responder（第一响应者）用于第一个接收事件，通常情况下，第一响应者是一个视图对象。</p>
<p>一个对象可以通过以下操作成为第一响应者：</p>
<ol>
<li>重写 <code>canBecomeFirstResponder</code> 方法，并返回 <code>YES</code></li>
<li>接收 <code>becomeFirstResponder</code> 消息，如果必要，一个对象可以给自己发这个消息</li>
</ol>
<h3 id="要点">要点</h3><ol>
<li><code>CALayer</code> 不是 <code>UIResponder</code> 的子类，这说明 <code>CALayer</code> 无法响应事件，这也是 <code>UIView</code> 与 <code>CALayer</code> 的重要区别之一</li>
</ol>
<hr>
<h2 id="Responder_Chain">Responder Chain</h2><p>当一个事件发生时，如果 First Responder 不进行处理，事件就会继续往下传递，被下个 Responder 接收，如果下个 Responder 仍不处理，又会被下下个 Responder 接收……直到一个 Responder 处理了事件或者没有 Responder 了。这些 Responder 按照传递次序连接起来的链条就构成了 Responder Chain（响应者链）。</p>
<p>下图直观地反应了事件传递的流程：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-event-delivery-02.png" alt=""></p>
<p>从图中可以看到，响应者链有以下特点：</p>
<ol>
<li><p>响应者链通常是由 initial view 开始</p>
</li>
<li><p>UIView 的 <code>nextResponder</code> 是它的 Super View；如果 UIView 已经是其所在的 UIViewController 的 Top View，那么 UIView 的 <code>nextResponder</code> 就是 UIViewController</p>
</li>
<li><p>UIViewController 如果有 Super ViewController，那么它的 <code>nextResponder</code> 为其 Super ViewController 最表层的 View；如果没有，那么它的 <code>nextResponder</code> 就是 UIWindow</p>
</li>
<li><p>UIWindow 的 contentView 指向 UIApplication，将其作为 <code>nextResponder</code></p>
</li>
<li><p>UIApplication 是一个响应者链的终点，它的 <code>nextResponder</code> 指向 AppDelegate（文档中说是 nil，如果有同学有明确的答案请告知），整个 Responder Chain 结束</p>
</li>
</ol>
<p><strong>需要说明是</strong>：如果当前的 Responder 不处理事件，并希望将其传递给 <code>nextResponder</code> 时，需要手动编写代码，才会继续往下传递，否则事件会被废弃：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">// 将事件传递给 nextResponder</span></span><br><span class="line">    <span class="keyword">id</span> theNextResponder = [<span class="keyword">self</span> nextResponder];</span><br><span class="line">    [theNextResponder touchesBegan:touches withEvent:event];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="要点-1">要点</h3><ol>
<li><code>UIResponder</code> 本身是不会去存储或者设置 <code>nextResponder</code> 的，所谓的 <code>nextResponder</code> 都是子类去实现的</li>
</ol>
<hr>
<h2 id="Hit-Test_View_&amp;_Hit-Testing">Hit-Test View &amp; Hit-Testing</h2><p><strong>Hit-Test View</strong>：当用户与触摸屏产生交互时，硬件就会探测到物理接触并且通知操作系统。操作系统就会创建相应的事件，并将其传递给当前正在运行的应用程序的事件队列。然后这个事件会被事件循环传递给优先响应对象，既 Hit-Test View</p>
<p><strong>Hit-Testing</strong>：Hit-Test View 就是事件被触发时和用户交互的对象，寻找 Hit-Test View 的过程就叫做 Hit-Testing</p>
<p>在 <code>UIView</code> 中定义了如下两个函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  UIView.h</span></span><br><span class="line"><span class="comment">//  UIKit</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2005-2015 Apple Inc. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">- (nullable <span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(nullable <span class="built_in">UIEvent</span> *)event;   <span class="comment">// recursively calls -pointInside:withEvent:. point is in the receiver's coordinate system</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(nullable <span class="built_in">UIEvent</span> *)event;   <span class="comment">// default returns YES if point is in bounds</span></span><br></pre></td></tr></table></figure>
<p>系统先调用 <code>pointInSide: WithEvent:</code> 判断当前视图以及这些视图的子视图是否能接收这次点击事件，然后在调用 <code>hitTest: withEvent:</code> 依次获取处理这个事件的所有视图对象，在获取所有的可处理事件对象后，开始调用这些对象的 touches 回调方法。</p>
<p>下面通过两张图来观察：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-event-delivery-03.png" alt=""><a href="http://zhoon.github.io/ios/2015/04/12/ios-event.html" target="_blank" rel="external">图片来自</a></p>
<p>UIWindow 有一个 MianVIew，MainView 里面有三个 Sub View：View A、View B、View C，他们各自有两个 Sub View，他们层级关系是：View A 在最下面，View B 中间，View C 最上(按照 <code>addSubview</code> 的顺序)，其中 View A 和 View B 有一部分重叠。如果手指在 View B.1 和 View A.2 重叠的上面点击，按照上面说的递归方式，顺序如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-event-delivery-04.png" alt=""><a href="http://zhoon.github.io/ios/2015/04/12/ios-event.html" target="_blank" rel="external">图片来自</a></p>
<p>递归是向界面的根节点 UIWindow 发送 <code>hitTest:withEvent:</code> 消息开始的，从这个消息返回的是一个 UIView，也就是手指当前位置最前面的那个 Hittest View。当向 UIWindow 发送 <code>hitTest:withEvent:</code> 消息时，<code>hitTest:withEvent:</code> 里面所做的事，就是判断当前的点击位置是否在 Window 里面，如果在则遍历 Window 的 Subview 然后依次对 Subview 发送 <code>hitTest:withEvent:</code> 消息（注意这里给 Subview 发送消息是根据当前 Subview 的 index 顺序，index 越大就越先被访问）。如果当前的 point 没有在 View 上面，那么这个 View 的 Subview 也就不会被遍历了。当事件遍历到了 View B.1，发现 point 在 View B.1 里面，并且 View B.1 没有 Subview，那么他就是我们要找的 Hittest View 了，找到之后就会一路返回直到根节点，而 View B 之后的 View A 也不会被遍历了。</p>
<hr>
<h2 id="总结">总结</h2><p>所以关于事件的链有两条：事件的<strong>响应链</strong>；Hit-Testing 时事件的<strong>传递链</strong>。</p>
<ul>
<li><p><strong>事件响应链</strong>：由离用户最近的 View 向系统传递：<br>initial view –&gt; Super View –&gt; …… –&gt; View Controller –&gt; Window –&gt; Application –&gt; AppDelegate</p>
</li>
<li><p><strong>事件传递链</strong>：由系统向离用户最近的 View 传递：<br>UIKit –&gt; active app’s event queue –&gt; Window –&gt; Root View –&gt; …… –&gt; Lowest View</p>
</li>
</ul>
<p>具体的应用可以参见：<a href="http://sindrilin.com/ios-dev/2015/12/27/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%93%8D%E5%BA%94%E9%93%BE.html" target="_blank" rel="external">事件传递响应链</a></p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/multitouch_background/multitouch_background.html" target="_blank" rel="external">Event Handling Guide for iOS</a></li>
<li><a href="http://sindrilin.com/ios-dev/2015/12/27/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%93%8D%E5%BA%94%E9%93%BE.html" target="_blank" rel="external">事件传递响应链</a></li>
<li><a href="https://www.zybuluo.com/MicroCai/note/66142" target="_blank" rel="external">iOS Events and Responder Chain</a></li>
<li><a href="http://zhoon.github.io/ios/2015/04/12/ios-event.html" target="_blank" rel="external">深入浅出iOS事件机制</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>今天看到一道面试题：<code>UIWindow</code> 与 <code>UIView</code> 有何区别？</p>
<p>关于问题的答案，你可以自行 Google。要说这篇文章的由来，是因为答案中说到：<strong>UIWindow 管理和协调着事件的分发</strong>，这一点引起了我的疑问。</p>
<p>那么，在 iOS 中，事件分发机制的概念与具体的流程是怎么样子的呢？如果你之前也未曾了解，亦或是一知半解，不如今天就和我一起学习下事件分发机制吧！</p>]]>
    
    </summary>
    
      <category term="Event Delivery" scheme="http://itangqi.me/tags/Event-Delivery/"/>
    
      <category term="Event Type" scheme="http://itangqi.me/tags/Event-Type/"/>
    
      <category term="Responder Chain" scheme="http://itangqi.me/tags/Responder-Chain/"/>
    
      <category term="Responder Object" scheme="http://itangqi.me/tags/Responder-Object/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 中的 Autorelease Pool]]></title>
    <link href="http://itangqi.me/2016/04/15/autorelease-pool-in-ios/"/>
    <id>http://itangqi.me/2016/04/15/autorelease-pool-in-ios/</id>
    <published>2016-04-14T16:00:00.000Z</published>
    <updated>2016-05-28T08:36:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>Objective-C 对象的生命周期取决于其引用计数。在 Objective-C 的引用计数架构中，有一项特性叫做 Autorelease Pool（自动释放池）。释放对象有两种方式：</p>
<ol>
<li>调用 <code>release</code> 方法，使其保留计数立即减 1 </li>
<li>调用 <code>autorelease</code> 方法，将其加入 Autorelease Pool 中</li>
</ol>
<p>Autorelease Pool 用于存放那些需要在稍后某个时刻释放的对象。当 Pool drain（清空）时，系统会向其中的对象发送 <code>release</code> 消息。</p>
<a id="more"></a>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/autorelease-pool-in-ios-01.jpg" alt=""></p>
<hr>
<h2 id="详解">详解</h2><p>创建 Autorelease Pool 所使用语法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在没有创建 Autorelease Pool 的情况下给对象发送 <code>autorelease</code> 消息，那么控制台会输出这样一条信息：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__<span class="built_in">NSAutoreleaseNoPool</span>(): Object <span class="number">0x350270</span> of class <span class="built_in">NSCFString</span> autoreleased with no pool <span class="keyword">in</span> place - just leaking - <span class="keyword">break</span> on objc_ autoreleaseNoPool() to debug</span><br></pre></td></tr></table></figure>
<p>而然，一般情况下无须担心 Autorelease Pool 的创建问题。Mac OS X  与 iOS 应用程序分别运行于 Cocoa 及 Cocoa Touch 环境中。系统会自动创建一些线程，比如主线程或者是 GCD 机制中的线程，这些线程默认都有 Autorelease Pool，每次执行 Event Loop（事件循环）时，就会将其清空。因此，不需要自己来创建。</p>
<p>通常只有一个地方需要创建 Autorelease Pool，那就是在 <code>main</code> 函数里，我们用 Autorelease Pool  来包裹应用程序的入口点。比如说，iOS 程序的 <code>main</code> 函数经常这样写：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实从技术角度看，不是非得有个 <code>@autoreleasepool {}</code> 才行。因为块的末尾恰好就是应用程序的终止处，而此时操作系统会把程序所占的全部内存都释放掉。虽说如此，但是如果不写这个块的话，那么由 <code>UIApplicationMain</code> 函数所自动释放的那些对象，就没有 Autorelease Pool 可以容纳了，于是系统会发出警告信息来表明这一情况。所以说，这个池可以理解成最外围捕捉全部自动释放对象所用的池。</p>
<hr>
<h2 id="示例">示例</h2><p>下面这段代码中的花括号定义了 Autorelease Pool 的范围。Autorelease Pool 于 <code>{</code>（左花括号）处创建，并于对应的 <code>}</code>（右花括号）处自动清空。位于 Autorelease Pool 范围内的对象，将在此范围末尾处收到 <code>release</code> 消息。Autorelease Pool 可以嵌套。系统在自动释放对象时，会把它放到最内层的池里。比如说：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *string = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"1 = %i"</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSNumber</span> *number = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中有两个对象，它们都由类的工厂方法所创建，这样创建出来的对象会自动释放。<code>NSString</code> 对象放在外围的 Autorelease Pool 中，而 <code>NSNumber</code> 对象则放在里层的 Autorelease Pool 中。将 Autorelease Pool 嵌套使用的好处是，可以借此控制应用程序的<strong>内存峰值（high-memory waterline）</strong>，使其不致过高。</p>
<p>考虑下面这段代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    [<span class="keyword">self</span> doSomethingWithInt:i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>doSomethingWithInt:</code> 方法要创建临时对象，那么这些对象很可能会放在 Autorelease Pool 里。比方说，它们可能是一些临时字符串。但是，即便这些对象在调用完方法之后就不再使用了，它们也依然处于]存活状态，因为目前还在 Autorelease Pool 里，等待系统稍后将其释放并回收。然而，<strong>Autorelease Pool 要等到线程执行下一个事件循环时才会清空。</strong>这就意味着在执行 for 循环时，会持续有新的对象创建出来，并加入 Autorelease Pool 中。所有这种对象都要等 for 循环执行完才会释放。这样一来，在执行 for 循环时，应用程序所占内存量就会持续上涨，而等到所有临时对象都释放之后，内存量又会突然下降。</p>
<hr>
<h2 id="实现原理">实现原理</h2><h3 id="AutoreleasePoolPage">AutoreleasePoolPage</h3><p>ARC 下，我们使用 <code>@autoreleasepool {}</code> 来使用一个 Autorelease Pool，随后编译器将其改写成下面的样子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *context = objc_autoreleasePoolPush();</span><br><span class="line"><span class="comment">// &#123;&#125;中的代码</span></span><br><span class="line">objc_autoreleasePoolPop(context);</span><br></pre></td></tr></table></figure>
<p>而这两个函数都是对 <code>AutoreleasePoolPage</code> 的简单封装，所以自动释放机制的核心就在于这个类。</p>
<p><code>AutoreleasePoolPage</code> 是一个 C++ 实现的类：</p>
<ol>
<li>Autorelease Pool 并没有单独的结构，而是由若干个 <code>AutoreleasePoolPage</code> 以<strong>双向链表</strong>的形式组合而成（分别对应结构中的 parent 指针和 child 指针）</li>
<li>Autorelease Pool 是按线程一一对应的（结构中的 thread 指针指向当前线程）</li>
<li><code>AutoreleasePoolPage</code> 每个对象会开辟 4096 字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存 autorelease 对象的地址</li>
<li>上面的 id *next 指针作为游标指向栈顶最新 add 进来的 autorelease 对象的下一个位置</li>
<li>一个 <code>AutoreleasePoolPage</code> 的空间被占满时，会新建一个 <code>AutoreleasePoolPage</code> 对象，连接链表，后来的 autorelease 对象在新的 Page 加入</li>
</ol>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/autorelease-pool-in-ios-02.jpg" alt=""></p>
<ul>
<li><code>magic</code> 用来校验 <code>AutoreleasePoolPage</code> 的结构是否完整</li>
<li><code>next</code> 指向最新添加的 autoreleased 对象的下一个位置，初始化时指向 begin() </li>
<li><code>thread</code> 指向当前线程</li>
<li><code>parent</code> 指向父结点，第一个结点的 parent 值为 nil </li>
<li><code>child</code> 指向子结点，最后一个结点的 child 值为 nil </li>
<li><code>depth</code> 代表深度，从 0 开始，往后递增 1</li>
<li><code>hiwat</code> 代表 high water mark </li>
</ul>
<p>另外，当 next == begin() 时，表示 <code>AutoreleasePoolPage</code> 为空；当 next == end() 时，表示 <code>AutoreleasePoolPage</code> 已满。</p>
<p>所以，若当前线程中只有一个 <code>AutoreleasePoolPage</code> 对象，并记录了很多 autorelease 对象地址时内存如下图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/autorelease-pool-in-ios-03.jpg" alt=""></p>
<p>图中的情况，这一页再加入一个 autorelease 对象就要满了（也就是 next 指针马上指向栈顶），这时就要执行上面说的操作，建立下一页 Page 对象，与这一页链表连接完成后，新 Page 的 next 指针被初始化在栈底（ begin 的位置），然后继续向栈顶添加新对象。</p>
<p>所以，向一个对象发送 <code>autorelease</code> 消息，就是将这个对象加入到当前 <code>AutoreleasePoolPage</code> 的栈顶 next 指针指向的位置</p>
<h3 id="释放时机">释放时机</h3><p>每当进行一次 <code>objc_autoreleasePoolPush</code> 调用时，Runtime 向当前的 <code>AutoreleasePoolPage</code>中 add 进一个<strong>哨兵对象（POOL_SENTINEL）</strong>，值为 0（也就是个 nil），那么这一个 page 就变成了下面的样子：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/autorelease-pool-in-ios-04.jpg" alt=""></p>
<p><code>objc_autoreleasePoolPush</code> 的返回值正是这个哨兵对象的地址，被 <code>objc_autoreleasePoolPop</code>（哨兵对象）作为入参，于是：</p>
<ol>
<li>根据传入的哨兵对象地址找到哨兵对象所处的 Page</li>
<li>在当前 Page 中，将晚于哨兵对象插入的所有 autorelease 对象都发送一次 <code>release</code> 消息，并向回移动next指针到正确位置</li>
<li>补充 2：从最新加入的对象一直向前清理，可以向前跨越若干个 Page，直到哨兵所在的 Page</li>
</ol>
<p>刚才的 <code>objc_autoreleasePoolPop</code> 执行后，最终变成了下面的样子：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/autorelease-pool-in-ios-05.jpg" alt=""></p>
<hr>
<h2 id="@autoreleasepool_{}">@autoreleasepool {}</h2><p>我们使用 <code>clang -rewrite-objc</code> 命令将下面的 Objective-C 代码重写成 C++ 代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将会得到以下输出结果（只保留了相关代码）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="keyword">void</span> * objc_autoreleasePoolPush(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> __declspec(dllimport) <span class="keyword">void</span> objc_autoreleasePoolPop(<span class="keyword">void</span> *);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>苹果通过声明一个 <code>__AtAutoreleasePool</code> 类型的局部变量 <code>__autoreleasepool</code> 来实现 <code>@autoreleasepool {}</code>。当声明 <code>__autoreleasepool</code> 变量时，构造函数 <code>__AtAutoreleasePool()</code> 被调用，即执行 <code>atautoreleasepoolobj = objc_autoreleasePoolPush();</code>；当出了当前作用域时，析构函数 <code>~__AtAutoreleasePool()</code> 被调用，即执行 <code>objc_autoreleasePoolPop(atautoreleasepoolobj);</code>。也就是说 <code>@autoreleasepool {}</code> 的实现代码可以进一步简化如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @autoreleasepool */</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> *atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">    <span class="comment">// 用户代码，所有接收到 autorelease 消息的对象会被添加到这个 Autorelease Pool 中</span></span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，单个 Autorelease Pool 的运行过程可以简单地理解为 <code>objc_autoreleasePoolPush()</code>、<code>[obj autorelease]</code> 和 <code>objc_autoreleasePoolPop(void *)</code> 三个过程。</p>
<h3 id="push_操作">push 操作</h3><p>上面提到的 <code>objc_autoreleasePoolPush()</code> 函数本质上就是调用的 <code>AutoreleasePoolPage</code> 的 <code>push</code> 函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">objc_autoreleasePoolPush(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们接下来看看 <code>AutoreleasePoolPage</code> 的 <code>push</code> 函数的作用和执行过程。一个 <code>push</code> 操作其实就是创建一个新的 Autorelease Pool，对应 <code>AutoreleasePoolPage</code> 的具体实现就是往 <code>AutoreleasePoolPage</code> 中的 <code>next</code> 位置插入一个 <strong>POOL_SENTINEL</strong>（哨兵对象），并且返回插入的 <code>POOL_SENTINEL</code> 的内存地址。这个地址也就是我们前面提到的 pool token ，在执行 <code>pop</code> 操作的时候作为函数的入参：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> *dest = autoreleaseFast(POOL_SENTINEL);</span><br><span class="line">    assert(*dest == POOL_SENTINEL);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>push</code> 函数通过调用 <code>autoreleaseFast</code> 函数来执行具体的插入操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> *autoreleaseFast(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>autoreleaseFast</code> 函数在执行一个具体的插入操作时，分别对三种情况进行了不同的处理：</p>
<ol>
<li>当前 Page 存在且没有满时，直接将对象添加到当前 Page 中，即 next 指向的位置</li>
<li>当前 Page 存在且已满时，创建一个新的 Page ，并将对象添加到新创建的 Page 中</li>
<li>当前 Page 不存在时，即还没有 Page 时，创建第一个 Page ，并将对象添加到新创建的 Page 中</li>
</ol>
<p>每调用一次 <code>push</code> 操作就会创建一个新的 Autorelease Pool，即往 <code>AutoreleasePoolPage</code> 中插入一个 <code>POOL_SENTINEL</code>，并且返回插入的 <code>POOL_SENTINEL</code> 的内存地址。</p>
<h3 id="autorelease_操作">autorelease 操作</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)autorelease &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootAutorelease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过查看 <code>((id)self)-&gt;rootAutorelease()</code> 的方法调用，我们发现最终调用的就是  <code>AutoreleasePoolPage</code> 的 <code>autorelease</code> 函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noinline,used))</span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AutoreleasePoolPage</code> 的 <code>autorelease</code> 函数的实现对我们来说就比较容量理解了，它跟 <code>push</code> 操作的实现非常相似。只不过 <code>push</code> 操作插入的是一个 <code>POOL_SENTINEL</code>，而 <code>autorelease</code> 操作插入的是一个具体的 autoreleased 对象：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line">    assert(!obj-&gt;isTaggedPointer());</span><br><span class="line">    <span class="keyword">id</span> *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    assert(!dest  ||  *dest == obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pop_操作">pop 操作</h3><p>同理，前面提到的 <code>objc_autoreleasePoolPop(void *)</code> 函数本质上也是调用的  <code>AutoreleasePoolPage</code> 的 <code>pop</code> 函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme rdar://9167170</span></span><br><span class="line">    <span class="keyword">if</span> (!ctxt) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pop</code> 函数的入参就是 <code>push</code> 函数的返回值，也就是 <code>POOL_SENTINEL</code> 的内存地址，即 pool token。当执行 <code>pop</code> 操作时，内存地址在 pool token 之后的所有 autoreleased 对象都会被 release。直到 pool token 所在 Page 的 next 指向 pool token 为止。</p>
<p>下面是某个线程的 Autorelease Pool 堆栈的内存结构图，在这个 Autorelease Pool 堆栈中总共有两个 <code>POOL_SENTINEL</code>，即有两个 Autorelease Pool。该堆栈由三个 <code>AutoreleasePoolPage</code> 结点组成，第一个 <code>AutoreleasePoolPage</code> 结点为 <code>coldPage()</code>，最后一个 <code>AutoreleasePoolPage</code> 结点为 <code>hotPage()</code>。其中，前两个结点已经满了，最后一个结点中保存了最新添加的 autoreleased 对象 <code>objr3</code> 的内存地址：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/autorelease-pool-in-ios-06.png" alt=""></p>
<p>此时，如果执行 <code>pop(token1)</code> 操作，那么该 Autorelease Pool 堆栈的内存结构将会变成如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/autorelease-pool-in-ios-07.png" alt=""></p>
<hr>
<h2 id="总结">总结</h2><p>这种情况不甚理想，尤其当循环长度无法预知的情况下更是如此。比方说，要从数据库中读出许多对象。代码可能会这么写：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *databaseRecords = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *people = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *record <span class="keyword">in</span> databaseRecords) &#123;</span><br><span class="line">    EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];</span><br><span class="line">    [people addObject:person];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EOCPerson</code> 的初始化函数也许会像上列那样，再创建出一些临时对象。若记录有很多条，则内存中也会有很多不必要的临时对象，它们本来应该提早回收的。增加一个 Autorelease Pool 即可解决此问题。如果把循环内的代码包裹在 <code>@autoreleasepool {}</code> 中，那么在循环中自动释放的对象就会放在这个 Pool，而不是线程的主池里面。例如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *databaseRecords = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *people = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *record <span class="keyword">in</span> databaseRecords) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];</span><br><span class="line">        [people addObject:person]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上这个 Autorelease Pool 之后，应用程序在执行循环时的内存峰值就会降低，不再像原来那么高了。内存峰值（high-memory waterline）是指应用程序在某个特定时间段内的最大内存用量（highest memory footprint）。新增的 <code>@autoreleasepool {}</code> 可以减少这个峰值，因为系统会在块的末尾把某些对象回收掉。而刚才提到的那种临时对象，就在回收之列。</p>
<p>是否应该用池来优化效率，完全取决于具体的应用程序。首先得监控内存用量，判断其中有没有需要解决的问题，如果没有完成这一步，那就别急着优化。尽管 <code>@autoreleasepool {}</code> 的开销不太大，但毕竟还是有的，所以尽量不要建立额外的 Autorelease Pool。</p>
<h3 id="MRC_vs-_ARC">MRC vs. ARC</h3><p>如果在 ARC 出现之前就写过 Objective-C 程序，那么可能还记得有种老式写法，就是使用 <code>NSAutoreleasePool</code> 对象。这个特殊的对象与普通对象不同，它专门用来表示 Autorelease Pool，就像新语法中的 <code>@autoreleasepool {}</code> 一样。但是这种写法并不会在每次执行 for 循环时都清空池，此对象更为重量级，通常用来创建那种偶尔需要清空的池，比方说：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *databaseRecords = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *people = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *record <span class="keyword">in</span> databaseRecords) &#123;</span><br><span class="line">    EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];</span><br><span class="line">    [people addObject:person];</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Drain the pool only every 10 cycles</span></span><br><span class="line">    <span class="keyword">if</span> (++i == <span class="number">10</span>) &#123;</span><br><span class="line">        [pool drain];</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Also drain at the end in case the loop is not a multiple of 10</span></span><br><span class="line">[pool drain];</span><br></pre></td></tr></table></figure>
<p>现在不需要再这样写代码了。采用随着 ARC 所引入的新语法，可以创建出更为轻量级的 Autorelease Pool。原来所写的代码可能会每执行 n 次循环清空一次 Autorelease Pool，现在可以改用 <code>@autoreleasepool {}</code> 把 for 循环中的语句包起来，这样的话，每次执行循环时都会建立并清空 Autorelease Pool。</p>
<p><code>@autoreleasepool {}</code> 语法还有个好处：每个 Autorelease Pool 均有其范围，可以避免无意间误用了那些在清空池后已为系统所回收的对象。比方说，考虑下面这段采用旧式写法的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="keyword">id</span> object = [<span class="keyword">self</span> createObject];</span><br><span class="line">[pool drain];</span><br><span class="line">[<span class="keyword">self</span> useObject:object];</span><br></pre></td></tr></table></figure>
<p>这样写虽然稍显夸张，但却能说明问题。调用 <code>useObject:</code> 方法时所传入的那个对象，可能已经为系统所回收了。同样的代码改用新式写法就变成了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="keyword">id</span> object = [<span class="keyword">self</span> createObject];</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span> useObject:object];</span><br></pre></td></tr></table></figure>
<p>这次根本就无法编译，因为 object 变量出了 Autorelease Pool 的外围后就不可用了，所以在调用 <code>useObject:</code> 方法时不能用它做参数。</p>
<h3 id="NSThread、NSRunLoop_和_NSAutoreleasePool">NSThread、NSRunLoop 和 NSAutoreleasePool</h3><p>根据苹果官方文档中对 <code>NSRunLoop</code> 的描述，我们可以知道每一个线程，包括主线程，都会拥有一个专属的 <code>NSRunLoop</code> 对象，并且会在有需要的时候自动创建。</p>
<p>在主线程的 <code>NSRunLoop</code> 对象（在系统级别的其他线程中应该也是如此，比如通过 <code>dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</code> 获取到的线程）的每个（事件循环）Event Loop 开始前，系统会自动创建一个 Autorelease Pool ，并在 Event Loop 结束时 drain 。</p>
<p>另外，<code>NSAutoreleasePool</code> 中还提到，每一个线程都会维护自己的 Autorelease Pool 堆栈。换句话说 Autorelease Pool 是与线程紧密相关的，每一个 Autorelease Pool 只对应一个线程。</p>
<p>弄清楚 <code>NSThread</code>、<code>NSRunLoop</code> 和 <code>NSAutoreleasePool</code> 三者之间的关系可以帮助我们从整体上了解 Objective-C 的内存管理机制</p>
<h3 id="使用场景">使用场景</h3><ol>
<li>你编写是命令行工具的代码，而不是基于 UI 框架的代码</li>
<li>你需要写一个循环，里面会创建很多临时的对象<ul>
<li>这时候你可以在循环内部的代码块里使用一个 <code>@autoreleasepool {}</code>，这样这些对象就能在一次迭代完成后被释放掉。这种方式可以降低内存最大占用</li>
</ul>
</li>
<li>当你大量使用辅助线程<ul>
<li>你需要在线程的任务代码中创建自己的 <code>@autoreleasepool {}</code></li>
</ul>
</li>
</ol>
<hr>
<h2 id="要点">要点</h2><ul>
<li>Autorelease Pool 排布在栈中，对象收到 <code>autorelease</code> 消息后，系统将其放入最顶端的池里。</li>
<li>合理运用 Autorelease Pool，可降低应用程序的内存峰值。</li>
<li><code>@autoreleasepool {}</code> 这种新式写法能创建出更为轻便的 Autorelease Pool。</li>
</ul>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://book.douban.com/subject/25829244/" target="_blank" rel="external">Effective Objective-C 2.0</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html#//apple_ref/doc/uid/20000047-CJBFBEDI" target="_blank" rel="external">Using Autorelease Pool Blocks</a></li>
<li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a></li>
<li><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">Objective-C Autorelease Pool 的实现原理</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>Objective-C 对象的生命周期取决于其引用计数。在 Objective-C 的引用计数架构中，有一项特性叫做 Autorelease Pool（自动释放池）。释放对象有两种方式：</p>
<ol>
<li>调用 <code>release</code> 方法，使其保留计数立即减 1 </li>
<li>调用 <code>autorelease</code> 方法，将其加入 Autorelease Pool 中</li>
</ol>
<p>Autorelease Pool 用于存放那些需要在稍后某个时刻释放的对象。当 Pool drain（清空）时，系统会向其中的对象发送 <code>release</code> 消息。</p>]]>
    
    </summary>
    
      <category term="Autorelease Pool" scheme="http://itangqi.me/tags/Autorelease-Pool/"/>
    
      <category term="Memory Management" scheme="http://itangqi.me/tags/Memory-Management/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初识 Run Loop]]></title>
    <link href="http://itangqi.me/2016/04/14/the-first-meet-with-runloop/"/>
    <id>http://itangqi.me/2016/04/14/the-first-meet-with-runloop/</id>
    <published>2016-04-13T16:00:00.000Z</published>
    <updated>2016-05-28T08:30:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在学习完内存管理与多线程的知识后，我又将目光瞄向了 <strong>Run Loop</strong>，不过受限于现阶段的能力，我在查阅了大量资料后，对于 Run Loop 的理解仍然非常浅显，所以本文绝大多数的内容，是参照网上大牛们的文章进行总结的。当然啦，我也希望在不久的将来，对于 Run Loop 能有更多自己的观点与总结。</p>
<a id="more"></a>
<hr>
<h2 id="什么是_Run_Loop">什么是 Run Loop</h2><p>首先看以下代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不知道刚接触 iOS 开发的同学有没有过这样的疑惑：我们都知道 <code>main</code> 函数是程序的入口，可为何当 <code>main</code> 函数执行完毕后，程序没有退出呢？而能在没有事情做的时候维持应用的运行的呢？</p>
<p>如果你是个好奇的宝宝，那么一定会去搜寻答案，没错，其实这背后便隐藏了今天的主角 Run Loop。</p>
<p>以下来自苹果<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="external">官方文档</a>的介绍：</p>
<blockquote>
<p>Run loops are part of the fundamental infrastructure associated with threads. A run loop is an event processing loop that you use to schedule work and coordinate the receipt of incoming events. The purpose of a run loop is to keep your thread busy when there is work to do and put your thread to sleep when there is none.</p>
<p>Run loop management is not entirely automatic. You must still design your thread’s code to start the run loop at appropriate times and respond to incoming events. Both Cocoa and Core Foundation provide run loop objects to help you configure and manage your thread’s run loop. Your application does not need to create these objects explicitly; each thread, including the application’s main thread, has an associated run loop object. Only secondary threads need to run their run loop explicitly, however. The app frameworks automatically set up and run the run loop on the main thread as part of the application startup process.</p>
</blockquote>
<p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，那么就得让它循环。</p>
<p>所以，Run Loop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行任务。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>
<p>所以，上面代码中 <code>UIApplicationMain()</code> 方法在这里不仅完成了初始化我们的程序并设置程序 Delegate 的任务，而且随之开启了主线程的 Run Loop，开始接受处理事件。这样我们的应用就可以在无人操作的时候休息，需要让它干活的时候又能立马响应。</p>
<p>直接看图更容易理解：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-10.jpg" alt=""><a href="http://stackoverflow.com/questions/5766839/end-of-run-loop-autorelease-pool-recovery" target="_blank" rel="external">图片来自</a></p>
<p>在 OS X/iOS 系统中，提供了两个这样的对象：</p>
<p>• <strong>CFRunLoopRef</strong>：是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。<br>• <strong>NSRunLoop</strong>：是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<p>首先来看一张关系图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-09.jpeg" alt="">[图片来自-sunnyxx]</p>
<hr>
<h2 id="RunLoop_与线程的关系">RunLoop 与线程的关系</h2><p>苹果不允许直接创建 Run Loop，它只提供了两个自动获取的函数：<code>CFRunLoopGetMain()</code> 和 <code>CFRunLoopGetCurrent()</code>，这两个函数内部的逻辑大概是下面这样：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 全局的 Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> loopsDic;</span><br><span class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFSpinLock_t</span> loopsLock;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 获取一个 pthread 对应的 Run Loop。</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> _<span class="built_in">CFRunLoopGet</span>(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 Run Loop。</span></span><br><span class="line">        loopsDic = <span class="built_in">CFDictionaryCreateMutable</span>();</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> mainLoop = _<span class="built_in">CFRunLoopCreate</span>();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = <span class="built_in">CFDictionaryGetValue</span>(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">/// 取不到时，创建一个</span></span><br><span class="line">        loop = _<span class="built_in">CFRunLoopCreate</span>();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, thread, loop);</span><br><span class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 Run Loop。</span></span><br><span class="line">        _<span class="built_in">CFSetTSD</span>(..., thread, loop, __<span class="built_in">CFFinalizeRunLoop</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">CFRunLoopGet</span>(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _<span class="built_in">CFRunLoopGet</span>(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，线程和 Run Loop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 Run Loop，如果你不主动获取，那它一直都不会有。Run Loop 的创建是发生在第一次获取时，Run Loop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 Run Loop（主线程除外）。</p>
<hr>
<h2 id="Run_Loop_对外的接口">Run Loop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有 5 个类:</p>
<p>• CFRunLoopRef<br>• CFRunLoopModeRef<br>• CFRunLoopSourceRef<br>• CFRunLoopTimerRef<br>• CFRunLoopObserverRef</p>
<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-01.png" alt=""><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">图片来自</a></p>
<p>对于上图的理解：一个 Run Loop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 Run Loop 的主函数时，只能指定其中一个 Mode，这个 Mode 被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p><strong>CFRunLoopSourceRef：</strong> 是事件产生的地方。Source 有两个版本：Source0 和 Source1：</p>
<p>• Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <code>CFRunLoopSourceSignal(source)</code>，将这个 Source 标记为待处理，然后手动调用 <code>CFRunLoopWakeUp(runloop)</code> 来唤醒 Run Loop，让其处理这个事件。<br>• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 Run Loop 的线程，其原理在下面会讲到。</p>
<p><strong>CFRunLoopTimerRef：</strong> 是基于时间的触发器，它和 NSTimer 是 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html" target="_blank" rel="external">Toll-Free Bridging</a> 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 Run Loop 时，Run Loop 会注册对应的时间点，当时间点到时，Run Loop 会被唤醒以执行那个回调。</p>
<p><strong>CFRunLoopObserverRef：</strong> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 Run Loop 的状态发生变化时，观察者就能通过回调接受到这个变化。</p>
<hr>
<h2 id="Run_Loop_的_Sources">Run Loop 的 Sources</h2><p>Run Loop 对象处理的事件源分为两种：Input sources 和 Timer sources：</p>
<p>• Input sources：用分发异步事件，通常是用于其他线程或程序的消息，比如：<code>performSelector:onThread:...</code></p>
<p>• Timer sources：用分发同步事件，通常这些事件发生在特定时间或者重复的时间间隔上，比如：<code>[NSTimer scheduledTimerWithTimeInterval:target:selector:...]</code></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-07.jpg" alt=""></p>
<p>上面图中展示了 Run Loop 的概念结构及各种事件源。其中 Input sources 分发异步事件给相应的处理程序并且调用 <code>runUntilDate:</code> 方法（这个方法会在该线程关联的 NSRunLoop 对象上被调用）来退出其 Run Loop。Timer sources 分发事件到相应的处理程序，但不会引起 Run Loop 退出。</p>
<h3 id="Input_sources">Input sources</h3><p>Input sources 有两个不同的种类: Port-Based Sources 和 Custom Input Sources。Run Loop 本身并不关心 Input sources 是哪一种类型。系统会实现两种不同的 Input sources 供我们使用。这两种不同类型的 Input sources 的区别在于：Port-Based Sources 由内核自动发送，Custom Input Sources 需要从其他线程手动发送。</p>
<p><strong>Custom Input Sources</strong></p>
<p>我们可以使用 Core Foundation 里面的 CFRunLoopSourceRef 类型相关的函数来创建 Custom Input Sources。</p>
<p><strong>Port-Based Sources</strong></p>
<p>通过内置的端口相关的对象和函数，配置基于端口的 Input sources。（比如在主线程创建子线程时传入一个 NSPort 对象，主线程和子线程就可以进行通讯。NSPort 对象会负责自己创建和配置 Input sources。)</p>
<h3 id="Time_sources">Time sources</h3><p>Timer sources 在预设的时间点同步的传递消息，Timer 是线程通知自己做某件事的一种方式。</p>
<p>Foundation 中 NSTimer Class 提供了相关方法来设置 Timer sources。需要注意的是除了 <code>scheduledTimerWithTimeInterval</code> 开头的方法创建的 Timer 都需要手动添加到当前 Run Loop 中。（<code>scheduledTimerWithTimeInterval</code> 创建的 Timer 会自动以 Default Mode 加载到当前 Run Loop中。）</p>
<p>Timer 在选择使用一次后，在执行完成时，会从 Run Loop 中移除。选择循环时，会一直保存在当前 Run Loop 中，直到调用 invalidated 方法。</p>
<hr>
<h2 id="Run_Loop_的_Mode">Run Loop 的 Mode</h2><p>Run Loop Mode 是指要被监听的事件源（包括 Input sources 和 Timer sources）的集合 + 要被通知的 run-loop observers 的集合。每一次运行自己的 Run Loop 时，都需要显示或者隐示的指定其运行于哪一种 Mode。在设置 Run Loop Mode 后，你的 Run Loop 会自动过滤和其他 Mode 相关的事件源，而只监视和当前设置 Mode 相关的源（通知相关的观察者）。大多数时候，Run Loop 都是运行在系统定义的默认模式上。</p>
<p>首先我们可以看一下 App 启动后 Run Loop 的状态：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoop</span> &#123;</span><br><span class="line">    current mode = k<span class="built_in">CFRunLoopDefaultMode</span></span><br><span class="line">    common modes = &#123;</span><br><span class="line">        <span class="built_in">UITrackingRunLoopMode</span></span><br><span class="line">        k<span class="built_in">CFRunLoopDefaultMode</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    common mode items = &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// source0 (manual)</span></span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order =-<span class="number">1</span>, &#123;</span><br><span class="line">            callout = _<span class="built_in">UIApplicationHandleEventQueue</span>&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order =-<span class="number">1</span>, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// source1 (mach port)</span></span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">17923</span>&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">12039</span>&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">16647</span>&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order =-<span class="number">1</span>, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;port = <span class="number">2407</span>,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__<span class="built_in">CFMachPortPvlS1_</span>&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>b03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">1</span>, &#123;port = <span class="number">1903</span>,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Ovserver</span></span><br><span class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = -<span class="number">2147483647</span>, activities = <span class="number">0x1</span>, <span class="comment">// Entry</span></span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">0</span>, activities = <span class="number">0x20</span>,          <span class="comment">// BeforeWaiting</span></span><br><span class="line">            callout = _<span class="built_in">UIGestureRecognizerUpdateObserver</span>&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">1999000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _after<span class="built_in">CACommitHandler</span>&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">2000000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _ZN2<span class="built_in">CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span>&#125;</span><br><span class="line">        <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">2147483647</span>, activities = <span class="number">0xa0</span>, <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Timer</span></span><br><span class="line">        <span class="built_in">CFRunLoopTimer</span> &#123;firing = No, interval = <span class="number">3.1536e+09</span>, tolerance = <span class="number">0</span>,</span><br><span class="line">            next fire date = <span class="number">453098071</span> (-<span class="number">4421.76019</span> @ <span class="number">96223387169499</span>),</span><br><span class="line">            callout = _ZN2<span class="built_in">CAL14timer_callbackEP16__CFRunLoopTimerPv</span> (QuartzCore<span class="variable">.framework</span>)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">            sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            timers =    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">            sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">            timers =    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopObserver</span> &gt;&#123;activities = <span class="number">0xa0</span>, order = <span class="number">2000000</span>,</span><br><span class="line">                    callout = _ZN2<span class="built_in">CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span>&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopSource</span> &#123;order = -<span class="number">1</span>, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopSource</span> &#123;order = -<span class="number">1</span>, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，系统默认注册了 5 个 Mode：</p>
<ol>
<li>kCFRunLoopDefaultMode：App的默认 Mode，通常主线程是在这个 Mode 下运行的</li>
<li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>
<li>UIInitializationRunLoopMode：在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用（私有）</li>
<li>GSEventReceiveRunLoopMode：接受系统事件的内部 Mode，通常用不到</li>
<li>kCFRunLoopCommonModes：这是一个占位的 Mode，没有实际作用</li>
</ol>
<p>下图列出了 Cocoa 和 Core Foundation 中定义的一些 Modes：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-08.png" alt=""></p>
<p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoopMode</span> &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;            <span class="comment">// Mode Name, 例如 @"kCFRunLoopDefaultMode"</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// Array</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> __<span class="built_in">CFRunLoop</span> &#123;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为 “Common” 属性（通过将其 Mode Name 添加到 RunLoop 的 “commonModes” 中）。每当 Run Loop 的内容发生变化时，Run Loop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有 Mode 里。</p>
<p>应用场景举例：主线程的 Run Loop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为 “Common” 属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个 TableView 时，Run Loop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 Run Loop 的 “commonModeItems” 中。”commonModeItems” 被 Run Loop 自动更新到所有具有 “Common” 属性的 Mode 里去。</p>
<p>你只能通过 Mode Name 来操作内部的 Mode，当你传入一个新的 Mode Name 但 Run Loop 内部没有对应 Mode 时，Run Loop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 Run Loop 来说，其内部的 Mode 只能增加不能删除。</p>
<p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 Mode Name。</p>
<hr>
<h2 id="Run_Loop_的_Observers">Run Loop 的 Observers</h2><p>对比上面说的事件源——它们是在特定的同步事件或异步事件发生时被触发，Run Loop Observers 就不一样了，它是在 Run Loop 执行自己的代码到某一个指定位置时被触发。我们可以用 Run Loop Observers 来跟踪到这些事件：</p>
<ul>
<li>进入 Run Loop 的时候</li>
<li>Run Loop 将要处理一个 Timer source 的时候</li>
<li>Run Loop 将要处理一个 Input source 的时候</li>
<li>Run Loop 将要休眠的时候</li>
<li>Run Loop 被唤醒，并准备处理唤醒它的事件的时候</li>
<li>Run Loop 将要退出的时候</li>
</ul>
<p>与 Timer 类似，Run Loop Observers 也可以只观察一次或者反复观察。只观察一次的话，就在 fire 后把自己从 Run Loop 中给移除掉就行了</p>
<p>当你为一个需要长时间运行的线程配置 Run Loop 时，最好是能添加至少一个 Input source 到 Run Loop 中，这比用 Timer source 更好，Timer 要么一次，触发完了，就会结束，而之后 Run Loop 也就结束了，要么循环，这样就会导致周期性地唤醒线程，这实际上是一种轮询的形式。与之相反，Input source会一直等待对应的事件发生，而在事件发生前它能让线程先休眠。</p>
<hr>
<h2 id="Run_Loop_事件处理流程">Run Loop 事件处理流程</h2><p>Run Loop 本质是一个处理事件源的循环。我们对 Run Loop 的运行时具有控制权，如果当前没有时间发生，Run Loop 会让当前线程进入睡眠模式，来减轻 CPU 压力。如果有事件发生，Run Loop 就处理事件并通知相关的 Observer。具体的顺序如下:</p>
<ol>
<li>Run Loop 进入的时候，会通知 Observer</li>
<li>Timer 即将被触发时，会通知 Observer</li>
<li>有其它非 Port-Based Input Source 即将被触发时，会通知 Observer</li>
<li>触发非 Port-Based Input Source 的事件源</li>
<li>如果一个基于端口的 Input source 已经就绪，那就立即处理这个事件，跳转到步骤 9</li>
<li>通知 Observer 当前线程进入睡眠状态</li>
<li>让线程休眠，除非下面的事件发生：<ul>
<li>一个对应着基于端口的 Input source 的事件到来</li>
<li>一个 timer 触发了</li>
<li>Run Loop 的超时了</li>
<li>Run Loop 被显示唤醒</li>
</ul>
</li>
<li>通知 Observer 线程被唤醒</li>
<li>处理等待的事件<ul>
<li>如果一个用户定义的 Timer 触发了，处理这个 Timer 事件并且重启 Run Loop，跳转到步骤 2</li>
<li>如果一个 Input source 触发了，分发这个事件</li>
<li>如果 Run Loop 被显式地唤醒了并且还没超时，重启 Run Loop，跳转到步骤 2</li>
</ul>
</li>
<li>通知 observers 这个 Run Loop 要退出了</li>
</ol>
<p>由于与 Timer source 和 Input source 相关的 observer 通知是在事件发生前发出去的，所以这些通知和真实的事件发生时间之间是存在一定的延时的。如果你需要精确的时间控制，而这个延时对你来说很致命的话，你可以使用休眠通知和唤醒通知来校队事件实际发生时间。</p>
<p>由于 timer 和其他一些周期性的事件是在你运行其对应的 Run Loop 的时候被分发的，所以当绕过这个 Loop 的时候，这些事件的分发也会被干扰到。一个典型的例子就是当你实现一个鼠标事件追踪的例程时，你进入到一个循环里不断地向应用请求事件，由于你直接抓取这些事件而不是正常地由应用向你的例程分发，这时那些活动的timer也会无法触发，除非你的鼠标事件追踪例程退出并将控制器交给应用。</p>
<p>可以通过 Run Loop 对象来显式地唤醒 Run Loop。其他事件也可以唤醒 Run Loop，比如：添加一个其他的非基于端口的 Input source 可以唤醒 Run Loop 立即处理这个 Input source，而不是等到其他事件发生才处理。</p>
<hr>
<h2 id="Run_Loop_对象的线程安全问题">Run Loop 对象的线程安全问题</h2><p>使用 Core Foundation 中的方法通常是线程安全的，可以被任意线程调用。如果修改了 Run Loop 的配置然后需要执行某些操作，我们最好是在 Run Loop 所在的线程中执行这些操作。</p>
<p>使用 Foundation 中的 NSRunLoop 类来修改自己的 Run Loop，我们必须在 Run Loop 的所在线程中完成这些操作。在其他线程中给 Run Loop 添加事件源或者 Timer 会导致程序崩溃。</p>
<hr>
<h2 id="Run_Loop_的内部逻辑">Run Loop 的内部逻辑</h2><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-02.png" alt=""><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">图片来自</a></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 用DefaultMode启动</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), k<span class="built_in">CFRunLoopDefaultMode</span>, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// RunLoop的实现</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunSpecific</span>(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __<span class="built_in">CFRunLoopFindMode</span>(runloop, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (__<span class="built_in">CFRunLoopModeIsEmpty</span>(currentMode)) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">    __<span class="built_in">CFRunLoopDoObservers</span>(runloop, currentMode, k<span class="built_in">CFRunLoopEntry</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 内部函数，进入loop</span></span><br><span class="line">    __<span class="built_in">CFRunLoopRun</span>(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">truetruetrue<span class="comment">// 省略</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">    __<span class="built_in">CFRunLoopDoObservers</span>(rl, currentMode, k<span class="built_in">CFRunLoopExit</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，实际上 Run Loop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>
<hr>
<h2 id="Run_Loop_的底层实现">Run Loop 的底层实现</h2><p>从上面代码可以看到，Run Loop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OS X/iOS 的系统架构。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-03.png" alt=""><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">图片来自</a></p>
<p>苹果官方将整个系统大致划分为上述 4 个层次：</p>
<p>• 应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。<br>• 应用框架层即开发人员接触到的 Cocoa 等框架。<br>• 核心框架层包括各种核心框架、OpenGL 等内容。<br>• Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 <a href="http://opensource.apple.com/" target="_blank" rel="external">opensource.apple.com</a> 里找到。</p>
<p>我们在深入看一下 Darwin 这个核心的架构：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-04.png" alt=""><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">图片来自</a></p>
<p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。<br>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。<br>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。<br>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>
<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些 API 非常基础，如果没有这些 API 的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>
<p>一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，发送和接受消息是通过同一个 API 进行的。</p>
<p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-05.png" alt=""><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">图片来自</a></p>
<p>这些概念可以参考维基百科: <a href="https://en.wikipedia.org/wiki/System_call" target="_blank" rel="external">System_call</a>、<a href="https://en.wikipedia.org/wiki/Trap_(computing" target="_blank" rel="external">Trap_(computing)</a>)。</p>
<p><strong>Run Loop 的核心就是一个 <code>mach_msg()</code>，Run Loop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 <code>mach_msg_trap()</code> 这个地方。</strong></p>
<p>关于具体的如何利用 mach port 发送信息，可以看看 NSHipster <a href="http://nshipster.com/inter-process-communication/" target="_blank" rel="external">这一篇文章</a>，或者这里的<a href="https://segmentfault.com/a/1190000002400329" target="_blank" rel="external">中文翻译</a> 。</p>
<p>关于Mach的历史可以看看这篇很有趣的文章：<a href="http://history.programmer.com.cn/8121/" target="_blank" rel="external">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p>
<hr>
<h2 id="苹果用_Run_Loop_实现的功能">苹果用 Run Loop 实现的功能</h2><h3 id="AutoreleasePool">AutoreleasePool</h3><p>在主线程执行的代码，通常是写在诸如事件回调、Timer 回调内的。这些回调会被 Run Loop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h3 id="事件响应">事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h3 id="手势识别">手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop 即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行 GestureRecognizer 的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="界面更新">界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<p>这个函数内部的调用栈大概是这样的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2<span class="built_in">CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span>()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> layoutSublayers];</span><br><span class="line">                            [<span class="built_in">UIView</span> layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [<span class="built_in">CALayer</span> display];</span><br><span class="line">                            [<span class="built_in">UIView</span> drawRect];</span><br></pre></td></tr></table></figure>
<h3 id="定时器">定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 Run Loop 后，Run Loop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。Run Loop 为了节省资源，并不会在非常准确的时间点回调这个 Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<h3 id="PerformSelecter">PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 Run Loop 中。所以如果当前线程没有 Run Loop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 Run Loop 该方法也会失效。</p>
<h3 id="关于_GCD">关于 GCD</h3><p>GCD 提供的某些接口也用到了 Run Loop， 例如 dispatch_async()。</p>
<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code> 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h3 id="关于网络请求">关于网络请求</h3><p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-first-meet-with-runloops-06.png" alt=""><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">图片来自</a></p>
<p>NSURLConnectionLoader 中的 Run Loop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 Run Loop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 Run Loop 对 Delegate 执行实际的回调。</p>
<hr>
<h2 id="Run_Loop_的实际应用举例">Run Loop 的实际应用举例</h2><h3 id="AFNetworking">AFNetworking</h3><p>由于计划之后会阅读 <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a> 的源码，并整理成系列的文章，所以，这里先留个坑，回头再来补上。</p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1" target="_blank" rel="external">Threading Programming Guide</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/" target="_blank" rel="external">NSRunLoop Class Reference</a></li>
<li><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></li>
<li><a href="http://www.samirchen.com/ios-runloop/" target="_blank" rel="external">iOS中的RunLoop</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>在学习完内存管理与多线程的知识后，我又将目光瞄向了 <strong>Run Loop</strong>，不过受限于现阶段的能力，我在查阅了大量资料后，对于 Run Loop 的理解仍然非常浅显，所以本文绝大多数的内容，是参照网上大牛们的文章进行总结的。当然啦，我也希望在不久的将来，对于 Run Loop 能有更多自己的观点与总结。</p>]]>
    
    </summary>
    
      <category term="NSRunLoop" scheme="http://itangqi.me/tags/NSRunLoop/"/>
    
      <category term="Run Loop" scheme="http://itangqi.me/tags/Run-Loop/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
</feed>
