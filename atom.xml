<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Qi Tang's Blog]]></title>
  <subtitle><![CDATA[你不能把这个世界，让给你所鄙视的人]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://itangqi.me/"/>
  <updated>2017-05-23T13:05:55.000Z</updated>
  <id>http://itangqi.me/</id>
  
  <author>
    <name><![CDATA[Qi Tang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Dribbble 第三方 iOS 客户端比较]]></title>
    <link href="http://itangqi.me/2017/05/23/the-comparison-of-third-party-dribbble-clients/"/>
    <id>http://itangqi.me/2017/05/23/the-comparison-of-third-party-dribbble-clients/</id>
    <published>2017-05-22T16:00:00.000Z</published>
    <updated>2017-05-23T13:05:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近的两个月，利用工作之余，我设计并开发了一款 <a href="https://dribbble.com/" target="_blank" rel="external">Dribbble</a> 第三方 iOS 客户端：<strong>Driki</strong> 。在郑重介绍 Driki 之前，今天我想先谈一谈，对目前市面上已有的 Dribbble 第三方客户端的一些看法。在此先感谢一下，正是有了它们的存在，才使得我能在 <strong>Driki</strong> 的设计与开发上得到许多灵感。下文中，我一共会提及 4 款应用，它们分别是：<a href="https://itunes.apple.com/us/app/zeeen-dribbble-client/id923813895?mt=8" target="_blank" rel="external">ZEEEN</a>、<a href="https://itunes.apple.com/us/app/balllin-a-dribbble-client/id457288487?mt=8" target="_blank" rel="external">Balllin</a>、<a href="https://itunes.apple.com/cn/app/super-ball-uigreat-dribbble-client/id1179976723?mt=8" target="_blank" rel="external">SuperBall</a> 与 <a href="https://itunes.apple.com/cn/app/dribbbiu-better-dribbble-client/id1098608767?mt=8&amp;ign-mpt=uo%3D8" target="_blank" rel="external">Dribbbiu</a> ，我会分别从售价、特点与不足进行分析与比较。</p>
<a id="more"></a> 
<hr>
<h2 id="ZEEEN">ZEEEN</h2><h3 id="售价">售价</h3><ul>
<li>18 元（以 2017-05-23 当日售价为准）</li>
</ul>
<h3 id="设计">设计</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-09.PNG" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-10.PNG" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-11.PNG" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-03.PNG" alt=""></p>
<h3 id="特点">特点</h3><ul>
<li>自定义底部导航栏（NavigationBar）用于例如：返回上级、搜索等操作；</li>
<li>Shot 详情页内，背景颜色与文字颜色，来自色板，视觉效果相当赞；</li>
<li>Shot 详情页内，支持左右滑动进行查看；</li>
<li>支持搜索；</li>
<li>支持 3D Touch ；</li>
<li>支持 Gif 全屏浏览；</li>
<li>支持添加 Shot 至 Bucket ；</li>
<li>应用中的动画效果与整体设计风格非常赞；</li>
<li>错误处理提示完整，例如：网络请求次数超出限制的提示；</li>
<li>拥有应用引导页；</li>
</ul>
<h3 id="不足">不足</h3><ul>
<li>支持在 Shot 详情页左右滑动进行上一个 \ 下一个查看，但返回首页后位置仍然停留在最初的地方，影响在首页继续浏览的体验；</li>
<li>不支持评论；</li>
<li>不支持 iPad ；</li>
</ul>
<h3 id="总结">总结</h3><p>在我看来，无论是设计还是功能的完整程度，<code>ZEEEN</code> 毫无疑问是目前市面上最好的 <code>Dribbble</code> 第三方客户端（没有之一）。当然啦，其也并不是 100% 完美，未能支持 iPad ，便是一大遗憾。</p>
<hr>
<h2 id="Balllin">Balllin</h2><h3 id="售价-1">售价</h3><ul>
<li>30 元（以 2017-05-23 当日售价为准）</li>
</ul>
<h3 id="设计-1">设计</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-04.PNG" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-06.PNG" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-19.PNG" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-02.PNG" alt=""></p>
<h3 id="特点-1">特点</h3><ul>
<li>功能上：<code>ZEEEN</code> 有的，<code>Balllin</code> 都有，所以详见 <code>ZEEEN</code> 即可；</li>
<li>相较 <code>ZEEEN</code> 而言最大的优势便是其支持 iPad ； </li>
</ul>
<h3 id="不足-1">不足</h3><ul>
<li>在详情页内无法左右滑动查看；</li>
<li>Shot 不支持点击全屏浏览；</li>
<li>搜索功能似乎无返回结果？（不知是否是 BUG）</li>
<li>设计风格不够现代；</li>
<li>不能 unlike；</li>
</ul>
<h3 id="总结-1">总结</h3><p><code>Balllin</code> 作为老牌 Dribbble 第三方客户端，功能相当完整，且支持 iPad ，但其 30 元的售价相较 <code>ZEEEN</code> 或接下来的两款应用都没有明显优势。</p>
<hr>
<h2 id="SuperBall">SuperBall</h2><h3 id="售价-2">售价</h3><ul>
<li>6 元（以 2017-05-23 当日售价为准）</li>
</ul>
<h3 id="设计-2">设计</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-08.PNG" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-15.PNG" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-05.PNG" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-14.PNG" alt=""></p>
<h3 id="特点-2">特点</h3><ul>
<li>Shot 详情页内，支持下拉手势从详情页返回首页，且返回后的位置与详情页一致，这个功能相对赞；</li>
<li>支持 iPad ；</li>
</ul>
<h3 id="不足-2">不足</h3><ul>
<li>不支持 3D Touch ；</li>
<li>虽然支持 iPad ，但体验效果较为差；</li>
</ul>
<h3 id="总结-2">总结</h3><p>其实 <code>SuperBall</code> 在设计上大量借鉴了 <code>ZEEEN</code> ，并增加了 <code>ZEEEN</code> 所不具有的返回首页的手势操作。不过在长时间使用后发现，<code>SuperBall</code> 在许多细节上仍与 <code>ZEEEN</code> 存在着一定差距，但是 6 元的价格，又使得其具有相对较高的性价比。</p>
<hr>
<h2 id="Dribbbiu">Dribbbiu</h2><h3 id="售价-3">售价</h3><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-07.PNG" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-13.PNG" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-20.PNG" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-comparison-of-third-party-dribbble-clients-01.PNG" alt=""></p>
<h3 id="价格">价格</h3><ul>
<li>12 元（以 2017-05-23 当日售价为准）</li>
</ul>
<h3 id="特点-3">特点</h3><ul>
<li>自定义底部 Tabbar ；</li>
<li>局部支持 3D Touch ；</li>
<li>支持评论，并支持 @ 他人；</li>
<li>支持 iPad，且支持分屏，是所有 Dribbble 第三方客户端中体验最好的；</li>
</ul>
<h3 id="不足-3">不足</h3><ul>
<li>应用中无返回按钮，仅靠手势右划返回；</li>
<li>不支持在详情页左右滑动查看；</li>
<li>不支持 Gif 全屏浏览；</li>
<li>无搜索功能；</li>
</ul>
<h3 id="总结-3">总结</h3><p><code>Dribbbiu</code> 的设计是我目前为止最为喜欢的，支持 iPad 并且支持分屏，但其在交互和功能上都有所缺失，加之 12 元的售价，无意使其性价比大打折扣；</p>
<hr>
<h2 id="总结-4">总结</h2><p>上文中提及的 4 款（收费）应用是我个人在试用了近 20 款 Dribbble 第三方客户端后，认为综合得分最高的 4 款。它们各有各的特点，但同时也存在的明显的不足（有点价位过高，有的功能不全），而我要做 <strong>Driki</strong> 的目的之一，便是希望能取其所长，补其所短，做一款设计、功能与价格综合性价比最高的 Dribbble 第三方客户端。</p>
<p>最后，目前 <strong>Driki</strong> 正处于内测阶段，如果你对 <strong>Driki</strong> 感兴趣的话，欢迎前往：<a href="https://wj.qq.com/s/1379045/d450" target="_blank" rel="external">https://wj.qq.com/s/1379045/d450</a> 填写邮箱用于接受「TestFlight」，我保证，它不会让你失望的：）</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>最近的两个月，利用工作之余，我设计并开发了一款 <a href="https://dribbble.com/">Dribbble</a> 第三方 iOS 客户端：<strong>Driki</strong> 。在郑重介绍 Driki 之前，今天我想先谈一谈，对目前市面上已有的 Dribbble 第三方客户端的一些看法。在此先感谢一下，正是有了它们的存在，才使得我能在 <strong>Driki</strong> 的设计与开发上得到许多灵感。下文中，我一共会提及 4 款应用，它们分别是：<a href="https://itunes.apple.com/us/app/zeeen-dribbble-client/id923813895?mt=8">ZEEEN</a>、<a href="https://itunes.apple.com/us/app/balllin-a-dribbble-client/id457288487?mt=8">Balllin</a>、<a href="https://itunes.apple.com/cn/app/super-ball-uigreat-dribbble-client/id1179976723?mt=8">SuperBall</a> 与 <a href="https://itunes.apple.com/cn/app/dribbbiu-better-dribbble-client/id1098608767?mt=8&amp;ign-mpt=uo%3D8">Dribbbiu</a> ，我会分别从售价、特点与不足进行分析与比较。</p>]]>
    
    </summary>
    
      <category term="Dribbble" scheme="http://itangqi.me/tags/Dribbble/"/>
    
      <category term="Driki" scheme="http://itangqi.me/tags/Driki/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Using Kotlin for Android Development]]></title>
    <link href="http://itangqi.me/2017/03/28/using-kotlin-for-android-development/"/>
    <id>http://itangqi.me/2017/03/28/using-kotlin-for-android-development/</id>
    <published>2017-03-27T16:00:00.000Z</published>
    <updated>2017-03-28T06:28:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Preface">Preface</h2><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-kotlin-01.png" alt=""></p>
<blockquote>
<p>本文主要记录了我在学习并使用 <code>Kotlin</code> 参与开发我司应用<a href="http://www.wandoujia.com/apps/com.huaban.android" target="_blank" rel="external">花瓣</a>的过程中总结出来的心得体会，顺带也想安利一波 <code>Kotlin</code>。</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="Kotlin">Kotlin</h2><blockquote>
<p>Statically typed programming language for the JVM, Android and the browser. (100% interoperable with Java™)</p>
</blockquote>
<p><code>Kotlin</code> 是由 JetBrains 在 2010 年推出的基于 JVM 的新编程语言，作为一个跨平台的语言，<code>Kotlin</code> 可以应用于任何 Java 的工作环境：服务器端的应用，移动应用（Android 版），桌面应用程序。</p>
<h3 id="Advantage">Advantage</h3><ol>
<li>Concise to reduce the amount of boilerplate code you need to write.</li>
<li>Expressive to make your code more readable and understandable.</li>
<li>Safe to avoid entire classes of errors such as null pointer exceptions.</li>
<li>Versatile for building server-side applications, Android apps or frontend code running in the browser.</li>
<li>Interoperable to leverage existing frameworks and libraries of the JVM with 100 percent Java interoperability. </li>
</ol>
<p>如果你之前对 <code>Kotlin</code> 并不了解，那么当你看到 <code>Kotlin</code> 的这些特性之后，现在是不是已经抑制不住内心的小激动了呢？</p>
<p><strong>Talk is cheap. Show me the code.</strong> 下面将通过代码来直观的感受下 <code>Kotlin</code> 是如何提升开发者的幸福感的。</p>
<h3 id="Concise">Concise</h3><p>举个例子，在使用 <code>Java</code> 开发时，我们定义一个 <code>Artist</code> 数据类，我们需要去编写（至少生成）这些代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Artist</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String mbid;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMbid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mbid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMbid</span><span class="params">(String mbid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mbid = mbid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Artist&#123;"</span> +</span><br><span class="line">          <span class="string">"id="</span> + id +</span><br><span class="line">          <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">          <span class="string">", url='"</span> + url + <span class="string">'\''</span> +</span><br><span class="line">          <span class="string">", mbid='"</span> + mbid + <span class="string">'\''</span> +</span><br><span class="line">          <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而使用 <code>Kotlin</code> ，我们只需编写如下代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data <span class="class"><span class="keyword">class</span> <span class="title">Artist</span></span>(</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> id</span>: <span class="typename">Long</span>,</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> name</span>: String,</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> url</span>: String,</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> mbid</span>: String)</span><br></pre></td></tr></table></figure>
<p><code>Kotlin</code> 将自动帮我们生成 <code>getter</code> 、 <code>setter</code> 、 <code>toString</code> 、 <code>equals</code> 、 <code>hashCode</code> 和其他方法，如 <code>copy（）</code> 。</p>
<h3 id="Null_Safety">Null Safety</h3><p>在使用 <code>Java</code> 开发的时候，我们的代码大多是防御性的。如果我们不想遇到 <code>NullPointerException</code> ，我们就需要在使用它之前不停地去判断它是否为 <code>null</code> 。如很多现代的语言，<code>Kotlin</code> 是<strong>空安全</strong>的，因为我们需要通过一个安全调用操作符（<code>?</code>）来明确地指定一个对象是否能为空。</p>
<p>在 <code>Kotlin</code> 中，所有变量在默认情况下都被视为不可为空，因此尝试为变量分配空值将导致编译错误。如果你想明确声明一个变量可以接受一个空值，那么你需要附加一个 <code>？</code> 操作符到变量类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此时并不能通过编译，Artist 不可以为 null</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> notNullArtist</span>: Artist = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，Artist 可以为 null</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> artist</span>: Artist? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h4 id="The_Safe_Call_Operator_\_The_Elvis_Operator_\_The_!!_Operator">The Safe Call Operator \ The Elvis Operator \ The !! Operator</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法编译，artist 可能为 null，我们需要进行处理</span></span><br><span class="line">artist.print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要在 artist != null 时才会打印</span></span><br><span class="line">artist?.print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 智能转换，如果我们在之前进行了空检查，则不需要使用安全调用操作符调用</span></span><br><span class="line"><span class="keyword">if</span> (artist != <span class="literal">null</span>) &#123;</span><br><span class="line">  artist.print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有在确保 artist 不为 null 的情况下才能这么调用，否则它会抛出异常</span></span><br><span class="line">artist!!.print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Elvis 操作符来给定一个在是 null 的情况下的替代值</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> name</span> = artist?.name ?: <span class="string">"empty"</span></span><br></pre></td></tr></table></figure>
<h3 id="Higher-Order_functions">Higher-Order functions</h3><p>很多语言已经支持了高阶函数，比如 <code>Java 8</code> ，但是你并不能用上 <code>Java 8</code> 。如果你在用 <code>Java 6</code> 或者 <code>Java 7</code> ，下面的例子实现了一个具有过滤功能的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">R <span class="title">call</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(Collection&lt;T&gt; items, Function&lt;T, Boolean&gt; f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> List&lt;T&gt; filtered = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">  <span class="keyword">for</span> (T item : items) <span class="keyword">if</span> (f.call(item)) filtered.add(item);</span><br><span class="line">  <span class="keyword">return</span> filtered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter(numbers, <span class="keyword">new</span> Function&lt;Integer, Boolean&gt;() &#123;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们首先要声明一个函数接口，接受参数类型为 <code>T</code> ，返回类型为 <code>R</code> 。我们用接口中的方法遍历操作了目标集合，创建了一个新的列表，把符合条件的过滤了出来。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">filter</span><span class="params">(items: <span class="typename">Collection&lt;T&gt;, f: (T</span>)</span> -&gt; Boolean): List<span class="type">&lt;T&gt;</span> &#123;</span></span><br><span class="line">  <span class="variable"><span class="keyword">val</span> filtered</span> = arrayListOf<span class="type">&lt;T&gt;</span>()</span><br><span class="line">  <span class="keyword">for</span> (item <span class="keyword">in</span> items) <span class="keyword">if</span> (f(item)) filtered.add(item)</span><br><span class="line">  <span class="keyword">return</span> filtered</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码是在 <code>Kotlin</code> 下的实现，是不是简单很多？我们调用的时候如下： <code>kotlin filter(numbers, { value -&gt; value % 2 == 0 })</code></p>
<p>你可能也发现了，我们没有定义任何的函数接口，这是因为在 <code>Kotlin</code> 中，函数也是一种数据类型。看到 <code>f:(T) -&gt; Boolean</code> 这个语句了吗？这就是函数类型作为参数的写法，<code>f</code> 是函数别名，<code>T</code> 是函数接受参数，<code>Boolean</code> 是这个函数的返回值。定义完成后，我们随后就能跟调用其他函数一样调用 <code>f</code> 。调用 <code>filter</code> 的时候，我们是用 <code>lambda</code> 表达式来传入过滤函数的，即：<code>{value -&gt; value % 2 = 0}</code> 。</p>
<h3 id="Lambdas">Lambdas</h3><p>同样，在 <code>Java 8</code> 前，由于缺少了对 <code>lambdas</code> 的支持，所以编写监听和回调事件是件非常繁琐的事情。而 <code>Kotlin</code> 有着非常好的 <code>lambdas</code> 支持。</p>
<p>我们来看一个常见的例子：将一个点击监听器添加到一个按钮。在 <code>Java 7</code> 及更早版本中，通常需要以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">       Toast.makeText(<span class="keyword">this</span>, <span class="string">"Button clicked"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>而然，使用 <code>Kotlin</code> 只需一行代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(&#123; view -&gt; toast(<span class="string">"Button clicked"</span>) &#125;)</span><br></pre></td></tr></table></figure>
<p>真是简单且易读。</p>
<h3 id="Extension_Functions">Extension Functions</h3><p>在使用 <code>Java</code> 开发的时候，我们经常会写一大堆的 <code>Utils</code> 类，以满足不同使用场景的需求，而 <code>Kotlin</code> 提供了 <code>Extension Functions</code> 这一特性允许我们可以给任何已存在的类添加方法，包括在 <code>Java</code> 中的一些基本类型。毫不夸张，<code>Extension Functions</code> 绝对算得上 <code>Kotlin</code> 最强大的特性之一。</p>
<p>下面是一个工具函数，判断传入的字符串是否为电话号码格式，它接受一个字符串参数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isPhoneNumber</span><span class="params">(phoneNumber: <span class="typename">String</span>)</span>: Boolean &#123;</span></span><br><span class="line">    <span class="keyword">return</span> phoneNumber.isNotBlank() &amp;&amp; Pattern.matches(<span class="string">"^1\\d&#123;10&#125;$"</span>, phoneNumber)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>Extension Functions</code> 特性，就能给已存在的类（<code>String</code>）添加方法，写法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">isPhoneNumber</span><span class="params">()</span> : Boolean &#123;</span></span><br><span class="line">    <span class="keyword">return</span> this.isNotBlank() &amp;&amp; Pattern.matches(<span class="string">"^1\\d&#123;10&#125;$"</span>, this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就是我们的调用方法，我们可以直接在字符串类型上调用这个方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"18612345678"</span>.isPhoneNumber()</span><br></pre></td></tr></table></figure>
<p><strong>或许有人会问了，那既然可以给已存在的类添加方法，那是否可以添加属性（成员）呢？答案是肯定的！</strong></p>
<p>关于上述问题的阐述，请参见：<a href="http://blog.inico.me/2016/10/26/Kotlin-Magic-Java-Swift#.WNiCcHR97YZ" target="_blank" rel="external">Kotlin的黑魔法</a></p>
<h3 id="Anko">Anko</h3><blockquote>
<p>Anko is a library which makes Android application development faster and easier. It makes your code clean and easy to read, and lets you forget about rough edges of Android SDK for Java.</p>
</blockquote>
<p><a href="https://github.com/Kotlin/anko" target="_blank" rel="external"><code>Anko</code></a> 大大简化了工作视图、线程和 Android 生命周期。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> act</span> = this</span><br><span class="line"><span class="variable"><span class="keyword">val</span> layout</span> = LinearLayout(act)</span><br><span class="line">layout.orientation = LinearLayout.VERTICAL</span><br><span class="line"><span class="variable"><span class="keyword">val</span> name</span> = EditText(act)</span><br><span class="line"><span class="variable"><span class="keyword">val</span> button</span> = Button(act)</span><br><span class="line">button.text = <span class="string">"Say Hello"</span></span><br><span class="line">button.setOnClickListener &#123;</span><br><span class="line">    Toast.makeText(act, <span class="string">"Hello, $&#123;name.text&#125;!"</span>,Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br><span class="line">layout.addView(name)</span><br><span class="line">layout.addView(button)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">verticalLayout｛</span><br><span class="line">    <span class="variable"><span class="keyword">val</span> name</span> = editText()</span><br><span class="line">    button(<span class="string">"Say Hello"</span>) &#123;</span><br><span class="line">        onClick &#123; toast(<span class="string">"Hello, $&#123;name.text&#125;!"</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Tips">Tips</h2><h3 id="Kotlin_Android_Extensions">Kotlin Android Extensions</h3><p><code>Kotlin Android Extensions</code> 本质上是一个视图绑定，使得开发者在代码中通过 <code>id</code> 就可以使用 <code>XML</code> 文件中定义的 <code>View</code> 。它将自动为 <code>View</code> 创建属性值，而不用使用第三方注解框架或者 <code>findViewById</code> 函数。</p>
<p>例如，我们有 <code>activity_main.xml</code> 如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">android.support.constraint.ConstraintLayout</span></span><br><span class="line">    <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:app</span>=<span class="value">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">tools:context</span>=<span class="value">"me.itangqi.practicekotlin.MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/textView"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"Hello World!"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">android.support.constraint.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果我们想在 <code>MainActivity</code> 中使用 <code>activity_main.xml</code> 里面定义的 <code>TextView</code> ，你只需要导入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br></pre></td></tr></table></figure>
<p>之后便可以直接引用了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span> &#123;</span></span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line">    textView.text = <span class="string">"I´m a welcome text!!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，<code>Kotlin Android Extensions</code> 在给我们带来开发上的快感的同时，也带来了隐患（我是真的被坑过…），那就是：<strong>只要你 <code>import kotlinx.android.synthetic.main.xxx</code> ，你便可以在当前 <code>Activity</code> \ <code>Fragment</code>，使用任何 <code>xml</code> 中声明的 <code>View</code>，而这也许并不是你想要的</strong> ，例如，我们有一个 <code>activity_second.xml</code> ，其中定义了一个 <code>Button</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    android:id=<span class="string">"@+id/actionButton"</span></span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>只要我们导入了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_second.*</span><br></pre></td></tr></table></figure>
<p>我们便可在 <code>MainActivity</code> 中使用不属于 <code>activity_main.xml</code> 中的 <code>Button</code> ：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span> &#123;</span></span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line">    actionButton.text = <span class="string">"Click Me"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时可以正常通过编译，并不会报错，直到运行到该页面时 (&gt;_&lt;｡)</p>
<p>因为 Android Studio 的智能提示，你需要在开发时格外注意，不要引入不属于本页面的 <code>View</code>：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/using-kotlin-for-android-development-01.png" alt=""></p>
<p>此时，多个 <code>xml</code> 中可能都声明了 <code>id</code> 为 <code>textView</code> 的 <code>TextView</code>，一定要注意了。</p>
<h3 id="minSdkVersion_API">minSdkVersion API</h3><p>这又是一个实实在在踩过的坑，由于 AS 之前的版本（&lt;2.3），<code>Lint</code> 并没有提示，我直接调用了高于 <code>minSdkVersion</code> 的 API ，结果当然惨不忍睹…</p>
<p>不过，当我现在试图复现这个问题时，发现最新版 <code>2.3</code> 已经有提示了：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/using-kotlin-for-android-development-02.png" alt=""></p>
<p>上述两个问题，其实严格上说，并不是 <code>Kotlin</code> 或者 <code>Android Studio</code> 的锅，因为通过问题反应出的，更多的是，要求我们在平日的开发工作中，提高编程时的规范，并时刻注重细节。</p>
<hr>
<h2 id="Reference">Reference</h2><ol>
<li><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="external">Kotlin Reference</a></li>
<li><a href="https://code.tutsplus.com/articles/coding-functional-android-apps-in-kotlin-lambdas-null-safety-more--cms-27964" target="_blank" rel="external">Coding Functional Android Apps in Kotlin: Lambdas, Null Safety &amp; More</a></li>
<li><a href="https://realm.io/news/droidcon-michael-pardo-kotlin/" target="_blank" rel="external">Kotlin: A New Hope in a Java 6 Wasteland</a></li>
<li><a href="https://medium.com/@juanchosaravia/learn-kotlin-while-developing-an-android-app-introduction-567e21ff9664#.y45ce9sa6" target="_blank" rel="external">Learn Kotlin with Keddit</a></li>
<li><a href="http://blog.inico.me/2016/10/26/Kotlin-Magic-Java-Swift#.WNiCcHR97YZ" target="_blank" rel="external">Kotlin的黑魔法</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Preface">Preface</h2><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-kotlin-01.png" alt=""></p>
<blockquote>
<p>本文主要记录了我在学习并使用 <code>Kotlin</code> 参与开发我司应用<a href="http://www.wandoujia.com/apps/com.huaban.android">花瓣</a>的过程中总结出来的心得体会，顺带也想安利一波 <code>Kotlin</code>。</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Android" scheme="http://itangqi.me/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://itangqi.me/tags/Kotlin/"/>
    
      <category term="Android" scheme="http://itangqi.me/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MVVM With ReactiveCocoa]]></title>
    <link href="http://itangqi.me/2017/03/25/the-notes-of-learning-mvvm-with-rac/"/>
    <id>http://itangqi.me/2017/03/25/the-notes-of-learning-mvvm-with-rac/</id>
    <published>2017-03-24T16:00:00.000Z</published>
    <updated>2017-03-25T08:30:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>本文仅作为个人对于 <code>MVVM With ReactiveCocoa</code> 学习与使用的总结，文章绝大部分内容来自网络，详情请见参考链接。</p>
</blockquote>
<p>Last updated on 2017.03.25</p>
<a id="more"></a> 
<hr>
<h2 id="Functor_Applicative_Monad">Functor Applicative Monad</h2><h3 id="Functor_、Applicative_和_Monad_是什么："><code>Functor</code> 、<code>Applicative</code> 和 <code>Monad</code> 是什么：</h3><ol>
<li>一个 <code>Functor</code> 就是一种实现了 <code>Functor typeclass</code> 的数据类型。</li>
<li>一个 <code>Applicative</code> 就是一种实现了 <code>Applicative typeclass</code> 的数据类型。</li>
<li>一个 <code>Monad</code> 就是一种实现了 <code>Monad typeclass</code> 的数据类型。</li>
</ol>
<h3 id="typeclass"><code>typeclass</code></h3><p><code>typeclass</code> 就类似于 <code>Java</code> 中的接口，或者 <code>Objective-C</code> 中的协议。在 <code>typeclass</code> 中定义了一些函数，实现一个 <code>typeclass</code> 就是要实现这些函数，而所有实现了这个 <code>typeclass</code> 的数据类型都会拥有这些共同的行为。</p>
<h3 id="Functor_、Applicative_和_Monad_三者之间的联系："><code>Functor</code> 、<code>Applicative</code> 和 <code>Monad</code> 三者之间的联系：</h3><ol>
<li><p><code>Applicative</code> 是增强型的 <code>Functor</code> ，一种数据类型要成为 <code>Applicative</code> 的前提条件是它必须是 <code>Functor</code> ；</p>
</li>
<li><p><code>Monad</code> 是增强型的 <code>Applicative</code> ，一种数据类型要成为 <code>Monad</code> 的前提条件是它必须是 <code>Applicative</code> 。</p>
</li>
</ol>
<h3 id="Functor_、_Applicative_和_Monad_三者之间的区别："><code>Functor</code> 、 <code>Applicative</code> 和 <code>Monad</code> 三者之间的区别：</h3><ol>
<li><code>Functor</code> ：使用 <code>fmap</code> 应用一个函数到一个上下文中的值；</li>
<li><code>Applicative</code> ：使用 <code>&lt;*&gt;</code> 应用一个上下文中的函数到一个上下文中的值；</li>
<li><code>Monad</code> ：使用 <code>&gt;&gt;=</code> 应用一个接收一个普通值但是返回一个在上下文中的值的函数到一个上下文中的值。</li>
</ol>
<hr>
<h2 id="MVC">MVC</h2><p><code>MVC</code> 是 <code>iOS</code> 开发中使用最普遍的架构模式，同时也是苹果官方推荐的架构模式。<code>MVC</code> 代表的是 <code>Model–View–Controller</code> ，它们之间的关系如下：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-mvvm-with-rac-01.png" alt=""></p>
<p>是的，<code>MVC</code> 看上去棒极了，<code>Model</code> 代表数据，<code>View</code> 代表  <code>UI</code> ，而 <code>Controller</code> 则负责协调它们两者之间的关系。然而，尽管从技术上看 <code>View</code> 和 <code>Controller</code> 是相互独立的，但事实上它们几乎总是结对出现，一个 <code>View</code> 只能与一个  <code>Controller</code> 进行匹配，反之亦然。既然如此，那我们为何不将它们看作一个整体呢：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-mvvm-with-rac-02.png" alt=""></p>
<p>因此，<code>M-VC</code> 可能是对 <code>iOS</code> 中的 <code>MVC</code> 模式更为准确的解读。在一个典型的 <code>MVC</code> 应用中，<code>Controller</code> 由于承载了过多的逻辑，往往会变得臃肿不堪，所以 <code>MVC</code> 也经常被人调侃成 <strong>Massive View Controller</strong> ：</p>
<blockquote>
<p>iOS architecture, where MVC stands for Massive View Controller.</p>
</blockquote>
<hr>
<h2 id="MVVM">MVVM</h2><p>因此，一种可以很好地解决 <code>Massive View Controller</code> 问题的办法就是将 <code>Controller</code> 中的展示逻辑抽取出来，放置到一个专门的地方，而这个地方就是 <code>ViewModel</code> 。其实，我们只要在上图中的 <code>M-VC</code> 之间放入 <code>VM</code> ，就可以得到 <code>MVVM</code> 模式的结构图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-mvvm-with-rac-04.svg" alt=""></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-mvvm-with-rac-03.png" alt=""></p>
<p>从上图中，我们可以非常清楚地看到 <code>MVVM</code> 中四个组件之间的关系。</p>
<p><strong>注：除了 <code>View</code> 、<code>ViewModel</code> 和 <code>Model</code> 之外，<code>MVVM</code>  中还有一个非常重要的隐含组件 <code>Binder</code> ：</strong></p>
<ul>
<li><code>View</code> ：由 <code>MVC</code> 中的 <code>View</code> 和 <code>Controller</code> 组成，负责 <code>UI</code> 的展示，绑定 <code>ViewModel</code> 中的属性，触发  <code>ViewModel</code> 中的命令；</li>
<li><code>ViewModel</code> ：从 <code>MVC</code> 的 <code>Controller</code> 中抽取出来的展示逻辑，负责从 <code>Model</code> 中获取 <code>View</code> 所需的数据，转换成  <code>View</code> 可以展示的数据，并暴露公开的属性和命令供 <code>View</code> 进行绑定；</li>
<li><code>Model</code> ：与 <code>MVC</code> 中的 <code>Model</code> 一致，包括数据模型、访问数据库的操作和网络请求等；</li>
<li><code>Binder</code> ：在 <code>MVVM</code> 中，声明式的数据和命令绑定是一个隐含的约定，它可以让开发者非常方便地实现 <code>View</code> 和  <code>ViewModel</code> 的同步，避免编写大量繁杂的样板化代码。在微软的 <code>MVVM</code> 实现中，使用的是一种被称为 <a href="https://en.wikipedia.org/wiki/Extensible_Application_Markup_Language" target="_blank" rel="external">XAML</a> 的标记语言。</li>
</ul>
<h3 id="响应式">响应式</h3><h3 id="函数式">函数式</h3><ol>
<li>高阶函数：高阶函数是入参是函数或者返回值是函数的函数</li>
<li>不变量</li>
<li>迭代</li>
</ol>
<h3 id="数据绑定">数据绑定</h3><p>在 <code>MVVM</code> 的架构中，最为关键的一环莫过于 <code>ViewModel</code> 层与 <code>View</code> 层的绑定了，我们的主角 <code>FRP</code> 恰好可以解决绑定问题，同时还能处理跨层错误处理的问题。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单向绑定</span></span><br><span class="line">    RAC(<span class="keyword">self</span><span class="variable">.someLabel</span>, text) = RACObserve(<span class="keyword">self</span><span class="variable">.viewModel</span>, someProperty);</span><br><span class="line">    RAC(<span class="keyword">self</span><span class="variable">.scrollView</span>, hidden) = <span class="keyword">self</span><span class="variable">.viewModel</span><span class="variable">.someSignal</span>;</span><br><span class="line">    RAC(<span class="keyword">self</span><span class="variable">.confirmButton</span>, frame) = [<span class="keyword">self</span><span class="variable">.viewModel</span><span class="variable">.someChannel</span></span><br><span class="line">                                      map:^<span class="keyword">id</span>(<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">                                          <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, str<span class="variable">.length</span> * <span class="number">3</span>);</span><br><span class="line">                                          <span class="keyword">return</span> [<span class="built_in">NSValue</span> valueWith<span class="built_in">CGRect</span>:rect];</span><br><span class="line">                                      &#125;];</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 双向绑定</span></span><br><span class="line">    RACChannelTo(<span class="keyword">self</span><span class="variable">.someLabel</span>, text) = RACChannelTo(<span class="keyword">self</span><span class="variable">.viewModel</span>, someProperty);</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.textField</span><span class="variable">.rac_newTextChannel</span> subscribe:<span class="keyword">self</span><span class="variable">.viewModel</span><span class="variable">.someChannel</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.viewModel</span><span class="variable">.someChannel</span> subscribe:<span class="keyword">self</span><span class="variable">.textField</span><span class="variable">.rac_newTextChannel</span>];</span><br><span class="line">    RACChannelTo(<span class="keyword">self</span>, reviewID) = <span class="keyword">self</span><span class="variable">.viewModel</span><span class="variable">.someChannel</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 命令绑定</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.confirmButton</span><span class="variable">.rac_command</span> = <span class="keyword">self</span><span class="variable">.viewModel</span><span class="variable">.someCommand</span>;</span><br><span class="line">    </span><br><span class="line">    RAC(<span class="keyword">self</span><span class="variable">.textField</span>, hidden) = <span class="keyword">self</span><span class="variable">.viewModel</span><span class="variable">.someCommand</span><span class="variable">.executing</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.viewModel</span><span class="variable">.someCommand</span><span class="variable">.errors</span></span><br><span class="line">     subscribeNext:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">         <span class="comment">// 错误处理在这里</span></span><br><span class="line">     &#125;];</span><br></pre></td></tr></table></figure>
<h3 id="子_ViewModel">子 ViewModel</h3><p><code>ViewModel</code> 不必在屏幕上显示所有东西。你可用子 <code>Viewmodel</code> 来代表屏幕上更小，更潜在被封装的部分。如果一个视图上的一小块儿（比如表格的 Cell）在 App 中可以被重用以及表现多个数据-模型对象，子 <code>ViewModel</code> 会格外有利。</p>
<h3 id="ReactiveViewModel">ReactiveViewModel</h3><blockquote>
<p>ReactiveViewModel is a combination code/documentation project for building Cocoa applications using Model-View-ViewModel and ReactiveCocoa.</p>
</blockquote>
<p><a href="https://github.com/ReactiveCocoa/ReactiveViewModel" target="_blank" rel="external">https://github.com/ReactiveCocoa/ReactiveViewModel</a></p>
<h3 id="注意事项">注意事项</h3><ol>
<li><code>ViewModel</code> 中的代码是与 <code>View</code> 无关的。</li>
<li><code>ViewModel</code> 中使用 <code>readonly</code> 控制访问权限。</li>
<li><code>ViewController</code> 总的责任是处理 <code>ViewModel</code> 中的变化。</li>
<li>并非使用 <code>MVVM</code> 模式就必须的使用 <code>ReactiveCocoa</code> ，可以使用 <code>KVO</code> , <code>Block</code> , <code>Delegate</code> , <code>Notification</code> 等手段，而 <code>ReactiveCocoa</code> 更优雅的实现了这个过程。</li>
</ol>
<hr>
<h2 id="参考链接">参考链接</h2><ol>
<li><a href="http://blog.leichunfeng.com/blog/2015/11/08/functor-applicative-and-monad/" target="_blank" rel="external">Functor、Applicative 和 Monad</a></li>
<li><a href="http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/" target="_blank" rel="external">MVVM With ReactiveCocoa</a></li>
<li><a href="http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/" target="_blank" rel="external">ReactiveCocoa and MVVM, an Introduction</a></li>
<li><a href="https://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1" target="_blank" rel="external">MVVM Tutorial with ReactiveCocoa: Part 1/2</a></li>
<li><a href="http://williamzang.com/blog/2016/06/27/ios-kai-fa-xia-de-han-shu-xiang-ying-shi-bian-cheng/" target="_blank" rel="external">iOS开发下的函数响应式编程</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>本文仅作为个人对于 <code>MVVM With ReactiveCocoa</code> 学习与使用的总结，文章绝大部分内容来自网络，详情请见参考链接。</p>
</blockquote>
<p>Last updated on 2017.03.25</p>]]>
    
    </summary>
    
      <category term="MVC" scheme="http://itangqi.me/tags/MVC/"/>
    
      <category term="MVVM" scheme="http://itangqi.me/tags/MVVM/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="ReactiveCocoa" scheme="http://itangqi.me/tags/ReactiveCocoa/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ReactiveCocoa 知识点整理]]></title>
    <link href="http://itangqi.me/2017/03/22/the-notes-of-learning-reactivecocoa/"/>
    <id>http://itangqi.me/2017/03/22/the-notes-of-learning-reactivecocoa/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2017-03-24T06:57:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>本文仅作为个人对于 <code>ReactiveCocoa</code> 学习与使用的总结，文章绝大部分内容来自网络，详情请见参考链接。</p>
</blockquote>
<p>Last updated on 2017.03.24</p>
<a id="more"></a> 
<hr>
<h2 id="FRP_思想">FRP 思想</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = a + b <span class="comment">// c is 4</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">3</span></span><br><span class="line"><span class="comment">// now what is the value of c?</span></span><br></pre></td></tr></table></figure>
<p>简单来讲，FRP 是基于异步事件流进行编程的一种编程范式。针对离散事件序列进行有效的封装，利用函数式编程的思想，满足响应式编程的需要。</p>
<hr>
<h2 id="ReactiveCocoa_常见类">ReactiveCocoa 常见类</h2><h3 id="信号源相关">信号源相关</h3><h4 id="RACStream">RACStream</h4><blockquote>
<p>An abstract class representing any stream of values.</p>
</blockquote>
<p><code>RACStream</code> 是一个抽象类，是以 <code>Monad</code>（函数式编程语言）的概念为依据进行设计的，它代表的就是一个 <code>Monad</code>。有了 <code>Monad</code> 作为基石后，许多基于流的操作就可以被建立起来了，比如 <code>map</code> 、<code>filter</code> 、<code>zip</code> 等。 </p>
<h4 id="RACSignal">RACSignal</h4><p>可以把信号想象成水龙头，只不过里面不是水，而是玻璃球（value），直径跟水管的内径一样，这样就能保证玻璃球是依次排列，不会出现并排的情况（数据都是线性处理的，不会出现并发情况）。水龙头的开关默认是关的，除非有了接收方（subscriber），才会打开。这样只要有新的玻璃球进来，就会自动传送给接收方。可以在水龙头上加一个过滤嘴（filter），不符合的不让通过，也可以加一个改动装置，把球改变成符合自己的需求（map）。也可以把多个水龙头合并成一个新的水龙头（combineLatest:reduce:），这样只要其中的一个水龙头有玻璃球出来，这个新合并的水龙头就会得到这个球。</p>
<p><code>RACSignal</code> 代表的是将来会被传递的值，它是一种 <code>push-driven</code> 的流。<code>RACSignal</code> 可以向订阅者发送三种不同类型的事件：</p>
<ul>
<li><code>next</code> ：<code>RACSignal</code> 通过 <code>next</code> 事件向订阅者传送新的值，并且这个值可以为 <code>nil</code>；</li>
<li><code>error</code> ：<code>RACSignal</code> 通过 <code>error</code> 事件向订阅者表明信号在正常结束前发生了错误；</li>
<li><code>completed</code> ：<code>RACSignal</code> 通过 <code>completed</code> 事件向订阅者表明信号已经正常结束，不会再有后续的值传送给订阅者。</li>
</ul>
<p>注意，<code>ReactiveCocoa</code> 中的值流只包含正常的值，即通过 <code>next</code> 事件传送的值，并不包括 <code>error</code> 和 <code>completed</code> 事件，它们需要被特殊处理。通常情况下，一个信号的生命周期是由任意个 <code>next</code> 事件和一个 <code>error</code> 事件或一个 <code>completed</code> 事件组成的。</p>
<p><code>RACSignal</code> 的 <code>Subscription</code> 过程概括起来可以分为三个步骤：</p>
<ol>
<li>[RACSignal createSignal] 来获得 signal</li>
<li>[signal subscribeNext:] 来获得 subscriber，然后进行subscription</li>
<li>进入 didSubscribe ，通过 [subscriber sendNext:] 来执行 next block</li>
</ol>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-reactivecocoa-01.svg" alt=""></p>
<h4 id="RACSubject">RACSubject</h4><p><code>RACSubject</code> 代表的是可以手动控制的信号，我们可以把它看作是 <code>RACSignal</code> 的可变版本，就好比 <code>NSMutableArray</code> 是 <code>NSArray</code> 的可变版本一样。<code>RACSubject</code> 继承自 <code>RACSignal</code> ，所以它可以作为信号源被订阅者订阅，同时，它又实现了 <code>RACSubscriber</code> 协议，所以它也可以作为订阅者订阅其他信号源，这个就是 <code>RACSubject</code> 为什么可以手动控制的原因。</p>
<p>实际使用中，在 <code>MVVM</code> 中使用 <code>RACSubject</code> 可以非常方便地实现统一的错误处理逻辑。比如，我们可以在 <code>viewModel</code> 的基类中声明一个 <code>RACSubject</code> 类型的属性 <code>errors</code> ，然后在 <code>viewController</code> 的基类中编写统一的错误处理逻辑：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span><span class="variable">.viewModel</span><span class="variable">.errors</span> subscribeNext:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">// 错误处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RACCommand">RACCommand</h4><blockquote>
<p>A command is a signal triggered in response to some action, typically UI-related.</p>
</blockquote>
<p><code>RACCommand</code> 通常用来表示某个 <code>Action</code> 的执行，比如点击<code>Button</code>。它有几个比较重要的属性：executionSignals / errors / executing。</p>
<ul>
<li><code>executionSignals</code> ：是 signal of signals ，如果直接 subscribe 的话会得到一个 signal ，而不是我们想要的 value，所以一般会配合 <code>switchToLatest</code> 。</li>
<li><code>errors</code> ：跟正常的 signal 不一样，RACCommand 的错误不是通过 sendError 来实现的，而是通过 errors 属性传递出来的。</li>
<li><code>executing</code> ：表示该 command 当前是否正在执行。</li>
</ul>
<h4 id="RACSequence">RACSequence</h4><blockquote>
<p>Represents an immutable sequence of values. Unless otherwise specified, the sequences’ values are evaluated lazily on demand. Like Cocoa collections, sequences cannot contain nil.</p>
</blockquote>
<p><code>RACSequence</code> 代表的是一个不可变的值的序列，与 <code>RACSignal</code> 不同，它是 <code>pull-driven</code> 类型的流。从严格意义上讲，<code>RACSequence</code> 并不能算作是信号源，因为它并不能像 <code>RACSignal</code> 那样，可以被订阅者订阅，但是它与 <code>RACSignal</code> 之间可以非常方便地进行转换。</p>
<p>因此，我们可以非常方便地使用 <code>RACSequence</code> 来实现集合的链式操作，直到得到你想要的最终结果为止，常用的使用场景为「字典转模型」。</p>
<p><strong>注意</strong>：<code>RACSequence</code> 会涉及到性能与效率的问题。</p>
<h3 id="订阅者相关">订阅者相关</h3><h4 id="RACSubscriber">RACSubscriber</h4><blockquote>
<p>Represents any object which can directly receive values from a RACSignal.</p>
</blockquote>
<p>订阅者对信号源的一次订阅过程可以抽象为：通过 <code>RACSignal</code> 的 <code>-subscribe:</code> 方法传入一个订阅者，并最终返回一个 <code>RACDisposable</code> 对象的过程。</p>
<p><strong>注意</strong>：在 <code>ReactiveCocoa</code> 中并没有专门的类 <code>RACSubscription</code> 来代表一次订阅，而间接地使用 <code>RACDisposable</code> 来充当这一角色。因此，一个 <code>RACDisposable</code> 对象就代表着一次订阅，并且我们可以用它来取消这次订阅。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribeNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))nextBlock &#123;</span><br><span class="line">true<span class="built_in">NSCParameterAssert</span>(nextBlock != <span class="literal">NULL</span>);</span><br><span class="line">true</span><br><span class="line">trueRACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:<span class="literal">NULL</span> completed:<span class="literal">NULL</span>];</span><br><span class="line">true<span class="keyword">return</span> [<span class="keyword">self</span> subscribe:o];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)subscriberWithNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))next error:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *error))error completed:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completed &#123;</span><br><span class="line">trueRACSubscriber *subscriber = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line"></span><br><span class="line">truesubscriber-&gt;_next = [next <span class="keyword">copy</span>];</span><br><span class="line">truesubscriber-&gt;_error = [error <span class="keyword">copy</span>];</span><br><span class="line">truesubscriber-&gt;_completed = [completed <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">true<span class="keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">true<span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"This method must be overridden by subclasses"</span>);</span><br><span class="line">true<span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="调度器相关">调度器相关</h3><h4 id="RACScheduler">RACScheduler</h4><blockquote>
<p>Schedulers are used to control when and where work is performed.</p>
</blockquote>
<p><code>RACScheduler</code> 在 <code>ReactiveCocoa</code> 中就是扮演着调度器的角色，本质上，它就是用 <code>GCD</code> 的串行队列来实现的，并且支持取消操作。是的，在 <code>ReactiveCocoa</code> 中，并没有使用到 <code>NSOperationQueue</code> 和 <code>NSRunloop</code> 等技术，<code>RACScheduler</code> 也只是对 <code>GCD</code> 的简单封装而已。</p>
<h3 id="清洁工相关">清洁工相关</h3><h4 id="RACDisposable">RACDisposable</h4><blockquote>
<p>A disposable encapsulates the work necessary to tear down and cleanup a subscription.</p>
</blockquote>
<p><code>RACDisposable</code> 在 <code>ReactiveCocoa</code> 中就充当着清洁工的角色，它封装了取消和清理一次订阅所必需的工作。它有一个核心的方法 <code>-dispose</code> ，调用这个方法就会执行相应的清理工作，这有点类似于 <code>NSObject</code> 的 <code>-dealloc</code> 方法。</p>
<hr>
<h2 id="ReactiveCocoa_常见用法">ReactiveCocoa 常见用法</h2><h3 id="代替代理">代替代理</h3><ul>
<li><code>rac_signalForSelector</code> 用户代替代理</li>
</ul>
<h3 id="代替_KVO">代替 KVO</h3><ul>
<li><code>rac_valuesAndChangesForKeyPath</code> 用于监听某个对象的某个属性的改变</li>
</ul>
<h3 id="代替事件监听">代替事件监听</h3><ul>
<li><code>rac_signalForControlEvents</code> 用于监听某个事件</li>
</ul>
<h3 id="代替通知">代替通知</h3><ul>
<li><code>rac_addObserverForName</code> 用于监听某个通知，且不需要在 <code>- (void)dealloc</code> 中移除监听</li>
</ul>
<h3 id="监听文本框文字改变">监听文本框文字改变</h3><ul>
<li><code>rac_textSignal</code> 用于监听文本框文字变化</li>
</ul>
<h3 id="代替手势">代替手势</h3><ul>
<li><code>rac_gestureSignal</code>用于监听手势操作</li>
</ul>
<h3 id="多个请求完成时，再执行后继操作">多个请求完成时，再执行后继操作</h3><ul>
<li><code>rac_liftSelector:withSignalsFromArray:Signals</code> 当传入的 Signals，每一个 Signal 都至少 sendNext 过一次，就会去触发第一个 selector 参数的方法。</li>
</ul>
<h3 id="信号的相关操作">信号的相关操作</h3><ul>
<li><code>bind</code> ：函数会返回一个新的信号 N。整体思路是对原信号 O 进行订阅，每当信号 O 产生一个值就将其转变成一个中间信号 M ，并马上订阅 M ，之后将信号M的输出作为新信号 N 的输出。</li>
<li><code>map</code> \ <code>flattenMap</code> ：用于把源信号内容映射成新的内容（信号）。</li>
<li><code>concat</code> ：组合，按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号。</li>
<li><code>then</code> ：用于连接两个信号，当第一个信号完成，才会连接 <code>then</code> 返回的信号。</li>
<li><code>merge</code> ：把多个信号合并为一个信号，任何一个信号有新值的时候就会调用。</li>
<li><code>zipWith</code> ：把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的 <code>next</code> 事件。</li>
<li><code>combineLatest</code> ：将多个信号合并起来，并且拿到各个信号的最新的值，必须每个合并的 <code>signal</code> 至少都有过一次 <code>sendNext</code> ，才会触发合并的信号。</li>
<li><code>reduce</code> ：聚合，用于信号发出的内容是元组，把信号发出元组的值聚合成一个值。</li>
<li><code>filter</code> ：过滤信号，使用它可以获取满足条件的信号。</li>
<li><code>ignore</code> ：忽略某些值的信号，使用 <code>RACObserve</code> 时可配合使用，其实现由 <code>filter</code> 完成。</li>
<li><code>distinctUntilChanged</code> ：实现是用 <code>bind</code> 来完成的，每次变换中都记录一下原信号上一次发送过来的值，并与这一次进行比较，如果是相同的值，就「吞」掉，返回 empty 信号。只有和原信号上一次发送的值不同，变换后的新信号才把这个值发送出来。</li>
<li><code>take</code> ：从开始一共取 N 次的信号。</li>
<li><code>takeLast</code> ：取最后 N 次的信号，前提条件：订阅者必须调用完成，因为只有完成，才知道总共有多少信号。</li>
<li><code>takeUntil</code> ：获取信号直到某个信号执行完成。</li>
<li><code>skip</code> ：跳过几个信号，不接受。</li>
<li><code>switchToLatest</code> ：用于 <code>signalOfSignals</code>（信号的信号），有时候信号也会发出信号，会在 <code>signalOfSignals</code> 中，获取 <code>signalOfSignals</code> 发送的最新信号。</li>
<li><code>doNext</code> ：执行 <code>next</code> 之前，会先执行这个 Block 。</li>
<li><code>doCompleted</code> ：执行 <code>sendCompleted</code> 之前，会先执行这个Block 。</li>
<li><code>timeout</code> ：超时，可以让一个信号在一定的时间后，自动报错。</li>
<li><code>interval</code> ：定时：每隔一段时间发出信号。</li>
<li><code>delay</code> ：延迟发送 <code>next</code> 。</li>
<li><code>retry</code> ：重试，只要失败，就会重新执行创建信号中的 block ，直到成功。</li>
<li><code>replay</code> ：重放，当一个信号被多次订阅，反复播放内容。</li>
<li><code>throttle</code> ：节流，当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</li>
</ul>
<hr>
<h2 id="ReactiveCocoa_常见宏">ReactiveCocoa 常见宏</h2><ul>
<li><code>RAC(TARGET, ...)</code> 用于绑定某个对象的某个属性</li>
<li><code>RACObserve(TARGET, KEYPATH)</code> 用于监听某个对象的某个属性，返回的是信号</li>
<li><code>@weakify(Obj)</code> &amp; <code>@strongify(Obj)</code> 配套使用</li>
</ul>
<hr>
<h2 id="注意事项">注意事项</h2><h3 id="Side_Effect">Side Effect</h3><blockquote>
<p>Side effects occur for each subscription by default, but there are certain situations where side effects should only occur once – for example, a network request typically should not be repeated when a new subscriber is added.</p>
</blockquote>
<p>如果某个信号被多个 <code>subscriber</code> 订阅，那么它的 <code>didSubscribe</code> 会被多次调用。</p>
<p>如果想要避免这种情况的发生，可以使用 <code>reply</code> / <code>replayLast</code> / <code>replayLazily</code> 方法，它们的作用是保证 <code>signal</code> 只被触发一次，然后把 <code>sendNext:</code> 的 <code>value</code> 给缓存起来，下一次再有新的 <code>subscriber</code> 时，直接发送缓存的 <code>value</code> 。</p>
<p>其内部实现依赖：<code>- (RACMulticastConnection *)multicast:(RACSubject *)subject;</code> 这个方法。</p>
<h3 id="Cell_重用">Cell 重用</h3><p>RAC 给 <code>UITableViewCell</code> 提供了一个方法： <code>rac_prepareForReuseSignal</code> ，它的作用是当 Cell 即将要被重用时，告诉 Cell 。想象 Cell 上有多个 <code>Button</code> ，Cell 在初始化时给每个 Button 都 <code>addTarget:action:forControlEvents</code> ，被重用时需要先移除这些 target ，下面这段代码就可以很方便地解决这个问题：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[[<span class="keyword">self</span><span class="variable">.cancelButton</span></span><br><span class="line">truerac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>]</span><br><span class="line">truetakeUntil:<span class="keyword">self</span><span class="variable">.rac_prepareForReuseSignal</span>]</span><br><span class="line">truesubscribeNext:^(<span class="built_in">UIButton</span> *x) &#123;</span><br><span class="line">true<span class="comment">// do other things</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="Strong_/_Weak_Dance">Strong / Weak Dance</h3><p>因为 RAC 很多操作都是在 <code>Block</code> 中进行的，所以最常见的问题便是「循环引用」，所以需要通过 <code>@weakify</code> 和 <code>@strongify</code> 来消除循环引用。</p>
<p>注意：事实上 <code>RACObserve(TARGET, KEYPATH)</code> 总是会引用 <code>self</code> ，即使 target 不是 self ，所以只要有 RACObserve 的地方都要使用 <code>@weakify</code> / <code>@strongify</code> 。</p>
<h3 id="flattenMap_与_map_的区别">flattenMap 与 map 的区别</h3><ul>
<li><code>flattenMap</code> 中的 block 返回信号。</li>
<li><code>map</code> 中的 block 返回对象。</li>
<li><code>map</code> 的实现是用了 <code>flattenMap</code> 函数来实现的。把 <code>map</code> 的入参闭包，放到了 <code>flattenMap</code> 的返回值中。</li>
<li>开发中，如果信号发出的值不是信号，映射一般使用 <code>map</code> 。</li>
<li>开发中，如果信号发出的值是信号，映射一般使用 <code>flattenMap</code> 。</li>
<li><code>signalOfsignals</code> 用 <code>flattenMap</code> 。</li>
</ul>
<h3 id="冷信号与热信号的区别">冷信号与热信号的区别</h3><ul>
<li>Hot Observable 是主动的，尽管你并没有订阅事件，但是它会时刻推送，就像鼠标移动；而 Cold Observable 是被动的，只有当你订阅的时候，它才会发布消息。</li>
<li>Hot Observable 可以有多个订阅者，是一对多，集合可以与订阅者共享信息；而 Cold Observable 只能一对一，当有不同的订阅者，消息是重新完整发送。</li>
<li><code>Subject</code> 类似「直播」，错过了就不再处理。而 <code>Signal</code> 类似「点播」。</li>
<li><code>RACSubject</code> 及其子类是热信号，<code>RACSignal</code> 排除 <code>RACSubject</code> 类以外的是冷信号。</li>
<li><code>RACSubject</code> 会持有订阅者（因为 <code>RACSubject</code> 是热信号，为了保证未来有事件发送的时候，订阅者可以收到信息，所以需要对订阅者保持状态，做法就是持有订阅者），而 <code>RACSignal</code> 不会持有订阅者。</li>
</ul>
<h3 id="其他">其他</h3><ul>
<li><p>当一个 <code>signal</code> 被一个 <code>subscriber</code> subscribe 后，这个 <code>subscriber</code> 何时会被移除？答案是：当 <code>subscriber</code> 被 <code>sendComplete</code> 或 <code>sendError</code> 时，或者手动调用 <code>[disposable dispose]</code> 。</p>
</li>
<li><p><code>replay</code> 是 <code>multicast</code> 的一个特殊 case 而已。</p>
</li>
<li><p>当 <code>subscriber</code> 被 <code>dispose</code> 后，所有该 <code>subscriber</code> 相关的工作都会被停止或取消，如 http 请求，资源也会被释放。</p>
</li>
<li><p><code>Errors</code> 有优先权，如果有多个 <code>signals</code> 被同时监听，只要其中一个 signal <code>sendError</code>，那么 error 就会立刻被传送给 subscriber ，并导致 signals 终止执行。相当于<code>Exception</code> 。</p>
</li>
<li><p>使用 <code>RACSubject</code> ，如果进行了 <code>map</code> 操作，那么一定要发送完成信号，不然会内存泄漏。</p>
</li>
<li><p>任何的信号转换即是对原有的信号进行订阅从而产生新的信号。</p>
</li>
</ul>
<hr>
<h2 id="系列文章">系列文章</h2><ol>
<li><a href="http://tech.meituan.com/tag/ReactiveCocoa" target="_blank" rel="external">美团点评技术团队</a></li>
<li><a href="http://www.jianshu.com/p/d7d951a99db8" target="_blank" rel="external">一缕殇流化隐半边冰霜</a></li>
<li><a href="http://draveness.me/racsignal/" target="_blank" rel="external">Draveness</a></li>
</ol>
<hr>
<h2 id="参考链接">参考链接</h2><ol>
<li><a href="http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/" target="_blank" rel="external">ReactiveCocoa v2.5 源码解析之架构总览</a></li>
<li><a href="http://limboy.me/tech/2014/06/06/deep-into-reactivecocoa2.html" target="_blank" rel="external">ReactiveCocoa2实战</a></li>
<li><a href="http://limboy.me/tech/2013/12/27/reactivecocoa-2.html" target="_blank" rel="external">说说ReactiveCocoa 2</a></li>
<li><a href="https://github.com/ming1016/study/wiki/iOS%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%BB%A5%E5%8F%8AReactiveCocoa%E7%9A%84%E4%BD%BF%E7%94%A8" target="_blank" rel="external">iOS函数响应式编程以及ReactiveCocoa的使用</a></li>
<li><a href="http://www.jianshu.com/p/87ef6720a096" target="_blank" rel="external">最快让你上手ReactiveCocoa之基础篇</a></li>
<li><a href="http://www.jianshu.com/p/e10e5ca413b7" target="_blank" rel="external">最快让你上手ReactiveCocoa之进阶篇</a></li>
<li><a href="http://blog.devtang.com/2016/01/03/reactive-cocoa-discussion/" target="_blank" rel="external">ReactiveCocoa 讨论会</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><blockquote>
<p>本文仅作为个人对于 <code>ReactiveCocoa</code> 学习与使用的总结，文章绝大部分内容来自网络，详情请见参考链接。</p>
</blockquote>
<p>Last updated on 2017.03.24</p>]]>
    
    </summary>
    
      <category term="FRP" scheme="http://itangqi.me/tags/FRP/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="ReactiveCocoa" scheme="http://itangqi.me/tags/ReactiveCocoa/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 屏幕旋转的那些事（二）]]></title>
    <link href="http://itangqi.me/2017/03/09/handle-orientation-changes-two/"/>
    <id>http://itangqi.me/2017/03/09/handle-orientation-changes-two/</id>
    <published>2017-03-08T16:00:00.000Z</published>
    <updated>2017-03-09T07:37:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在 <a href="http://itangqi.me/2017/03/09/handle-orientation-changes-one/">iOS 屏幕旋转的那些事（一）</a>一文中，整个实践的过程都比较顺利，但直到我遇到了 FLEX……</p>
<a id="more"></a>
<hr>
<h2 id="迷之_FLEX">迷之 FLEX</h2><p>如果你对 FLEX 还不了解，可参见：<a href="https://github.com/Flipboard/FLEX" target="_blank" rel="external">https://github.com/Flipboard/FLEX</a></p>
<p>由于在 iPad 版的某些页面，需要以 <a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/PresentingaViewController.html" target="_blank" rel="external">Modal View</a> 的形式展现，其中又涉及到横竖屏切换时，Modal View 的高度相应改变的问题，所以我需要获取到 Screen Width 与 Screen Height 的值。效果如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/handle-orientation-changes-04.png" alt=""></p>
<p>于是，我在 <code>- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator;</code> 中执行如下代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillTransitionToSize:(<span class="built_in">CGSize</span>)size withTransitionCoordinator:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinator</span>&gt;)coordinator &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillTransitionToSize:size withTransitionCoordinator:coordinator];</span><br><span class="line">    <span class="built_in">CGFloat</span> screenWidth = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> screenHeight = [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你觉得此时 <code>screenWidth</code> 与 <code>screenHeight</code> 的值是屏幕旋转前还是旋转后的呢？</p>
<p>顺便说一句：iOS 7 之前 UIScreen 的 bounds 不会随着方向而变化，但是到了 iOS 8 以后，随着设备方向的旋转，<code>[UIScreen mainScreen].bounds.size.width</code> 和 <code>[UIScreen mainScreen].bounds.size.height</code> 也会相应发生变化。具体请参见: <a href="http://stackoverflow.com/questions/24150359/is-uiscreen-mainscreen-bounds-size-becoming-orientation-dependent-in-ios8" target="_blank" rel="external">Is [UIScreen mainScreen].bounds.size becoming orientation-dependent in iOS8?</a></p>
<p>最终经过测试后的答案是：<strong>要看 FLEX 使用声明语句的位置而定！</strong></p>
<p>FLEX 的使用非常简单，我们来看下 <code>AppDelegate.m</code> 中的 <code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(nullable NSDictionary *)launchOptions;</code> ：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.window</span> = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span>];</span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.window</span> makeKeyAndVisible];</span><br><span class="line"></span><br><span class="line">QTViewController *viewController = [[QTViewController alloc] init];</span><br><span class="line">viewController<span class="variable">.title</span> = <span class="string">@"QTViewController"</span>;</span><br><span class="line"><span class="built_in">UINavigationController</span> *navigationController = [[<span class="built_in">UINavigationController</span> alloc] initWithRootViewController:viewController];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此处及之前开启，则在 - (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator 中使用 [UIScreen mainScreen].bounds.size 获取的为旋转后的值。</span></span><br><span class="line">[[FLEXManager sharedManager] showExplorer];</span><br><span class="line"><span class="comment">// !!!:</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.window</span><span class="variable">.rootViewController</span> = navigationController;</span><br><span class="line"><span class="comment">// 在此处及之后开启，则在 - (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id &lt;UIViewControllerTransitionCoordinator&gt;)coordinator 中使用 [UIScreen mainScreen].bounds.size 获取的为旋转前的值。</span></span><br><span class="line">[[FLEXManager sharedManager] showExplorer];</span><br></pre></td></tr></table></figure>
<p>随后，我又改进了写法，进行进一步测试：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillTransitionToSize:(<span class="built_in">CGSize</span>)size withTransitionCoordinator:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinator</span>&gt;)coordinator &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewWillTransitionToSize:size withTransitionCoordinator:coordinator];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Before: %f"</span>, [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Before: %f"</span>, [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">    </span><br><span class="line">    [coordinator animateAlongsideTransition:^(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinatorContext</span>&gt; context) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"After: %f"</span>, [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.width</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"After: %f"</span>, [<span class="built_in">UIScreen</span> mainScreen]<span class="variable">.bounds</span><span class="variable">.size</span><span class="variable">.height</span>);</span><br><span class="line">    &#125;</span><br><span class="line">                                 completion:^(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinatorContext</span>&gt; context)&#123;</span><br><span class="line">                                     </span><br><span class="line">                                 &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的测试结果为：</p>
<table>
<thead>
<tr>
<th>是否开启 FLEX</th>
<th style="text-align:center">位置</th>
<th style="text-align:center">Before 处的 Size</th>
<th style="text-align:center">After 处的 Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>否</td>
<td style="text-align:center"></td>
<td style="text-align:center">旋转前</td>
<td style="text-align:center">旋转后</td>
</tr>
<tr>
<td>是</td>
<td style="text-align:center">self.window.rootViewController = xxx 之后</td>
<td style="text-align:center">旋转前</td>
<td style="text-align:center">旋转后</td>
</tr>
<tr>
<td>是</td>
<td style="text-align:center">self.window.rootViewController = xxx 之前</td>
<td style="text-align:center"><strong>旋转后</strong></td>
<td style="text-align:center">旋转后</td>
</tr>
</tbody>
</table>
<p>所以，如果你真的需要在屏幕旋转时获取 Screen Size，请将操作放在 <code>After</code> 中，因为此时无论 FLEX 是否开启，也无论声明的位置，其都是获取到屏幕旋转之后的值。或将 FLEX 的使用声明语句放到 <code>self.window.rootViewController = xxx</code> 之后。</p>
<p>虽然已经可以解决问题了，但我仍有疑问，那就是「FLEX 到底做了什么，导致在 <code>self.window.rootViewController = xxx 之前</code> 声明，会改变 Before 处的 Size？」</p>
<p>于是，我们顺着 <code>[[FLEXManager sharedManager] showExplorer];</code> 查看源码中的调用顺序：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedManager</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> FLEXManager *sharedManager = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedManager = [[[<span class="keyword">self</span> class] alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)showExplorer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.explorerWindow</span><span class="variable">.hidden</span> = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (FLEXWindow *)explorerWindow</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="built_in">NSThread</span> isMainThread], <span class="string">@"You must use %@ from the main thread only."</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> class]));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!_explorerWindow) &#123;</span><br><span class="line">        _explorerWindow = [[FLEXWindow alloc] initWithFrame:[[<span class="built_in">UIScreen</span> mainScreen] bounds]];</span><br><span class="line">        _explorerWindow<span class="variable">.eventDelegate</span> = <span class="keyword">self</span>;</span><br><span class="line">        _explorerWindow<span class="variable">.rootViewController</span> = <span class="keyword">self</span><span class="variable">.explorerViewController</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _explorerWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们来看下 <code>FLEXWindow</code> 是如何实现的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">        <span class="comment">// Some apps have windows at UIWindowLevelStatusBar + n.</span></span><br><span class="line">        <span class="comment">// If we make the window level too high, we block out UIAlertViews.</span></span><br><span class="line">        <span class="comment">// There's a balance between staying above the app's windows and staying below alerts.</span></span><br><span class="line">        <span class="comment">// UIWindowLevelStatusBar + 100 seems to hit that balance.</span></span><br><span class="line">        <span class="keyword">self</span><span class="variable">.windowLevel</span> = <span class="built_in">UIWindowLevelStatusBar</span> + <span class="number">100.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> pointInside = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.eventDelegate</span> shouldHandleTouchAtPoint:point]) &#123;</span><br><span class="line">        pointInside = [<span class="keyword">super</span> pointInside:point withEvent:event];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pointInside;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)shouldAffectStatusBarAppearance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> isKeyWindow];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)canBecomeKeyWindow</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.eventDelegate</span> canBecomeKeyWindow];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This adds a method (superclass override) at runtime which gives us the status bar behavior we want.</span></span><br><span class="line">    <span class="comment">// The FLEX window is intended to be an overlay that generally doesn't affect the app underneath.</span></span><br><span class="line">    <span class="comment">// Most of the time, we want the app's main window(s) to be in control of status bar behavior.</span></span><br><span class="line">    <span class="comment">// Done at runtime with an obfuscated selector because it is private API. But you shoudn't ship this to the App Store anyways...</span></span><br><span class="line">    <span class="built_in">NSString</span> *canAffectSelectorString = [@[<span class="string">@"_can"</span>, <span class="string">@"Affect"</span>, <span class="string">@"Status"</span>, <span class="string">@"Bar"</span>, <span class="string">@"Appearance"</span>] componentsJoinedByString:<span class="string">@""</span>];</span><br><span class="line">    SEL canAffectSelector = <span class="built_in">NSSelectorFromString</span>(canAffectSelectorString);</span><br><span class="line">    Method shouldAffectMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(shouldAffectStatusBarAppearance));</span><br><span class="line">    IMP canAffectImplementation = method_getImplementation(shouldAffectMethod);</span><br><span class="line">    class_addMethod(<span class="keyword">self</span>, canAffectSelector, canAffectImplementation, method_getTypeEncoding(shouldAffectMethod));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// One more...</span></span><br><span class="line">    <span class="built_in">NSString</span> *canBecomeKeySelectorString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"_%@"</span>, <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(canBecomeKeyWindow))];</span><br><span class="line">    SEL canBecomeKeySelector = <span class="built_in">NSSelectorFromString</span>(canBecomeKeySelectorString);</span><br><span class="line">    Method canBecomeKeyMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(canBecomeKeyWindow));</span><br><span class="line">    IMP canBecomeKeyImplementation = method_getImplementation(canBecomeKeyMethod);</span><br><span class="line">    class_addMethod(<span class="keyword">self</span>, canBecomeKeySelector, canBecomeKeyImplementation, method_getTypeEncoding(canBecomeKeyMethod));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，也许你需要一点关于 <code>UIWindow</code> 的相关知识。简言之，就是将 <code>FLEXWindow</code> 置于整个 View Hierarchy 的最顶部，如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/handle-orientation-changes-03.png" alt=""><a href="http://www.jianshu.com/p/8bc4c5f4b19f" target="_blank" rel="external">图片来源</a></p>
<p>那 FLEX 又在屏幕旋转时做了哪些操作呢？首先我们需要了解下整体响应旋转变化的事件流程，简单来说如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIScreen</span> -&gt; <span class="built_in">UIWindow</span> -&gt; <span class="built_in">UIViewController</span> -&gt; ChildViewControllers -&gt; View -&gt; Subviews</span><br></pre></td></tr></table></figure>
<p>当发生屏幕旋转事件的时候，<code>UIApplication</code> 对象会将旋转事件传递给 <code>UIWindow</code>，<code>UIWindow</code> 本身并不处理旋转事件，而是将旋转事件传递给它的根控制器，由根控制器决定是否需要旋转及旋转操作。</p>
<p>最后，我们来看下 <code>FLEXExplorerViewController</code> 中关于 <code>Rotation</code> 的逻辑：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - Rotation</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)viewControllerForRotationAndOrientation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIWindow</span> *window = <span class="keyword">self</span><span class="variable">.previousKeyWindow</span> ?: [[<span class="built_in">UIApplication</span> sharedApplication] keyWindow];</span><br><span class="line">    <span class="built_in">UIViewController</span> *viewController = window<span class="variable">.rootViewController</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *viewControllerSelectorString = [@[<span class="string">@"_vie"</span>, <span class="string">@"wContro"</span>, <span class="string">@"llerFor"</span>, <span class="string">@"Supported"</span>, <span class="string">@"Interface"</span>, <span class="string">@"Orientations"</span>] componentsJoinedByString:<span class="string">@""</span>];</span><br><span class="line">    SEL viewControllerSelector = <span class="built_in">NSSelectorFromString</span>(viewControllerSelectorString);</span><br><span class="line">    <span class="keyword">if</span> ([viewController respondsToSelector:viewControllerSelector]) &#123;</span><br><span class="line"><span class="preprocessor">#pragma clang diagnostic push</span></span><br><span class="line"><span class="preprocessor">#pragma clang diagnostic ignored <span class="title">"-Warc-performSelector-leaks"</span></span></span><br><span class="line">        viewController = [viewController performSelector:viewControllerSelector];</span><br><span class="line"><span class="preprocessor">#pragma clang diagnostic pop</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> viewController;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIInterfaceOrientationMask</span>)supportedInterfaceOrientations</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIViewController</span> *viewControllerToAsk = [<span class="keyword">self</span> viewControllerForRotationAndOrientation];</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMask</span> supportedOrientations = [FLEXUtility infoPlistSupportedInterfaceOrientationsMask];</span><br><span class="line">    <span class="keyword">if</span> (viewControllerToAsk &amp;&amp; viewControllerToAsk != <span class="keyword">self</span>) &#123;</span><br><span class="line">        supportedOrientations = [viewControllerToAsk supportedInterfaceOrientations];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The UIViewController docs state that this method must not return zero.</span></span><br><span class="line">    <span class="comment">// If we weren't able to get a valid value for the supported interface orientations, default to all supported.</span></span><br><span class="line">    <span class="keyword">if</span> (supportedOrientations == <span class="number">0</span>) &#123;</span><br><span class="line">        supportedOrientations = <span class="built_in">UIInterfaceOrientationMaskAll</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> supportedOrientations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)shouldAutorotate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIViewController</span> *viewControllerToAsk = [<span class="keyword">self</span> viewControllerForRotationAndOrientation];</span><br><span class="line">    <span class="built_in">BOOL</span> shouldAutorotate = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (viewControllerToAsk &amp;&amp; viewControllerToAsk != <span class="keyword">self</span>) &#123;</span><br><span class="line">        shouldAutorotate = [viewControllerToAsk shouldAutorotate];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shouldAutorotate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willRotateToInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)toInterfaceOrientation duration:(<span class="built_in">NSTimeInterval</span>)duration</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *outlineView <span class="keyword">in</span> [<span class="keyword">self</span><span class="variable">.outlineViewsForVisibleViews</span> allValues]) &#123;</span><br><span class="line">        outlineView<span class="variable">.hidden</span> = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.selectedViewOverlay</span><span class="variable">.hidden</span> = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didRotateFromInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)fromInterfaceOrientation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *view <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.viewsAtTapPoint</span>) &#123;</span><br><span class="line">        <span class="built_in">NSValue</span> *key = [<span class="built_in">NSValue</span> valueWithNonretainedObject:view];</span><br><span class="line">        <span class="built_in">UIView</span> *outlineView = <span class="keyword">self</span><span class="variable">.outlineViewsForVisibleViews</span>[key];</span><br><span class="line">        outlineView<span class="variable">.frame</span> = [<span class="keyword">self</span> frameInLocalCoordinatesForView:view];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.currentMode</span> == FLEXExplorerModeSelect) &#123;</span><br><span class="line">            outlineView<span class="variable">.hidden</span> = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.selectedView</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.selectedViewOverlay</span><span class="variable">.frame</span> = [<span class="keyword">self</span> frameInLocalCoordinatesForView:<span class="keyword">self</span><span class="variable">.selectedView</span>];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.selectedViewOverlay</span><span class="variable">.hidden</span> = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，到目前为止，仍然不能解决我的疑问（瞬间感觉自己弱爆了……）如果你正巧知道原因，欢迎给我留言：）</p>
<p>如果你想对 FLEX 有更深入的了解，可参见系列文章：<a href="http://www.jianshu.com/p/8bc4c5f4b19f" target="_blank" rel="external">FLEX 2.0源码分析（一）</a></p>
<hr>
<h2 id="One_More_Thing">One More Thing</h2><p>好啦，对于已经阅读到这部分的朋友，作为回报，送上两个 iPad 适配相关的 Tips：</p>
<ol>
<li><a href="http://stackoverflow.com/questions/14469251/uicollectionviewflowlayout-size-warning-when-rotating-device-to-landscape" target="_blank" rel="external">UICollectionViewFlowLayout Size Warning When Rotating Device to Landscape</a></li>
<li><a href="http://stackoverflow.com/questions/16518175/custom-size-for-modal-view-loaded-with-form-sheet-presentation" target="_blank" rel="external">Custom size for Modal View loaded with Form Sheet presentation</a></li>
</ol>
<hr>
<h2 id="参考&amp;推荐">参考&amp;推荐</h2><ol>
<li><a href="http://stackoverflow.com/questions/26069874/what-is-the-right-way-to-handle-orientation-changes-in-ios-8" target="_blank" rel="external">What is the “right” way to handle orientation changes in iOS 8?</a></li>
<li><a href="http://www.jianshu.com/p/db03da61cd2c" target="_blank" rel="external">详解iOS开发中处理屏幕旋转的几种方法</a></li>
<li><a href="http://www.jianshu.com/p/8bc4c5f4b19f" target="_blank" rel="external">FLEX 2.0源码分析（一）</a></li>
<li><a href="https://satanwoo.github.io/2016/09/17/uiwindow-iOS/" target="_blank" rel="external">浅谈iOS的多Window处理</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>在 <a href="http://itangqi.me/2017/03/09/handle-orientation-changes-one/">iOS 屏幕旋转的那些事（一）</a>一文中，整个实践的过程都比较顺利，但直到我遇到了 FLEX……</p>]]>
    
    </summary>
    
      <category term="FLEX" scheme="http://itangqi.me/tags/FLEX/"/>
    
      <category term="Orientation" scheme="http://itangqi.me/tags/Orientation/"/>
    
      <category term="Rotation" scheme="http://itangqi.me/tags/Rotation/"/>
    
      <category term="UIDevice" scheme="http://itangqi.me/tags/UIDevice/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 屏幕旋转的那些事（一）]]></title>
    <link href="http://itangqi.me/2017/03/08/handle-orientation-changes-one/"/>
    <id>http://itangqi.me/2017/03/08/handle-orientation-changes-one/</id>
    <published>2017-03-07T16:00:00.000Z</published>
    <updated>2017-03-09T05:07:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文将讨论的话题是：iOS 屏幕旋转的那些事，文中示例 Demo 请参见：<a href="https://github.com/tangqi92/QTHandleOrientationChanges.git" target="_blank" rel="external">https://github.com/tangqi92/QTHandleOrientationChanges.git</a>。</p>
<a id="more"></a>
<hr>
<h2 id="需求">需求</h2><p>在即将推出的<strong>花瓣 4.0</strong> 版本中我们增加了对 iPad 横屏的支持，因为在实践的过程中踩了些坑，所以在此作下总结，同时也希望能帮助到有需要的朋友们。</p>
<p>由于历史原因，项目是手撕 Frame 而不是 Storyboard 进行布局，也并没有使用 Auto Layout。</p>
<p>又由于历史原因，项目设置为 「Universal」以支持 iPad。虽然支持 iPad，不过仅支持竖屏，其实也就是个放大的 iPhone 版，体验效果不佳。这次花瓣 4.0 的改版，iPad 横屏的支持便是一重点改进点，效果可见下图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/handle-orientation-changes-01.png" alt=""></p>
<p>如果你是使用 Storyboard 进行布局，当然可以通过 <a href="Size-Class-Specific Layout">Size Classes</a> 来解决多尺寸设备适配的问题。不过前面已经提到，本人喜欢手写布局，但依然可以实现效果。</p>
<p>PS：如果你对「布局实现方式的选择」或「Auto Layout」等概念仍有疑问，你可阅读下面参考文章，本文就不作过多详述：</p>
<ol>
<li><a href="https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/" target="_blank" rel="external">Understanding Auto Layout</a></li>
<li><a href="https://blog.callmewhy.com/2016/08/24/autolayout-design-aesthetic/" target="_blank" rel="external">Auto Layout 设计美学</a></li>
<li><a href="http://hjcapple.github.io/2016/04/21/ios-make-ui.html" target="_blank" rel="external">iOS 开发中，搭建界面的一些争论</a></li>
<li><a href="https://halfrost.com/wwdc2016_xcode8autolayout_features/" target="_blank" rel="external">WWDC2016 Session笔记 - Xcode 8 Auto Layout新特性</a></li>
</ol>
<hr>
<h2 id="实现">实现</h2><p>因为当屏幕旋转的时候，Controller 的 View 的 Size 会发生改变，就会调用 <code>viewWillLayoutSubviews()</code> 等方法重新布局，如果你是在这些方法里面布局的话，那么界面中的内容会重新布局，更进一步，如果你是在这些方法里面使用 Auto Layout 布局，那么就不需要再做额外的处理了。</p>
<p>但是，如果你是在 <code>viewDidLoad()</code> 等里面布局，那么界面中的内容将不会变化，你可能就需要监听屏幕旋转的地方重新布局，处理好旋转动画等。</p>
<p>于是，实现的关键便是处理屏幕的旋转事件，手动进行布局修改，以适配横竖屏不同效果的布局。那，我们又是如何知道设备的方向发生了改变的呢？不妨看看下面这些方法吧：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UIInterfaceOrientation</span> interfaceOrientation <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0,<span class="number">8</span>_0) __TVOS_PROHIBITED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notifies when rotation begins, reaches halfway point and ends.</span></span><br><span class="line">- (<span class="keyword">void</span>)willRotateToInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)toInterfaceOrientation duration:(<span class="built_in">NSTimeInterval</span>)duration <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0,<span class="number">8</span>_0, <span class="string">"Implement viewWillTransitionToSize:withTransitionCoordinator: instead"</span>) __TVOS_PROHIBITED;</span><br><span class="line">- (<span class="keyword">void</span>)didRotateFromInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)fromInterfaceOrientation <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0,<span class="number">8</span>_0) __TVOS_PROHIBITED;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willAnimateRotationToInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)toInterfaceOrientation duration:(<span class="built_in">NSTimeInterval</span>)duration <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">3</span>_0,<span class="number">8</span>_0, <span class="string">"Implement viewWillTransitionToSize:withTransitionCoordinator: instead"</span>) __TVOS_PROHIBITED;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)willAnimateFirstHalfOfRotationToInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)toInterfaceOrientation duration:(<span class="built_in">NSTimeInterval</span>)duration <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0, <span class="number">5</span>_0) __TVOS_PROHIBITED;</span><br><span class="line">- (<span class="keyword">void</span>)didAnimateFirstHalfOfRotationToInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)toInterfaceOrientation <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0, <span class="number">5</span>_0) __TVOS_PROHIBITED; <span class="comment">// The rotating header and footer views are offscreen.</span></span><br><span class="line">- (<span class="keyword">void</span>)willAnimateSecondHalfOfRotationFromInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)fromInterfaceOrientation duration:(<span class="built_in">NSTimeInterval</span>)duration <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">2</span>_0, <span class="number">5</span>_0) __TVOS_PROHIBITED; <span class="comment">// A this point, our view orientation is set to the new orientation.</span></span><br></pre></td></tr></table></figure>
<p>别高兴的太早，网上大部分文章（至少中文文章）都会告诉你使用上面的这些方法，而然，Apple 早已在 iOS 8.0 中便将这些关于 Controller 的 Rotation APIs 进行废弃，取而代之的是推荐使用：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillTransitionToSize:(<span class="built_in">CGSize</span>)size withTransitionCoordinator:(<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerTransitionCoordinator</span>&gt;)coordinator <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">8</span>_0);</span><br></pre></td></tr></table></figure>
<p>即当 Controller 的 View 的 Size 发生改变时便会触发该方法，下面来看下官方文档的解释：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/handle-orientation-changes-02.png" alt=""></p>
<p>其中 <strong>Size</strong> 为 View 改变（旋转）后的 Size，而 <strong>coordinator</strong> 则可用来处理转换动画。例如，你可以在该方法中改变子 View 的位置或大小：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillTransitionToSize:(<span class="built_in">CGSize</span>)size withTransitionCoordinator:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinator</span>&gt;)coordinator &#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">super</span> viewWillTransitionToSize:size withTransitionCoordinator:coordinator];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Code here will execute before the rotation begins.</span></span><br><span class="line">    <span class="comment">// Equivalent to placing it in the deprecated method -[willRotateToInterfaceOrientation:duration:].</span></span><br><span class="line">    [coordinator animateAlongsideTransition:^(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinatorContext</span>&gt; context) &#123;</span><br><span class="line">        <span class="comment">// Place code here to perform animations during the rotation.</span></span><br><span class="line">        <span class="comment">// You can pass nil for this closure if not necessary.</span></span><br><span class="line">        <span class="comment">// Reorganize views, or move child view controllers.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">UIInterfaceOrientationIsLandscape</span>([<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.statusBarOrientation</span>)) &#123;</span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.redView</span> mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">                make<span class="variable">.size</span><span class="variable">.mas_equalTo</span>(<span class="built_in">CGSizeMake</span>(<span class="number">200</span>, <span class="number">200</span>));</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">UIInterfaceOrientationIsPortrait</span>([<span class="built_in">UIApplication</span> sharedApplication]<span class="variable">.statusBarOrientation</span>)) &#123;</span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.redView</span> mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">                make<span class="variable">.size</span><span class="variable">.mas_equalTo</span>(<span class="built_in">CGSizeMake</span>(<span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                                 completion:^(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerTransitionCoordinatorContext</span>&gt; context)&#123;</span><br><span class="line">                                     <span class="comment">// Code here will execute after the rotation has finished.</span></span><br><span class="line">                                     <span class="comment">// Equivalent to placing it in the deprecated method -[didRotateFromInterfaceOrientation:].</span></span><br><span class="line">                                     <span class="comment">// Do any cleanup, if necessary.</span></span><br><span class="line"></span><br><span class="line">                                 &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释非常简单，就不做翻译了，其中，你可以通过 <code>[UIApplication sharedApplication].statusBarOrientation)</code> 来获取当前设备的方向，便于你之后的操作。</p>
<p>嗯，这篇文章很水，而我会在下篇文章：<a href="http://itangqi.me/2017/03/09/handle-orientation-changes-two/">iOS 屏幕旋转的那些事（二）</a> 中具体介绍我遇到的一个坑。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文将讨论的话题是：iOS 屏幕旋转的那些事，文中示例 Demo 请参见：<a href="https://github.com/tangqi92/QTHandleOrientationChanges.git">https://github.com/tangqi92/QTHandleOrientationChanges.git</a>。</p>]]>
    
    </summary>
    
      <category term="FLEX" scheme="http://itangqi.me/tags/FLEX/"/>
    
      <category term="Orientation" scheme="http://itangqi.me/tags/Orientation/"/>
    
      <category term="Rotation" scheme="http://itangqi.me/tags/Rotation/"/>
    
      <category term="UIDevice" scheme="http://itangqi.me/tags/UIDevice/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于 UITableView's Separator Inset 的探究]]></title>
    <link href="http://itangqi.me/2017/02/28/uitableview-cell-separatorinset/"/>
    <id>http://itangqi.me/2017/02/28/uitableview-cell-separatorinset/</id>
    <published>2017-02-27T16:00:00.000Z</published>
    <updated>2017-02-28T11:36:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这是一次关于 UITableView’s Separator Inset 的探究，请结合 Demo：<a href="https://github.com/tangqi92/QTSeparatorInsetTableView.git" target="_blank" rel="external">https://github.com/tangqi92/QTSeparatorInsetTableView.git</a> 阅读本文。</p>
<a id="more"></a>
<hr>
<h2 id="需求">需求</h2><p>我相信，在平日的开发中，<code>UITableView</code> 绝对算得上使用最平凡的 <code>UIKit</code> 控件之一，并且必定会涉及到 <code>UITableView/UITableViewCell</code> 分割线的设置。</p>
<p>下面，我们就来聊一聊，关于 <code>UITableView/UITableViewCell</code> 分割线的相关内容：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/uitableview-cell-separatorinset-01.png" alt=""></p>
<p>如上图所示，按设计师的要求，在 <code>UITableView</code> 中 <code>Cell</code> 的分割线需要距离左右边距各 16pt。</p>
<p>卧槽，这不很简单嘛！</p>
<p>是吗？</p>
<hr>
<h2 id="边距为_0">边距为 0</h2><p>对于如此简单的页面，自定义 Cell 并添加分割线的方式虽然可行，但未免有些小题大做了。所以，在这里我直接使用系统自带的 <code>UITableViewCell</code> 来实现。</p>
<p>天真的我，想都没想，直接设置 <code>self.tableView.separatorInset = UIEdgeInsetsMake(0, 16, 0, 16);</code>，然后分别测试了 iOS 8.x、iOS 9.x、iOS 10.x，结果显示效果一致，完美！</p>
<p>但出于验证自己答案和寻找更多实现方式的目的，我决定看看大家都是如何实现的，于是 Google 一番后，找到了：<a href="http://stackoverflow.com/questions/25770119/ios-8-uitableview-separator-inset-0-not-working" target="_blank" rel="external">iOS 8 UITableView separator inset 0 not working</a> 。该问题的描述是「为何在 iOS 8 中设置 UITableView 分割线边距为 0 不起作用」，我想这不简单嘛，于是 <code>self.tableView.separatorInset = UIEdgeInsetsZero;</code> ，然后做了测试，显示效果见下表：</p>
<table>
<thead>
<tr>
<th>系统版本</th>
<th style="text-align:center">测试用例</th>
<th style="text-align:center">实现效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>iOS 8.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsZero;</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>iOS 9.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsZero;</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>iOS 10.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsZero;</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<p>WTF（黑人问号脸？？？），这是什么情况？看来我真是「Too Young, Too Naive」…于是我又做了如下测试：</p>
<table>
<thead>
<tr>
<th>系统版本</th>
<th style="text-align:center">测试用例</th>
<th style="text-align:center">实现效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>iOS 8.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsMake(0, 5, 0, 5);</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>iOS 9.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsMake(0, 5, 0, 5);</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td>iOS 10.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsMake(0, 5, 0, 5);</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>系统版本</th>
<th style="text-align:center">测试用例</th>
<th style="text-align:center">实现效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>iOS 8.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsMake(0, 25, 0, 25);</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td>iOS 9.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsMake(0, 25, 0, 25);</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td>iOS 10.x</td>
<td style="text-align:center">self.tableView.separatorInset = UIEdgeInsetsMake(0, 25, 0, 25);</td>
<td style="text-align:center">YES</td>
</tr>
</tbody>
</table>
<p>一定是姿势不对，嗯，一定的！</p>
<hr>
<h2 id="历史回顾">历史回顾</h2><p>为了探究其缘由，在经过一番查阅资料后，关于「分割线边距」（Separator Inset），我们可以得到如下总结：</p>
<h3 id="Prior_to_iOS_7-x">Prior to iOS 7.x</h3><p>分割线默认边距为 <code>0</code>。</p>
<h3 id="iOS_7-x">iOS 7.x</h3><p>新增 <a href="https://developer.apple.com/reference/uikit/uitableview/1614851-separatorinset?language=objc" target="_blank" rel="external">separatorInset</a> 属性，默认边距为 <code>15</code>，此时直接设置 <code>separatorInset</code> 值为 <code>UIEdgeInsetsZero</code> 即可。</p>
<p>我们再来看下文档中关于 <code>separatorInset</code> 的解释：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/uitableview-cell-separatorinset-05.png" alt=""></p>
<h3 id="iOS_8-x">iOS 8.x</h3><p>新增 <a href="https://developer.apple.com/reference/uikit/uiview/1622566-layoutmargins?language=objc" target="_blank" rel="external">layoutMargins</a> 属性，如直接设置 <code>separatorInset</code> 为 <code>UIEdgeInsetsZero</code> 无效。</p>
<p>我们再来看下文档中关于 <code>layoutMargins</code> 的解释：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/uitableview-cell-separatorinset-06.png" alt=""></p>
<p>中间又涉及到 <a href="https://developer.apple.com/reference/uikit/uiview/1622653-preservessuperviewlayoutmargins?language=objc" target="_blank" rel="external">preservesSuperviewLayoutMargins</a> 属性，其解释：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/uitableview-cell-separatorinset-08.png" alt=""></p>
<p>简单来讲就是：<code>layoutMargins</code> 是 View 的 <code>bounds</code> 的边距，默认为 <code>8pt</code>。</p>
<p>如果 <code>preservesSuperviewLayoutMargins</code> 属性设置为 <code>YES</code>，那么父控件的 <code>layoutMargins</code> 边距就将会影响其子控件。</p>
<h3 id="iOS_9-x">iOS 9.x</h3><p>新增 <a href="https://developer.apple.com/reference/uikit/uitableview/1614849-celllayoutmarginsfollowreadablew?language=objc" target="_blank" rel="external">cellLayoutMarginsFollowReadableWidth</a> 属性，其解释：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A Boolean value that indicates whether the cell margins are derived from the width of the readable content guide.</span><br></pre></td></tr></table></figure>
<p>该属性的作用：当设置为 <code>YES</code> 时，在 iPad 上，当 TableView 横屏时，会根据内容留有空白，如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/uitableview-cell-separatorinset-09.png" alt=""></p>
<h3 id="iOS_10-x">iOS 10.x</h3><p>直接设置 tableview 的 <code>separatorInset</code> 即可。</p>
<hr>
<h2 id="实现">实现</h2><p>所以，为了能完美实现「分割线边距可控」的需求，我们需要如下操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView willDisplayCell:(<span class="built_in">UITableViewCell</span> *)cell forRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">// If cell margins are derived from the width of the readableContentGuide.</span></span><br><span class="line">    <span class="comment">// NS_AVAILABLE_IOS(9_0)，需进行判断</span></span><br><span class="line">    <span class="comment">// 设置为 NO，防止在横屏时留白</span></span><br><span class="line">    <span class="keyword">if</span> ([tableView respondsToSelector:<span class="keyword">@selector</span>(setCellLayoutMarginsFollowReadableWidth:)]) &#123;</span><br><span class="line">        tableView<span class="variable">.cellLayoutMarginsFollowReadableWidth</span> = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent the cell from inheriting the Table View's margin settings.</span></span><br><span class="line">    <span class="comment">// NS_AVAILABLE_IOS(8_0)，需进行判断</span></span><br><span class="line">    <span class="comment">// 阻止 Cell 继承来自 TableView 相关的设置（LayoutMargins or SeparatorInset），设置为 NO 后，Cell 可以独立地设置其自身的分割线边距而不依赖于 TableView</span></span><br><span class="line">    <span class="keyword">if</span> ([cell respondsToSelector:<span class="keyword">@selector</span>(setPreservesSuperviewLayoutMargins:)]) &#123;</span><br><span class="line">        [cell setPreservesSuperviewLayoutMargins:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove seperator inset.</span></span><br><span class="line">    <span class="comment">// NS_AVAILABLE_IOS(8_0)，需进行判断</span></span><br><span class="line">    <span class="comment">// 移除 Cell 的 layoutMargins（即设置为 0）</span></span><br><span class="line">    <span class="keyword">if</span> ([cell respondsToSelector:<span class="keyword">@selector</span>(setLayoutMargins:)]) &#123;</span><br><span class="line">        [cell setLayoutMargins:<span class="built_in">UIEdgeInsetsZero</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Explictly set your cell's layout margins.</span></span><br><span class="line">    <span class="comment">// NS_AVAILABLE_IOS(7_0)，需进行判断</span></span><br><span class="line">    <span class="comment">// 根据需求设置相应的边距</span></span><br><span class="line">    <span class="keyword">if</span> ([cell respondsToSelector:<span class="keyword">@selector</span>(setSeparatorInset:)]) &#123;</span><br><span class="line">        [cell setSeparatorInset:<span class="built_in">UIEdgeInsetsMake</span>(<span class="number">0</span>, <span class="number">16</span>, <span class="number">0</span>, <span class="number">16</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好啦，以上就是由一个简单的需求「设置分割线边距」引发的一系列探究，希望对你有所帮助。</p>
<hr>
<h2 id="疑问">疑问</h2><p>对于 iOS 10.x 直接设置 <code>self.tableView.separatorInset = UIEdgeInsetsMake(0, xx, 0, xx);</code> 便能实现效果，我到目前仍没有找到明确的答案，如果你正巧看到这，又正巧知道原因，希望能告知我一下，先在此表示感谢：）</p>
<hr>
<h2 id="参考">参考</h2><ol>
<li><a href="http://stackoverflow.com/questions/25770119/ios-8-uitableview-separator-inset-0-not-working" target="_blank" rel="external">iOS 8 UITableView separator inset 0 not working</a></li>
<li><a href="http://johnszumski.com/blog/hiding-table-separators-on-a-cell-by-cell-basis" target="_blank" rel="external">Hiding Table Separators on a Cell-by-Cell Basis</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>这是一次关于 UITableView’s Separator Inset 的探究，请结合 Demo：<a href="https://github.com/tangqi92/QTSeparatorInsetTableView.git">https://github.com/tangqi92/QTSeparatorInsetTableView.git</a> 阅读本文。</p>]]>
    
    </summary>
    
      <category term="Inset" scheme="http://itangqi.me/tags/Inset/"/>
    
      <category term="Margin" scheme="http://itangqi.me/tags/Margin/"/>
    
      <category term="Separator" scheme="http://itangqi.me/tags/Separator/"/>
    
      <category term="UITableView" scheme="http://itangqi.me/tags/UITableView/"/>
    
      <category term="UITableViewCell" scheme="http://itangqi.me/tags/UITableViewCell/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UITableViewCell 中嵌套 UICollectionView 的实现]]></title>
    <link href="http://itangqi.me/2017/02/21/putting-a-uicollectionview-in-a-uitableviewcell/"/>
    <id>http://itangqi.me/2017/02/21/putting-a-uicollectionview-in-a-uitableviewcell/</id>
    <published>2017-02-20T16:00:00.000Z</published>
    <updated>2017-02-21T07:09:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>自从去年来到花瓣实习以后，因为时间与精力（其实就是懒）的原因，这半年多没有写过一篇技术相关的文章。不过，随着项目的逐渐进展，我想，有必要对一些知识点进行总结与回顾了。与此同时，如果能帮助到大家就最好不过了：）</p>
<a id="more"></a>
<p>本文中的参考 Demo：<a href="https://github.com/tangqi92/QTTableCollectionView" target="_blank" rel="external">https://github.com/tangqi92/QTTableCollectionView</a>，请结合 Demo 阅读本文。</p>
<hr>
<h2 id="需求">需求</h2><p><img src="http://7xikfc.com1.z0.glb.clouddn.com/putting-a-uicollectionview-in-a-uitableviewcell-01.png" alt=""></p>
<p>这是 <strong>花瓣 4.0</strong> 中「个人主页」里的「关注」页面，我想，你一定会非常熟悉这样的界面布局：竖向与横向滚动列表的结合，我们熟悉的 <strong>App Store</strong>，其首页便是代表之一。</p>
<hr>
<h2 id="分析">分析</h2><p>本文的实现方式是：UITableView + UICollectionView 的结合（其实后来发现，仅仅使用 UICollectionView 就可以实现，不管啦~）。</p>
<p>于是，我们将页面简化，可以得到下图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/putting-a-uicollectionview-in-a-uitableviewcell-03.png" alt=""></p>
<p>现在，我们来分析下 Layout 结构：最外层当然是 UITableView，然后其中每个 UITableViewCell 中包含着一个 UICollectionView，而其中的 UICollectionViewCell 有 3 种不同的样式（既红、绿、蓝三种样式）。于是，我们又得到了下图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/putting-a-uicollectionview-in-a-uitableviewcell-04.png" alt=""></p>
<p>没错，我们将 UITableView 与 UICollectionView 的 Delegate 与 DataSource 都由 TableViewController 处理，是希望 UITableViewCell 中不要出现不必要的代码。</p>
<hr>
<h2 id="实现">实现</h2><p>下面，我们以 <a href="https://github.com/tangqi92/QTTableCollectionView" target="_blank" rel="external">https://github.com/tangqi92/QTTableCollectionView</a> 为例进行讲解。首先，来看下项目的目录结构：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/putting-a-uicollectionview-in-a-uitableviewcell-06.png" alt=""></p>
<h3 id="Model">Model</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QTExploreModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 请根据自身需求，定义相关 Model 类与其属性。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><code>QTExploreModel</code> \ <code>QTBoardModel</code> \ <code>QTUserModel</code> 3 个 Model 类，在这里仅是象征性作用，请根据实际项目需求定义。</p>
<h3 id="View">View</h3><h4 id="自定义_UICollectionViewCell">自定义 UICollectionViewCell</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QTExploresCollectionViewCell</span> : <span class="title">UICollectionViewCell</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) QTExploreModel *exploreModel;</span><br><span class="line"><span class="comment">/// 该方仅法用于测试。</span></span><br><span class="line">- (<span class="keyword">void</span>)setupModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QTExploresCollectionViewCell</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 请根据自身需求，自定义 CollectionViewCell。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *coverView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QTExploresCollectionViewCell</span></span></span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> initViews];</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.layer</span><span class="variable">.cornerRadius</span> = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.layer</span><span class="variable">.masksToBounds</span> = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)initViews &#123;</span><br><span class="line">    _coverView = [<span class="built_in">UIView</span> new];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.contentView</span> addSubview:_coverView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">    [_coverView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make<span class="variable">.edges</span><span class="variable">.equalTo</span>(<span class="keyword">self</span><span class="variable">.contentView</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setExploreModel:(QTExploreModel *)exploreModel &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 数据填充</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupModel &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.coverView</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><code>QTExploresCollectionViewCell</code> \ <code>QTBoardsCollectionViewCell</code> \ <code>QTUsersCollectionViewCell</code> 3 个自定义 UICollectionViewCell，也请根据实际项目需求自行定义。</p>
<h4 id="自定义_UICollectionView">自定义 UICollectionView</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 3 种类型的 Cell。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, CollectionViewCellType) &#123;</span><br><span class="line">    CellTypeExplores = <span class="number">0</span>,</span><br><span class="line">    CellTypeBoards,</span><br><span class="line">    CellTypeUsers</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QTCollectionView</span> : <span class="title">UICollectionView</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// indexPath 用于查询相应的 Model，并填充至 Cell。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSIndexPath</span> *indexPath;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) CollectionViewCellType collectionViewCellType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><code>indexPath</code> 用于记录 UICollectionView 所处的位置，而 <code>CollectionViewCellType</code> 用于区分不同类型的 UICollectionViewCell（当然，你可以直接使用 indexPath.section（0、1、2） 用以区别，只是我个人比较倾向使用枚举而已）。</p>
<h4 id="自定义_UITableViewCell">自定义 UITableViewCell</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> ExploreCollectionViewCellID = <span class="string">@"ExploreCollectionViewCellID"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> BoardCollectionViewCellID = <span class="string">@"BoardCollectionViewCellID"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> UserCollectionViewCellID = <span class="string">@"UserCollectionViewCellID"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">QTTableViewCell</span> : <span class="title">UITableViewCell</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// UITableViewCell 中嵌套 CollectionView。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) QTCollectionView *collectionView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 设置 CollectionView 的 DataSource 与 Delegate。</span></span><br><span class="line">- (<span class="keyword">void</span>)setCollectionViewDataSourceDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">UICollectionViewDataSource</span>, <span class="built_in">UICollectionViewDelegate</span>, <span class="built_in">UICollectionViewDelegateFlowLayout</span>&gt;)dataSourceDelegate indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>本文前面已经提过，该界面实现的关键便在于 <code>UITableViewCell</code> 中嵌套 <code>UICollectionView</code>，并将 <code>UICollectionView</code> 的 Delegate 与 DataSource 交由 <code>UITableViewController</code> 处理。在这里，我们使用 <code>- (void)setCollectionViewDataSourceDelegate:indexPath:</code> 处理。下面，我们再来看下 <code>QTTableViewCell</code> 的具体实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QTTableViewCell</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithStyle:(<span class="built_in">UITableViewCellStyle</span>)style reuseIdentifier:(<span class="built_in">NSString</span> *)reuseIdentifier &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">self</span> = [<span class="keyword">super</span> initWithStyle:style reuseIdentifier:reuseIdentifier])) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 UICollectionViewFlowLayout 进行布局。</span></span><br><span class="line">    <span class="comment">// 注册 UICollectionViewCell。</span></span><br><span class="line">    <span class="comment">// 其他初始化操作。</span></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make<span class="variable">.edges</span><span class="variable">.equalTo</span>(<span class="keyword">self</span><span class="variable">.contentView</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCollectionViewDataSourceDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">UICollectionViewDataSource</span>, <span class="built_in">UICollectionViewDelegate</span>&gt;)dataSourceDelegate indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.dataSource</span> = dataSourceDelegate;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.delegate</span> = dataSourceDelegate;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.indexPath</span> = indexPath;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> setContentOffset:<span class="keyword">self</span><span class="variable">.collectionView</span><span class="variable">.contentOffset</span> animated:<span class="literal">NO</span>];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.collectionView</span> reloadData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="Controller">Controller</h3><h4 id="UITableViewController_的实现">UITableViewController 的实现</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView willDisplayCell:(QTTableViewCell *)cell forRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">// 为 TableViewCell 中的 CollectionView 设置不同的 collectionViewCellType 用以区别，此处一共 3 种样式。</span></span><br><span class="line">    <span class="keyword">if</span> (indexPath<span class="variable">.section</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        cell<span class="variable">.collectionView</span><span class="variable">.collectionViewCellType</span> = CellTypeExplores;</span><br><span class="line">        <span class="built_in">NSInteger</span> index = cell<span class="variable">.collectionView</span><span class="variable">.indexPath</span><span class="variable">.row</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> horizontalOffset = [<span class="keyword">self</span><span class="variable">.contentOffsetDictionaryOfExplores</span>[[@(index) stringValue]] floatValue];</span><br><span class="line">        <span class="comment">// 设置 CollectionView 的 ContentOffset，在'- (void)scrollViewDidScroll:(UIScrollView *)scrollView;' 中存储的。</span></span><br><span class="line">        [cell<span class="variable">.collectionView</span> setContentOffset:<span class="built_in">CGPointMake</span>(horizontalOffset, <span class="number">0</span>)];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (indexPath<span class="variable">.section</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        cell<span class="variable">.collectionView</span><span class="variable">.collectionViewCellType</span> = CellTypeBoards;</span><br><span class="line">        <span class="built_in">NSInteger</span> index = cell<span class="variable">.collectionView</span><span class="variable">.indexPath</span><span class="variable">.row</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> horizontalOffset = [<span class="keyword">self</span><span class="variable">.contentOffsetDictionaryOfBoards</span>[[@(index) stringValue]] floatValue];</span><br><span class="line">        <span class="comment">// 设置 CollectionView 的 ContentOffset。</span></span><br><span class="line">        [cell<span class="variable">.collectionView</span> setContentOffset:<span class="built_in">CGPointMake</span>(horizontalOffset, <span class="number">0</span>)];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (indexPath<span class="variable">.section</span> == <span class="number">2</span>) &#123;</span><br><span class="line">        cell<span class="variable">.collectionView</span><span class="variable">.collectionViewCellType</span> = CellTypeUsers;</span><br><span class="line">        <span class="built_in">NSInteger</span> index = cell<span class="variable">.collectionView</span><span class="variable">.indexPath</span><span class="variable">.row</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> horizontalOffset = [<span class="keyword">self</span><span class="variable">.contentOffsetDictionaryOfUsers</span>[[@(index) stringValue]] floatValue];</span><br><span class="line">        <span class="comment">// 设置 CollectionView 的 ContentOffset。</span></span><br><span class="line">        [cell<span class="variable">.collectionView</span> setContentOffset:<span class="built_in">CGPointMake</span>(horizontalOffset, <span class="number">0</span>)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !!!: 设置 CollectionView 的 DataSource 与 Delegate 及所处的 indexPath。</span></span><br><span class="line">    [cell setCollectionViewDataSourceDelegate:<span class="keyword">self</span> indexPath:indexPath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住，在 UITableViewCell 中的 CollectionView 是在 Cell 之后初始化的，也就是在初始化这个 Cell 的之后要立即设置这个 Cell 中 CollectionView 的数据源跟代理。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(QTCollectionView *)collectionView cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="built_in">UICollectionViewCell</span> *cell = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (collectionView<span class="variable">.collectionViewCellType</span> == CellTypeExplores) &#123;</span><br><span class="line">        cell = [collectionView dequeueReusableCellWithReuseIdentifier:ExploreCollectionViewCellID forIndexPath:indexPath];</span><br><span class="line">        <span class="keyword">if</span> ([cell isKindOfClass:[QTExploresCollectionViewCell class]]) &#123;</span><br><span class="line">            QTExploresCollectionViewCell *cellExplore = (QTExploresCollectionViewCell *) cell;</span><br><span class="line">            [cellExplore setupModel];</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> 获取到相应的 Model 后进行赋值操作</span></span><br><span class="line">            <span class="comment">//            if (self.dataSourceExplores.count &gt; 0) &#123;</span></span><br><span class="line">            <span class="comment">//                cellExplore.exploreModel = self.dataSourceExplores[indexPath.row];</span></span><br><span class="line">            <span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collectionView<span class="variable">.collectionViewCellType</span> == CellTypeBoards) &#123;</span><br><span class="line">        cell = [collectionView dequeueReusableCellWithReuseIdentifier:BoardCollectionViewCellID forIndexPath:indexPath];</span><br><span class="line">        <span class="keyword">if</span> ([cell isKindOfClass:[QTBoardsCollectionViewCell class]]) &#123;</span><br><span class="line">            QTBoardsCollectionViewCell *cellBoard = (QTBoardsCollectionViewCell *) cell;</span><br><span class="line">            [cellBoard setupModel];</span><br><span class="line">            <span class="comment">//            if (self.dataSourceBoards.count &gt; 0) &#123;</span></span><br><span class="line">            <span class="comment">//                cellBoard.boardModel = self.dataSourceBoards[indexPath.row];</span></span><br><span class="line">            <span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collectionView<span class="variable">.collectionViewCellType</span> == CellTypeUsers) &#123;</span><br><span class="line">        cell = [collectionView dequeueReusableCellWithReuseIdentifier:UserCollectionViewCellID forIndexPath:indexPath];</span><br><span class="line">        <span class="keyword">if</span> ([cell isKindOfClass:[QTUsersCollectionViewCell class]]) &#123;</span><br><span class="line">            QTUsersCollectionViewCell *cellUser = (QTUsersCollectionViewCell *) cell;</span><br><span class="line">            [cellUser setupModel];</span><br><span class="line">            <span class="comment">//            if (self.dataSourceUsers.count &gt; 0) &#123;</span></span><br><span class="line">            <span class="comment">//                cellUser.userModel = self.dataSourceUsers[indexPath.row];</span></span><br><span class="line">            <span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    <span class="keyword">if</span> (![scrollView isKindOfClass:[<span class="built_in">UICollectionView</span> class]])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGFloat</span> horizontalOffset = scrollView<span class="variable">.contentOffset</span><span class="variable">.x</span>;</span><br><span class="line">    QTCollectionView *collectionView = (QTCollectionView *) scrollView;</span><br><span class="line">    <span class="built_in">NSInteger</span> index = collectionView<span class="variable">.indexPath</span><span class="variable">.row</span>;</span><br><span class="line">    <span class="comment">// 根据 collectionViewCellType 存储对应的偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (collectionView<span class="variable">.collectionViewCellType</span> == CellTypeExplores) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.contentOffsetDictionaryOfExplores</span>[[@(index) stringValue]] = @(horizontalOffset);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collectionView<span class="variable">.collectionViewCellType</span> == CellTypeBoards) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.contentOffsetDictionaryOfBoards</span>[[@(index) stringValue]] = @(horizontalOffset);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collectionView<span class="variable">.collectionViewCellType</span> == CellTypeUsers) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.contentOffsetDictionaryOfUsers</span>[[@(index) stringValue]] = @(horizontalOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 Cell 的重用机制，我们需要通过辅助手段，记住每个 UICollectionView 中滑动的偏移量，这里通过：<code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView</code> 实现。</p>
<p>整个代码比较简单，辅助上注释，相信并不难理解。大功告成，我们来看下最后的实现效果吧：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/putting-a-uicollectionview-in-a-uitableviewcell-07.png" alt=""></p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/putting-a-uicollectionview-in-a-uitableviewcell-09.png" alt=""></p>
<hr>
<h2 id="感谢">感谢</h2><p>本文绝大部分思想来自 <a href="https://ashfurrow.com/blog/putting-a-uicollectionview-in-a-uitableviewcell/" target="_blank" rel="external">Putting a UICollectionView in a UITableViewCell</a>，再次表示感谢！</p>
<p>如果你是个 Swifter，这里提供一篇基于 Swift 的文章 <a href="https://www.thorntech.com/2015/08/want-your-swift-app-to-scroll-in-two-directions-like-netflix-heres-how/" target="_blank" rel="external">https://www.thorntech.com/2015/08/want-your-swift-app-to-scroll-in-two-directions-like-netflix-heres-how/</a> 以供参考。</p>
<hr>
<h2 id="参考">参考</h2><ol>
<li><a href="https://ashfurrow.com/blog/putting-a-uicollectionview-in-a-uitableviewcell/" target="_blank" rel="external">Putting a UICollectionView in a UITableViewCell</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>自从去年来到花瓣实习以后，因为时间与精力（其实就是懒）的原因，这半年多没有写过一篇技术相关的文章。不过，随着项目的逐渐进展，我想，有必要对一些知识点进行总结与回顾了。与此同时，如果能帮助到大家就最好不过了：）</p>]]>
    
    </summary>
    
      <category term="UICollectionView" scheme="http://itangqi.me/tags/UICollectionView/"/>
    
      <category term="UITableView" scheme="http://itangqi.me/tags/UITableView/"/>
    
      <category term="UITableViewCell" scheme="http://itangqi.me/tags/UITableViewCell/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Bye 2016, Hi 2017]]></title>
    <link href="http://itangqi.me/2016/12/31/bye2016-hi2017/"/>
    <id>http://itangqi.me/2016/12/31/bye2016-hi2017/</id>
    <published>2016-12-30T16:00:00.000Z</published>
    <updated>2016-12-31T06:57:43.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>过去的如果就这么过去了，以后只会越来越糟。——《驴得水》</p>
</blockquote>
<a id="more"></a>
<h2 id="技术">技术</h2><h3 id="1_月_—_2_月">1 月 — 2 月</h3><p>为了迎接 3 月份的实习生面试，这 2 个月基本上就是在不断地刷题中度过的。</p>
<p>对了，想要进大厂，数据结构与算法一定要过关，别问我为什么这么说。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/IMG_1930%203.JPG" alt=""></p>
<h3 id="3_月_—_5_月">3 月 — 5 月</h3><p>正式开启了长达 3 个月之久的实习生求职之旅，虽然一路磕磕绊绊，但却也收获了许多宝贵的经验。</p>
<p>最开始，经历了豆瓣顺利到让人怀疑的面试，最终顺利拿到 Offer。</p>
<p>紧接着，接连跪在了百度与腾讯的在线笔试上，开始怀疑人生。</p>
<p>再后来，面对阿里内推与现场面试这两次机会时，都没能把握住。</p>
<p>幸运的是，我遇到了<a href="http://huaban.com/" target="_blank" rel="external">花瓣</a>。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/IMG_0997.JPG" alt=""></p>
<h3 id="6_月">6 月</h3><p>最轻松的一个月，闲暇时开始 <a href="https://github.com/tangqi92/GankYou" target="_blank" rel="external">GankYou</a> 的开发，随后由于工作的原因，没能持续更新下去，希望 17 年自己能把 Side Project 坚持下去。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/meizhi.png" alt=""></p>
<h3 id="7_月_—_9_月">7 月 — 9 月</h3><p>来到花瓣实习，经历了陶叔叔离职，产生过离开的想法，不过最终决定留下。</p>
<p>随后在士辛的指导下，参与了阔别三年之久的花瓣 Android <a href="http://www.wandoujia.com/apps/com.huaban.android" target="_blank" rel="external">3.0</a> 版本的开发，有幸见证了用户从零一步步增长到几十万的过程。</p>
<p>由于没有历史包袱，3.0 版本是完全基于 Kotlin 编写的，感觉很爽啊！但期间也踩了不少坑，之后会专门写篇文章来进行总结。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/665d097e49420fdbd0221fe7956b1820-for-7743-o_1arfsrcjt1h02tat1ogr1kkf1s3514-uid-12202.jpeg" alt=""></p>
<h3 id="10_月_—_12_月">10 月 — 12 月</h3><p>花瓣 Android 由士辛继续迭代，而我也正式转向 iOS，独立负责花瓣 iOS 4.0 版本的改版。4.0 采用了全新的设计，相应模块也进行了改版，目前为止已经进入内测阶段。</p>
<p>第一次独立负责项目，从一开始的畏畏缩缩，到现在的游刃有余，这是我飞速进步的 3 个月。我有个小小的愿望，那就是希望能通过自己的不断地努力，把花瓣 iOS 不断做得更好，能得到更多人的喜欢与肯定。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/IMG_1933.PNG" alt=""></p>
<h2 id="生活">生活</h2><h3 id="1_月_—_6_月">1 月 — 6 月</h3><p>下学期基本上就没去上过课，心思全在找实习上。</p>
<p>对于研二选择实习的我而言，其实这就是整个研究生生涯亦是整个学生生涯，最后的校园时光了，很高兴能与一群志同道合的小伙伴们一起度过。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/Enlighsst.jpg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/IMG_0638.JPG" alt=""></p>
<h3 id="7_月_—_12_月">7 月 — 12 月</h3><p>选择一个人住，选择自己想要的生活。</p>
<p>开始健身，开始自己做饭，开始改变穿衣风格。</p>
<p>感到累了，迷惘了，就回家，回到那个最温暖的地方。</p>
<p>感谢陶叔叔对我的赏识，让我有幸加入花瓣；感谢士辛在技术上的指点，让我快速成长起来；感谢雅金在设计与产品上的追求，让我更加有动力将花瓣做得更加精致；感谢花瓣的所有人，让我很有归属感。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/Enlight%2031.jpg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/Enlight%2032.jpg" alt=""></p>
<h2 id="2017">2017</h2><blockquote>
<p>永远保持真诚，保持高尚的品行。把每天过成你的最后一天，活得充实、不留遗憾，有冒险精神、要英勇，但也要尽情享受，因为人生本短。——《神奇队长》</p>
</blockquote>
<h2 id="书单列表">书单列表</h2><ol>
<li><a href="https://book.douban.com/subject/26630830/" target="_blank" rel="external">程序员面试宝典</a></li>
<li><a href="https://book.douban.com/subject/25910559/" target="_blank" rel="external">剑指Offer</a></li>
<li><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="external">图解HTTP</a></li>
<li><a href="https://book.douban.com/subject/24284008/" target="_blank" rel="external">Objective-C基础教程</a></li>
<li><a href="https://book.douban.com/subject/19967897/" target="_blank" rel="external">Objective-C 程序设计</a></li>
<li><a href="https://book.douban.com/subject/24720270/" target="_blank" rel="external">Objective-C高级编程</a></li>
<li><a href="https://book.douban.com/subject/25829244/" target="_blank" rel="external">Effective Objective-C 2.0</a></li>
<li><a href="https://book.douban.com/subject/26599538/" target="_blank" rel="external">Android开发艺术探索</a></li>
<li><a href="http://producter.io/" target="_blank" rel="external">Producter</a></li>
<li><a href="https://book.douban.com/subject/3523041/" target="_blank" rel="external">平凡的世界（全三册）</a></li>
</ol>
<h2 id="推荐单品">推荐单品</h2><ol>
<li><a href="http://you.163.com/item/detail?id=1037011" target="_blank" rel="external">安睡慢回弹记忆绵床垫</a></li>
<li><a href="https://detail.tmall.com/item.htm?spm=a1z10.3-b-s.w4011-14571099812.64.jqDlt6&amp;id=13230519823&amp;rn=41ae3101ca27fd6ebef56811aefb1222&amp;abbucket=18&amp;skuId=50444570013" target="_blank" rel="external">飞利浦电动牙刷HX6730</a></li>
</ol>
<h2 id="心愿单">心愿单</h2><ol>
<li>坚持健身</li>
<li>自己做饭</li>
<li>早睡早起</li>
<li>论文顺利开题</li>
<li>拿到心仪的 Offer</li>
<li>做自己，做喜欢的事</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>过去的如果就这么过去了，以后只会越来越糟。——《驴得水》</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Review" scheme="http://itangqi.me/tags/Review/"/>
    
      <category term="Summary" scheme="http://itangqi.me/tags/Summary/"/>
    
      <category term="Life" scheme="http://itangqi.me/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[近况]]></title>
    <link href="http://itangqi.me/2016/08/14/what-is-going-on/"/>
    <id>http://itangqi.me/2016/08/14/what-is-going-on/</id>
    <published>2016-08-13T16:00:00.000Z</published>
    <updated>2016-08-14T12:27:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这是一篇流水账，主要记录下过去两个月的时间里，我在生活和工作中经历的一些事与感悟。</p>
<a id="more"></a>
<hr>
<h2 id="最后的校园时光">最后的校园时光</h2><blockquote>
<p>习惯幕起幕落，总以为明天还很多。当我渐渐习惯并开始享受读研的日子时，我却到了不得不得和她说「再见」的时候。</p>
</blockquote>
<p>在 6 月初拿到实习 Offer 并决定不再面试其他公司后，我终于结束了长达 3 个月的实习生求职之旅（此处泪流满面.jpg）。同时，作为实验室最后一个确定实习意向的我，也终于能放下心中悬着的石头，和小伙伴们一起尽情地享受最后宝贵的校园时光了。</p>
<p>所以，在最后大半个月的时间里，我们总会找各种理由，隔三差五出去聚餐。亦或者在实验室，三五成群打牌、打游戏或者看电影（平时肯定不会这样哒），我们尽可能用照片记录下这一切，因为我们心里都清楚，这段弥足珍贵的时光，将一去不复返。如果说，读研给我留下了什么？与那些貌似高大尚其实华而不实的课程、与那些枯燥乏味且强制要听的讲座、与那些只会剥削利用学生劳动力的教授相比，那绝对是一群友爱的小伙伴。你能相信吗？即使现在我们散落在全国各地，但我们每周末都会约定一起进行视屏聊天。可以说，能拥有这样一群小伙伴真的非常幸福。</p>
<hr>
<h2 id="拥抱变化">拥抱变化</h2><blockquote>
<p>如果说，为什么选择花瓣？那我会毫不避讳地说：“我是冲着陶叔叔来的~”</p>
</blockquote>
<p>是的，正因为花瓣 iOS 端负责人是陶叔叔，所以我相信，若能在他的指导下工作，我一定能快速的成长。</p>
<p>可当我怀揣着雄心壮志，准备大干一番的时候，我却得知了陶叔叔即将离职的消息，而那是在我正式报道的第一天。突如其来的「变化」让我措手不及，我清楚的记得，当我听到这个消息的时候，我脑子是一片空白的。陶叔叔说他离职还有半个月的时间，不管接下来我怎么选择，这段日子，该学习的还要学习，该工作的还要工作。同时他也给了我很多中肯的意见，但他也始终强调，最终的决定一定是我自己拿。</p>
<p>那么，既然有了「变化」，就要有一颗积极的心去「拥抱变化」，一方面我每天照常努力学习与工作，另一方面我给自己列举了很多可能性，在纠结与权衡半个月之后，我决定留在花瓣。因为我相信花瓣，也相信自己，这是一个机会，我希望我能把握住它。</p>
<p>最后仍要感谢下陶叔叔，如果不是他，我也许就不会选择花瓣。虽然只和他共事短短半个月的时间，但他对我真的非常的好，身怀绝技却又平易近人（其实是有些逗逼啦~）。从他身上学到了不仅仅是技术，还有很多很多，祝陶叔叔之后一切顺利，以后常聚，记得请我吃饭啊，哈哈~</p>
<hr>
<h2 id="花瓣">花瓣</h2><blockquote>
<p>放弃了豆瓣，错过了阿里，选择了花瓣，这一切都是「缘」。</p>
</blockquote>
<p>花瓣是个小团队，所以在花瓣，你既要当开发，又要当测试，还要兼职卖萌当客服解答用户的疑问。我当然不是在抱怨，反而是很享受这个过程，因为在这有一种「归属感」，只要你想，你能在花瓣做任何事。团队非常友爱，相处起来非常融洽，上个星期，我还在公司过了生日。</p>
<p>过去的一个月，我都在参与花瓣 Android 的开发，虽然非常繁忙但却又感到非常幸运，因为能参与到一个全新的项目中（由于没有历史包袱，这次我们是从零开始重写），有很多想做却没机会做的事可以去实现。关于项目的具体细节，之后会有专门的文章来讲述，其实我和小伙伴是有计划搭建公司的技术博客，希望之后能付诸于行动吧~</p>
<p>花瓣 Android 正式版即将上线了，如果你想尝鲜的话，可以在这里获取<a href="http://fir.im/huabanAndroid" target="_blank" rel="external">最新测试版</a>（求轻喷 ≧▽≦）</p>
<p>关于接下来的计划，一方面，是继续迭代花瓣 Android 客户端，我和小伙伴「士辛」都有着共同的愿景，就是希望能做一款令自己满意的精致的应用，希望我们能实现吧~另一方面，是希望能推进花瓣 iOS 客户端新版本的开发工作，毕竟自己更热爱 iOS。但不管怎么，眼下的仍需要踏踏实实，一步一脚印走下去，加油吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>这是一篇流水账，主要记录下过去两个月的时间里，我在生活和工作中经历的一些事与感悟。</p>]]>
    
    </summary>
    
      <category term="Diary" scheme="http://itangqi.me/tags/Diary/"/>
    
      <category term="Summary" scheme="http://itangqi.me/tags/Summary/"/>
    
      <category term="Life" scheme="http://itangqi.me/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java 中的垃圾回收]]></title>
    <link href="http://itangqi.me/2016/06/12/garbage-collection-in-java/"/>
    <id>http://itangqi.me/2016/06/12/garbage-collection-in-java/</id>
    <published>2016-06-11T16:00:00.000Z</published>
    <updated>2016-06-22T04:28:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>说来惭愧，作为一名前 Android 开发者，对于 Java 的理解理应十分透彻才对。可不瞒你说，就在写这篇文章之前，你要是问我关于 Java 中垃圾回收（GC）的问题，我准一脸懵逼，哈哈（我居然还有脸笑）~</p>
<p>所以呢，在后继学习 iOS 开发的过程中，我特别注重原理的掌握。当然，如果你问我 Objective-C 中的内存管理机制，我肯定是有所了解的，不信你看：<a href="http://itangqi.me/2016/03/10/the-notes-of-learning-arc/">《Objective-C 高级编程》读书笔记之 ARC</a>。</p>
<blockquote>
<p>出来混，迟早是要还的。</p>
</blockquote>
<p>我想，现在也是时候把在 Java 那欠下的债清一清了，今天就来先来补一补——Java 中的垃圾回收机制。</p>
<a id="more"></a>
<hr>
<h2 id="什么是垃圾回收">什么是垃圾回收</h2><p>乍一看，垃圾回收所做的事情应当恰如其名——查找并清除垃圾。事实上却恰恰相反。垃圾回收会跟踪所有仍在使用的对象，然后将剩余的对象标记为垃圾。牢记了这点之后，我们再来深入地了解下这个被称为「垃圾回收」的自动化内存回收在 JVM 中到底是如何实现的。</p>
<h3 id="手动内存管理">手动内存管理</h3><p>在介绍现代版的垃圾回收之前，我们先来简单地回顾下需要手动地显式分配及释放内存的那些日子。如果你忘了去释放内存，那么这块内存就无法重用了。这块内存被占有了却没被使用。这种场景被称之为<strong>内存泄露</strong>。</p>
<p>内存泄露曾经是个非常普遍的问题。你只能通过不断地修复自己的代码来与它们进行抗争。因此，需要有一种更优雅的方式来自动释放无用内存，以便减少人为错误的可能性。这种自动化过程又被称为垃圾回收（简称 GC）。</p>
<h3 id="自动内存管理">自动内存管理</h3><p>第一代的垃圾回收器是 1959 年 Lisp 引入的，这项技术迄今为止一直在不断演进。</p>
<h4 id="引用计数">引用计数</h4><p>咦，这不是 Objective-C 中的概念吗？其实许多语言比如说 Perl，Python 以及 PHP，采用的都是这种方式。这个通过一张图可以很容易说明：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-07.png" alt=""></p>
<p>绿色的云代表的是程序中仍在使用的对象。从技术层面上来说，这有点像是正在执行的某个方法里面的局部变量，亦或是静态变量之类的。不同编程语言的情况可能会不一样，因此这并不是我们关注的重点。</p>
<p>蓝色的圆圈代表的是内存中的对象，可以看到有多少对象引用了它们。灰色圆圈的对象是已经没有任何人引用的了。因此，它们属于垃圾对象，可以被垃圾回收器清理掉。</p>
<p>看起来还不错对吧？没错，不过这里存在着一个重大的缺陷。很容易会出现一些<strong>孤立的环（detached cycle）</strong>，它们中的对象都不在任何域内，但彼此却互相引用导致引用数不为 0。下面便是一个例子：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-08.png" alt=""></p>
<p>看到了吧，红色部分其实就是应用程序不再使用的垃圾对象。由于引用计数的缺陷，因此会存在内存泄露。</p>
<p>有几种方法可以解决这一问题，比如 OC 中便可以使用 <code>weak</code> 引用来解决，接下来让我们来看下 JVM 所采用的方法。</p>
<h4 id="标记删除">标记删除</h4><p>首先，JVM 对于对象<strong>可达性</strong>的定义要明确一些。它可不像前面那样用绿色的云便含糊了事的，而是有着非常明确及具体的垃圾回收根对象（Garbage Collection Roots）的定义：</p>
<ul>
<li>局部变量</li>
<li>活动线程</li>
<li>静态字段</li>
<li>JNI 引用</li>
</ul>
<p>JVM 通过标记删除的算法来记录所有可达（存活）对象，同时确保不可达对象的那些内存能够被重用。这包含两个步骤：</p>
<ul>
<li>标记：是指遍历所有可达对象，然后在本地内存中记录这些对象的信息</li>
<li>删除：会确保不可达对象的内存地址可以在下一次内存分配中使用</li>
</ul>
<p>JVM 中的不同 GC 算法，比如说 Parallel Scavenge，Parallel Mark+Copy，CMS 都是这一算法的不同实现，只是各阶段略有不同而已，从概念上来讲仍然是对应着上面所说的那两个步骤。</p>
<p>这种实现最重要的就是不会再出现泄露的对象环了：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-09.png" alt=""></p>
<p>缺点就是应用程序的线程需要被<strong>暂停</strong>才能完成回收，如果引用一直在变的话你是无法进行计数的。这个应用程序被暂停以便 JVM 可以收拾家务的情况又被称为 <strong>Stop The World pause</strong>(STW)。这种暂停被触发的可能性有很多，不过垃圾回收应该是最常见的一种。</p>
<blockquote>
<p>因为垃圾回收的时候，需要整个的引用状态保持不变，否则判定是判定垃圾，等我稍后回收的时候它又被引用了，这就全乱套了。所以，GC 的时候，其他所有的程序执行处于暂停状态，卡住了。<br>幸运的是，这个卡顿是非常短（尤其是新生代），对程序的影响微乎其微 （关于其他 GC 比如并发 GC 之类的，在此不讨论）。<br>所以 GC 的卡顿问题由此而来，也是情有可原，暂时无可避免。</p>
</blockquote>
<hr>
<h2 id="碎片及整理（Fragmenting_and_Compacting）">碎片及整理（Fragmenting and Compacting）</h2><p>JVM 在清除不可达对象之后，还得确保它们所在的空间是可以进行复用的。对象删除会导致碎片的出现，这有点类似于磁盘碎片，这会带来两个问题：</p>
<ul>
<li>写操作会变得更加费时，因为查找下一个可用空闲块已不再是一个简单操作</li>
<li>JVM 在创建新对象的，会在连续的区块中分配内存。因此如果碎片已经严重到没有一个空闲块能足够容纳新创建的对象时，内存分配便会报错</li>
</ul>
<p>为了避免此类情形，JVM 需要确保碎片化在可控范围内。因此，在垃圾回收的过程中，除了进行标记和删除外，还有一个「内存去碎片化」的过程。在这个过程当中，会给可达对象重新分配空间，让它们互相紧挨着对方，这样便可以去除碎片。下图展示的便是这一过程：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-10.png" alt=""></p>
<hr>
<h2 id="分代假设">分代假设</h2><p>如前所述，垃圾回收需要完全中止应用运行。显然，对象越多，回收的时间也越长。那么我们能不能在更小的内存区域上进行回收呢？通过可行性调查，一组研究人员发现应用中绝大多数的内存分配会分为两大类：</p>
<ul>
<li>绝大部分的对象很快会变为不可用状态</li>
<li>还有一些，它们的存活时间通常也不会很长</li>
</ul>
<p>这些结论最终构成了弱分代假设（Weak Generational Hypothesis）。基于这一假设，虚拟机内的内存被分为两类，新生代（Young Generation)及老生代（Old Generation)。后者又被称为年老代（Tenured Generation）。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-11.png" alt=""></p>
<p>有了各自独立的可清除区域后，这才出现了众多不同的回收算法，正是它们一直以来在持续提升着 GC 的性能。</p>
<p>这并不说明这样的方式是没有问题的。比如说，不同分代中的对象可能彼此间有引用，在进行分代回收时，它们便为视为是「事实上」的 GC 根对象（GC roots)。</p>
<p>而更为重要的是，分代假设对于某些应用来说并不成立。由于 GC 算法主要是为那些「快速消失」或者「永久存活」的对象而进行的优化，因此对于那些生命周期「适中」的对象，JVM 就显得无能为力了。</p>
<hr>
<h2 id="内存池">内存池</h2><p>在堆里面进行内存池的划分对大家来说应该是非常熟悉的了。不过大家可能不太清楚的是在不同的内存池中，垃圾回收是如何履行它的职责的。值得注意的是，虽然不同的 GC 算法细节实现上有所不同，但是本文中所提到的概念却是大同小异的。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-04.png" alt=""></p>
<h3 id="Eden_区">Eden 区</h3><p>新对象被创建时，通常便会被分配到 Eden 区。由于通常都会有多个线程在同时分配大量的对象，因此 Eden 区又被进一步划分成一个或多个线程本地分配缓冲（Thread Local Allocation Buffer，简称 TLAB）。有了这些缓冲区使得 JVM 中大多数对象的分配都可以在各个线程自己对应的 TLAB 中完成，从而避免了线程间昂贵的同步开销。</p>
<p>如果在 TLAB 中无法完成分配（通常是由于没有足够的空间），便会到 Eden 区的共享空间中进行分配。如果这里还是没有足够的空间，则会触发一次新生代垃圾回收的过程来释放空间。如果垃圾回收后 Eden 区还是没有足够的空间，那么这个对象便会到老生代中去分配。</p>
<p>当进行 Eden 区的回收时，垃圾回收器会从根对象开始遍历所有的可达对象，并将它们标记为存活状态。</p>
<p>前面我们已经提到，对象间可能会存在跨代引用，因此最直观的做法便是扫描其它分区到 Eden 区的所有引用。但不幸的是这么做会做成分代的做法变得毫无意义。JVM 对此有它自己的妙招：卡片式标记（card-marking）。基本的做法是，JVM 将 Eden 区中可能存在老生代引用的对象标记为「脏」对象。关于这点<a href="http://psy-lob-saw.blogspot.jp/2014/10/the-jvm-write-barrier-card-marking.html" target="_blank" rel="external">Nitsan</a> 的博客这里有更进一步的介绍。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-05.png" alt=""></p>
<p>标记完成后，所有存活对象会被复制到其中的一个 Survivor 区。于是整个 Eden 区便可认为是清空了，又可以重新用来分配对象了。这一过程便被称为标记复制（Mark and Copy）：存活对象先被标记，随后被复制到 Survivor 区中。</p>
<h3 id="Survivor_区">Survivor 区</h3><p>紧挨着 Eden 的是两个 Survivor 区，分别是 ‘from’ 区和 ‘to’ 区。值得一提的是其中的一个 Survivor 区始终都是空的。</p>
<p>空的 Survivor 区会在下一次新生代 GC 的时候迎来它的居民。整个新生代中的所有存活对象（包含 Eden 区以及那个非空的名为 ‘from’ 的 Survivor 区）都会被复制到 ‘to’ 区中。一旦完成之后，对象便都跑到 ‘to’ 区中而 ‘from’ 区则被清空了。这时两者的角色便会发生调转。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-06.png" alt=""></p>
<p>存活对象会不断地在两个存活区之间来回地复制，直到其中的一些对象被认为是已经成熟，「足够老」了。请记住这点，基于分代假设，已经存活了一段时间的对象，在相当长的一段时间内仍可能继续存活。</p>
<p>这些「年老」的对象会被提升至老年代空间。出现对象提升的时候，这些对象则不会再被复制到另一个存活区，而是直接复制到老年代中，它们会一直待到不再被引用为止。</p>
<p>垃圾回收器会跟踪每个对象历经的回收次数，来判断它们是否已经「足够年老」，可以传播至老年代中。在一轮 GC 完成之后，每个分区中存活下来的对象的计数便会增加。当一个对象的年龄超过了一个特定的年老阈值之后，它便会被提升到老年代中。</p>
<p>JVM 会动态地调整实际的年龄阈值，不过通过指定 -XX:+MaxTenuringThreshold 参数可以给该值设置一个上限。将 -XX:+MaxTenuringThreshold 设置为 0 则立即触发对象提升，而不会复制到存活区中。在现代的 JVM 中，这个值默认会被设置为 15 个 GC 周期。在 HotSpot 虚拟机中这也是该值的上限。</p>
<p>如果存活区的大小不足以存放所有的新生代存活对象，则会出现过早提升。</p>
<h3 id="老生代">老生代</h3><p>老生代的内存空间的实现则更为复杂。老生代的空间通常都会非常大，里面存放的对象都是不太可能会被回收的。</p>
<p>老生代的 GC 比新生代的 GC 发生的频率要少得多。由于老生代中的多数对象都被认为是存活的，也就不会存在标记-复制操作了。在 GC 中，这些对象会被挪到一起以减少碎片。老生代的回收算法通常都是根据不同的理论来构建的。不过大体上都会分成如下几步：</p>
<ul>
<li>标记可达对象，设置 GC 根对象可达的所有对象后的标记位</li>
<li>删除不可达对象</li>
<li>整理老生代空间的对象，将存活对象复制到老生代开始的连续空间内。</li>
</ul>
<p>从以上描述中可知，为了避免过度碎片化，老生代的 GC 是明确需要进行整理操作的。</p>
<h3 id="持久代">持久代</h3><p>在 Java 8 以前还有一个特殊的空间叫做持久代（Permanent Generation）。这是元数据比如类相关数据存放的地方。除此之外，像驻留的字符串（internalized string）也会被存放在持久代中。这的确给Java开发人员带来了不少麻烦事，因为很难评估这究竟会使用到多少空间。评估不到位偏会抛出 java.lang.OutOfMemoryError: Permgen space 的异常。只要不是真的因为内存泄漏而引起的 OutOfMemoryError 异常，可以通过增加持久代空间的大小来解决这一问题，比如下例中的把持久代最大空间设置为 256MB：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:MaxPermSize=<span class="number">256</span>m com.mycompany.MyApplication</span><br></pre></td></tr></table></figure>
<h3 id="元空间">元空间</h3><p>由于元数据空间大小的预测是件繁琐且低效的工作，于是 Java 8 中干脆就去掉了持久代，转而推出了元空间。从此以后，那些个杂七杂八的东西便都存储到正常的 Java 堆了。</p>
<p>但是，类定义如今则是存储到了元空间里。它存储在本地内存中，不会与堆 内存相混杂。默认情况下，元空间的大小只受限于Java进程的可用本地内存的大小。这大大解放了开发人员，他们不会再因为多增加了一个类而引发 java.lang.OutOfMemoryError: Permgen space 异常了。值得注意的是，虽然看似元空间大小毫无限制了，但这一些并非是没有代价的——如果任由元空间无节制地增长，你可能会面临的是频繁的内存交换（swapping）或者是本地内存分配失败。</p>
<p>如果你希望避免此类情况，可以像下例中这样限制一下元空间的大小，将它设置成比如 256 MB：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:MaxMetaspaceSize=<span class="number">256</span>m com.mycompany.MyApplication</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="新生代_GC（Minor_GC）vs-_老生代_GC（Major_GC）vs-_Full_GC">新生代 GC（Minor GC）vs. 老生代 GC（Major GC）vs. Full GC</h2><p>清除堆内存不同区域的垃圾回收事件又被称为新生代 GC，老生代 GC，以及 Full GC 事件。下面我们将介绍一下不同事件的区别在哪里。不过你会发现其实各自的差别并不是那么重要。</p>
<p>重要的是我们希望知道应用是否到达它的服务能力上限了，而这又只能去监控应用的处理延时或者吞吐量。只有在这个时间GC事件才能派上用场。这些事件的关键之处在于它们是否停止了应用的运行，以及停了多久。</p>
<p>不过由于新生代 GC，老生代 GC，Full GC 这几个术语被广泛使用却又没有一个清晰的定义，我们还是先来详细地介绍一下它们的区别再说吧。</p>
<h3 id="新生代_GC">新生代 GC</h3><p>新生代垃圾的回收被称作 Minor GC。这个定义非常清晰，理解起来也不会有什么歧义。不过当处理新生代GC事件时，还是有一些有意思的东西值得注意的：</p>
<ol>
<li>只要 JVM 无法为新创建的对象分配空间，就肯定会触发新生代 GC，比方说 Eden 区满了。因此对象创建得越频繁，新生代 GC 肯定也更频繁</li>
<li>一旦内存池满了，它的所有内容就会被拷贝走，指针又将重新归零。因此和经典的标记（Mark），清除（Sweep），整理（Compact）的过程不同的是，Eden 区和 Survivor 区的清理只涉及到标记和拷贝。在它们中是不会出现碎片的。写指针始终在当前使用区的顶部</li>
<li>在一次新生代 GC 事件中，通常不涉及到年老代。年老代到年轻代的引用被认为是 GC 的根对象。而在标记阶段中，从年轻代到年老代的引用则会被忽略掉</li>
<li>和通常所理解的不一样的是，所有的新生代 GC 都会触发 stop-the-world 暂停，这会中断应用程序的线程。对绝大多数应用而言，暂停的时间是可以忽略不计的</li>
</ol>
<p>现在来看新生代 GC 还是很清晰的——每一次新生代 GC 都会对年轻代进行垃圾清除。</p>
<h3 id="老年代_GC_与_Full_GC">老年代 GC 与 Full GC</h3><p>你会发现关于这两种 GC 其实并没有明确的定义。JVM 规范或者垃圾回收相关的论文中都没有提及。不过从直觉来说，根据新生代 GC（Minor GC）清理的是新生代空间的认识来看，不难得出以下推论（这里应当从英文出发来理解，Minor, Major 与 Full GC，翻译过来的名称已经带有明显的释义了）：</p>
<ul>
<li>Major GC 清理的是老年代的空间</li>
<li>Full GC 清理的是整个堆——包括新生代与老年代空间</li>
</ul>
<p>因此我们从实际的 GC 日志中所看到的是这样——其实没有什么两次所谓的 Full GC，只有一次清理年老代空间的 Major GC 而已。</p>
<hr>
<h2 id="垃圾回收算法">垃圾回收算法</h2><h3 id="标记清除算法（Mark-Sweep）">标记清除算法（Mark-Sweep）</h3><p>通过名字就应该猜到了，就是标记哪些是可回收的，然后进行清除回收处理。</p>
<p>标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-12.png" alt=""></p>
<blockquote>
<p>优点：简单，易实现<br>缺点：容易产生内存碎片，对于后面分配大空间时，找不到足够的空间，而主动会触发一次内存回收，增加内存回收的次数。</p>
</blockquote>
<h3 id="复制算法">复制算法</h3><p>此方法将内存按容量分为两块，例如 A、B 两块，每次只使用其中的一块，当要进行回收操作时，将 A 中还存活的对象复制到 B 块中（假设上次使用 A），然后对 A 中所有对象清空就又构成一个完整的内存块。这种方法就避免了标记清除的内存碎片问题。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-13.png" alt=""></p>
<blockquote>
<p>优点：快速高效，不会产生内存碎片。<br>缺点：可用内存会减少一半，因为是按照均分的。</p>
</blockquote>
<p><strong>注意： 效率也与存活对象的多少有关，如果存活对象多，复制就多，效率就低了。</strong></p>
<h3 id="标记整理算法（Mark-Compact）">标记整理算法（Mark-Compact）</h3><p>标记整理算法就是在标记清除方法的基础上进行了优化，主要是在标记完成后将这些存活的对象向一端移动，然后将末尾边界后的所有内存空间清除。</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/garbage-collection-in-java-14.png" alt=""></p>
<blockquote>
<p>优点： 适合存活对象多的，不产生内存碎片</p>
</blockquote>
<h3 id="分代回收算法">分代回收算法</h3><p>分代回收算法其实不算一种新的算法，而是根据复制算法和标记整理算法的的特点综合而成。这种综合是考虑到 Java 的语言特性的。</p>
<p>下面来回顾一下两种老算法的适用场景：</p>
<blockquote>
<p>复制算法：适用于存活对象很少，回收对象多<br>标记整理算法: 适用用于存活对象多，回收对象少</p>
</blockquote>
<p>于是，我们根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Old Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法：</p>
<blockquote>
<p>新生代：由于新生代产生很多临时对象，大量对象需要进行回收，所以采用复制算法是最高效的。<br>老年代：回收的对象很少，都是经过几次标记后都不是可回收的状态转移到老年代的，所以仅有少量对象需要回收，故采用标记清除或者标记整理算法。</p>
</blockquote>
<p>所以以上整个过程就达到了最高效的回收办法——分代回收算法</p>
<h4 id="深入理解分代回收算法">深入理解分代回收算法</h4><p><strong>为什么不是一块 Survivor 区而是两块？</strong></p>
<blockquote>
<p>这里涉及到一个新生代和老年代的存活周期的问题，比如一个对象在新生代经历 15 次（仅供参考）GC，就可以移到老年代了。问题来了，当我们第一次 GC 的时候，我们可以把 Eden 区的存活对象放到 Survivor A区，但是第二次 GC 的时候，Survivor A 区的存活对象也需要再次用 Copying 算法，放到 Survivor B 区上，而把刚刚的 Survivor A 区和 Eden 区清除。第三次 GC 时，又把 Survivor B 区的存活对象复制到 Survivor A 区，如此反复。</p>
</blockquote>
<p>所以，这里就需要两块 Survivor 区来回倒腾。</p>
<p><strong>为什么 Eden 区这么大而 Survivor 区要分的少一点？</strong></p>
<blockquote>
<p>新创建的对象都是放在 Eden 区，这是很频繁的，尤其是大量的局部变量产生的临时对象，这些对象绝大部分都应该马上被回收，能存活下来被转移到 Survivor 区的往往不多。所以，设置较大的 Eden 区和较小的 Survivor 区是合理的，大大提高了内存的使用率，缓解了 Copying 算法的缺点。</p>
</blockquote>
<p>新的问题又来了，从 Eden 区往 Survivor 区转移的时候 Survivor 区不够了怎么办？——直接放到老年代去。</p>
<p><strong>Eden 区和两块 Survivor 区的工作流程？</strong></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配了一个又一个对象</span></span><br><span class="line">放到 Eden 区</span><br><span class="line"><span class="comment">// 不好，Eden 区满了，只能 GC（新生代 GC：Minor GC）了</span></span><br><span class="line">把 Eden 区的存活对象 <span class="keyword">copy</span> 到 Survivor A 区，然后清空 Eden 区（本来 Survivor B 区也需要清空的，不过本来就是空的）</span><br><span class="line"><span class="comment">// 又分配了一个又一个对象</span></span><br><span class="line">放到 Eden 区</span><br><span class="line"><span class="comment">// 不好，Eden 区又满了，只能 GC（新生代 GC：Minor GC）了</span></span><br><span class="line">把 Eden 区和 Survivor A 区的存活对象 <span class="keyword">copy</span> 到 Survivor B 区，然后清空 Eden 区和 Survivor A 区</span><br><span class="line"><span class="comment">// 又分配了一个又一个对象</span></span><br><span class="line">放到 Eden 区</span><br><span class="line"><span class="comment">// 不好，Eden 区又满了，只能 GC（新生代GC：Minor GC）了</span></span><br><span class="line">把 Eden 区和 Survivor B 区的存活对象 <span class="keyword">copy</span> 到 Survivor A 区，然后清空 Eden 区和 Survivor B 区</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 有的对象来回在 Survivor A 区或者 B 区呆了比如 15 次，就被分配到老年代 Old 区</span></span><br><span class="line"><span class="comment">// 有的对象太大，超过了 Eden 区，直接被分配在 Old 区</span></span><br><span class="line"><span class="comment">// 有的存活对象，放不下 Survivor 区，也被分配到 Old 区</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 在某次 Minor GC 的过程中突然发现：</span></span><br><span class="line"><span class="comment">// 不好，老年代 Old 区也满了，这是一次大 GC（老年代 GC：Major GC）</span></span><br><span class="line">Old 区慢慢的整理一番，空间又够了</span><br><span class="line"><span class="comment">// 继续 Minor GC</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>以上为了说明原理，只是最简化版本。</p>
<hr>
<h2 id="小结">小结</h2><p>至此，关于 Java 虚拟机垃圾回收（GC）的讲解就告一段落了，后面要补的知识还很多，路还很长，一步一脚印咯：D</p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://plumbr.eu/handbook/what-is-garbage-collection" target="_blank" rel="external">JAVA Garbage Collection Handbook</a></li>
<li><a href="http://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">理解Java垃圾回收机制</a></li>
<li><a href="http://stackoverflow.com/questions/7874342/what-is-the-difference-between-objective-c-automatic-reference-counting-and-garb****" target="_blank" rel="external">What is the difference between Objective-C automatic reference counting and garbage collection?</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>说来惭愧，作为一名前 Android 开发者，对于 Java 的理解理应十分透彻才对。可不瞒你说，就在写这篇文章之前，你要是问我关于 Java 中垃圾回收（GC）的问题，我准一脸懵逼，哈哈（我居然还有脸笑）~</p>
<p>所以呢，在后继学习 iOS 开发的过程中，我特别注重原理的掌握。当然，如果你问我 Objective-C 中的内存管理机制，我肯定是有所了解的，不信你看：<a href="http://itangqi.me/2016/03/10/the-notes-of-learning-arc/">《Objective-C 高级编程》读书笔记之 ARC</a>。</p>
<blockquote>
<p>出来混，迟早是要还的。</p>
</blockquote>
<p>我想，现在也是时候把在 Java 那欠下的债清一清了，今天就来先来补一补——Java 中的垃圾回收机制。</p>]]>
    
    </summary>
    
      <category term="GC" scheme="http://itangqi.me/tags/GC/"/>
    
      <category term="JVM" scheme="http://itangqi.me/tags/JVM/"/>
    
      <category term="Java" scheme="http://itangqi.me/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[抓包工具 Charles 使用心得]]></title>
    <link href="http://itangqi.me/2016/05/30/tips-for-using-charles/"/>
    <id>http://itangqi.me/2016/05/30/tips-for-using-charles/</id>
    <published>2016-05-29T16:00:00.000Z</published>
    <updated>2016-05-30T15:01:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>虽然实习工作还没有着落，但学习还是要继续的嘛，今天就来学习使用下 Mac 下截取网络封包的工具：<a href="http://www.charlesproxy.com/" target="_blank" rel="external">Charles</a>。</p>
<p>我想，如果你是个善于利用搜索引擎的人，那么在 Google 中输入「Charles 使用」等相应的关键字，便会出现一大把文章。<br>不过呢，之所以会有这篇文章，就是因为今天在安装和初步使用的过程中，遇到了些问题，而目前搜索出来的绝大数文章并没有提及（或者解决办法已经过时）。所以，我在此记录下来，希望能帮助到通过搜索找到这的朋友们。</p>
<a id="more"></a>
<hr>
<h2 id="付费_&amp;_正版">付费 &amp; 正版</h2><blockquote>
<p>Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，使用过程中不定时会中断 5 秒钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。</p>
</blockquote>
<p>关于价格，见下表：</p>
<table>
<thead>
<tr>
<th>License</th>
<th style="text-align:center">Pricing</th>
</tr>
</thead>
<tbody>
<tr>
<td>1-4 User Licenses</td>
<td style="text-align:center">US$50 / license</td>
</tr>
<tr>
<td>5+ User Licenses</td>
<td style="text-align:center">US$40 / license (20% discount)</td>
</tr>
<tr>
<td>10+ User Licenses</td>
<td style="text-align:center">US$30 / license (40% discount)</td>
</tr>
<tr>
<td>Site License</td>
<td style="text-align:center">US$400</td>
</tr>
<tr>
<td>Multi-Site License</td>
<td style="text-align:center">US$700</td>
</tr>
</tbody>
</table>
<p>50 刀的价格虽然不白菜，但试用版并未阉割功能，只是在使用体验上稍差，这可称得上良心啊。虽然我暂时不会购买，但我依然会使用正版，希望你也如此。</p>
<hr>
<h2 id="VPN">VPN</h2><p>当我打开 Charles（Mac OS X Proxy 已选择），按理说，我立刻就能看见源源不断的网络请求出现在 Charles 的界面中啦，可为什么始终是一片空白呢？</p>
<p>一番搜索，终于在这里 <a href="http://stackoverflow.com/questions/25697849/charles-proxy-not-working-with-chrome" target="_blank" rel="external">Charles proxy not working with Chrome</a> 找到了答案：</p>
<blockquote>
<p>For anyone else using VPN: Charles must be turned on before VPN. So quitting VPN after turning on Charles won’t work either.</p>
</blockquote>
<p>没办法，为了正常使用 Charles，只能暂时把梯子撤了：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-01.png" alt=""></p>
<hr>
<h2 id="乱码">乱码</h2><p>刚开始用着挺好的啊，怎么一言不合，就来个乱码呢？</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-08.png" alt=""></p>
<p>于是，便在 Google 中输入「Charles 乱码」，我保证，你能搜到的绝对是这样的答案：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-09.jpg" alt=""></p>
<p>可我告诉你，反正我尝试了在各种地方进行添加，最后都没有成功。<br>而我最终解决了乱码的问题，但根本没有涉及到 <code>Info.plist</code>。你只要确保，我接下来提及的问题，你有正确进行设置。</p>
<h3 id="安装_SSL_证书">安装 SSL 证书</h3><h4 id="Mac_端">Mac 端</h4><blockquote>
<p>首先去 <a href="http://www.charlesproxy.com/ssl.zip" target="_blank" rel="external">http://www.charlesproxy.com/ssl.zip</a> 下载 CA 证书文件，然后双击 .crt 文件，选择「总是信任」按钮，在钥匙串访问中即可看到添加成功的证书。</p>
</blockquote>
<p>看看，人家说的多么简单啊，可事实呢？当我访问上述网址时，出现的是如下的文字：</p>
<blockquote>
<p>If you are running Charles v3.10 or later, please go to Charles and consult the SSL Proxying submenu in the Help menu, for instructions on installing your new Charles Root Certificate.</p>
</blockquote>
<p>我那蹩脚的英文告诉我：如果你使用的是 v3.10 及之后的版本，安装方法已经变了，正确的姿势：启动 Charles 软件，在菜单中找到 Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate. 如下图所示：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-02.png" alt=""><a href="http://blog.devtang.com/2015/11/14/charles-introduction/" target="_blank" rel="external">图片来自</a></p>
<p>随后是这样的：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-03.jpg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-04.jpg" alt=""><a href="https://gitsea.com/2015/11/11/charles-https-%E6%8A%93%E5%8C%85-mac/" target="_blank" rel="external">图片来自</a></p>
<h4 id="iPhone_端">iPhone 端</h4><p>步骤：Help -&gt; SSL Proxying -&gt;Install Charles Root Certificate on a Mobile Device…</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-07.png" alt=""></p>
<h3 id="Mac_上的设置">Mac 上的设置</h3><ol>
<li><p>在 Charles 的工具栏上点击设置按钮，选择 SSL Proxy Settings，选中 Enable SSL Proxying。（别急，选完先别关掉）</p>
</li>
<li><p>SSL 选项卡的 Locations 里填写要抓包的域名和端口，点击 Add 按钮，在弹出的表单中 Host 填写域名。比如填api.instagram.com，Port 填 443</p>
</li>
</ol>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-11.jpg" alt=""><a href="https://gitsea.com/2015/11/11/charles-https-%E6%8A%93%E5%8C%85-mac/" target="_blank" rel="external">图片来自</a></p>
<p><strong>关于乱码，如果没有做这项操作，则肯定会出现乱码。而至于否是在 <code>Info.plist</code> 中添加 <code>UTF-8</code> 的字段，反正最后我没加，但一切正常。</strong></p>
<p>所以这个坑，我也是无意间解决的。</p>
<h3 id="iPhone_上的设置">iPhone 上的设置</h3><blockquote>
<p>首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”-&gt;”Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图所示：</p>
</blockquote>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-05.png" alt=""></p>
<p>然后就是在 iPhone 上的一系列操作，又是很简单，有木有！</p>
<p>可是，为什么尼玛我怎么试都不成果呢？！iPhone 上浏览器网址都打不开了….于是又尝试了另一种方式，在终端敲入 <code>ifconfig en0</code>：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/tips-for-using-charles-06.jpg" alt=""><a href="http://zhangfei.tk/2016/02/18/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7Charles%E7%9A%84%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/" target="_blank" rel="external">图片来自</a></p>
<p>Done! 终于可以愉快的玩耍了：）</p>
<hr>
<h2 id="参考">参考</h2>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>虽然实习工作还没有着落，但学习还是要继续的嘛，今天就来学习使用下 Mac 下截取网络封包的工具：<a href="http://www.charlesproxy.com/">Charles</a>。</p>
<p>我想，如果你是个善于利用搜索引擎的人，那么在 Google 中输入「Charles 使用」等相应的关键字，便会出现一大把文章。<br>不过呢，之所以会有这篇文章，就是因为今天在安装和初步使用的过程中，遇到了些问题，而目前搜索出来的绝大数文章并没有提及（或者解决办法已经过时）。所以，我在此记录下来，希望能帮助到通过搜索找到这的朋友们。</p>]]>
    
    </summary>
    
      <category term="Charles" scheme="http://itangqi.me/tags/Charles/"/>
    
      <category term="Tips" scheme="http://itangqi.me/tags/Tips/"/>
    
      <category term="Mac" scheme="http://itangqi.me/categories/Mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 3.0 源码阅读笔记（七）]]></title>
    <link href="http://itangqi.me/2016/05/20/the-notes-of-learning-afnetworking-seven/"/>
    <id>http://itangqi.me/2016/05/20/the-notes-of-learning-afnetworking-seven/</id>
    <published>2016-05-19T16:00:00.000Z</published>
    <updated>2016-05-28T07:42:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>自 iOS 9 发布之后，由于新特性 <a href="https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html" target="_blank" rel="external">App Transport Security</a> 的引入，在默认行为下是不能发送 HTTP 请求的。很多网站都在转用 HTTPS，而 <code>AFNetworking</code> 中的 <code>AFSecurityPolicy</code> 就是为了阻止<a href="https://zh.wikipedia.org/zh/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" target="_blank" rel="external">中间人攻击</a>，以及其它漏洞的工具。</p>
<p><code>AFSecurityPolicy</code> 主要作用就是验证 HTTPS 请求的证书是否有效，如果应用中有一些敏感信息或者涉及交易信息，一定要使用 HTTPS 来保证交易或者用户信息的安全。</p>
<a id="more"></a>
<hr>
<h2 id="AFSSLPinningMode">AFSSLPinningMode</h2><p>使用 <code>AFSecurityPolicy</code> 时，总共有三种验证服务器是否被信任的方式：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, AFSSLPinningMode) &#123;</span><br><span class="line">    AFSSLPinningModeNone,</span><br><span class="line">    AFSSLPinningModePublicKey,</span><br><span class="line">    AFSSLPinningModeCertificate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="AFSSLPinningModeNone"><code>AFSSLPinningModeNone</code></h3><ul>
<li>这个模式不做本地证书验证（不做 SSL Pinning 操作）</li>
<li>直接从客户端系统中的受信任颁发机构 CA 列表中去验证</li>
</ul>
<h3 id="AFSSLPinningModePublicKey"><code>AFSSLPinningModePublicKey</code></h3><ul>
<li>客户端需要一份证书文件的拷贝</li>
<li>验证时只验证证书里的公钥，不验证证书的有效期等信息</li>
<li>即使伪造证书的公钥，也不能解密传输的数据，必须要私钥</li>
</ul>
<h3 id="AFSSLPinningModeCertificate"><code>AFSSLPinningModeCertificate</code></h3><ul>
<li>客户端需要一份证书文件的拷贝</li>
<li>第一步验证、先验证证书的域名/有效期等信息</li>
<li>第二步验证、对比服务端返回的证书跟客户端存储的证书是否一致</li>
</ul>
<hr>
<h2 id="初始化以及设置">初始化以及设置</h2><p>在使用 <code>AFSecurityPolicy</code> 验证服务端是否受到信任之前，要对其进行初始化，使用初始化方法时，主要目的是设置<strong>验证服务器是否受信任的方式</strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> policyWithPinningMode:pinningMode withPinnedCertificates:[<span class="keyword">self</span> defaultPinnedCertificates]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)policyWithPinningMode:(AFSSLPinningMode)pinningMode withPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    AFSecurityPolicy *securityPolicy = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    securityPolicy<span class="variable">.SSLPinningMode</span> = pinningMode;</span><br><span class="line"></span><br><span class="line">    [securityPolicy setPinnedCertificates:pinnedCertificates];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里没有什么地方值得解释的。不过在调用 <code>pinnedCertificate</code> 的 setter 方法时，会从全部的证书中<strong>取出公钥</strong>保存到 <code>pinnedPublicKeys</code> 属性中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    _pinnedCertificates = pinnedCertificates;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.pinnedCertificates</span>) &#123;</span><br><span class="line">        <span class="built_in">NSMutableSet</span> *mutablePinnedPublicKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity:[<span class="keyword">self</span><span class="variable">.pinnedCertificates</span> count]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificate <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.pinnedCertificates</span>) &#123;</span><br><span class="line">            <span class="keyword">id</span> publicKey = AFPublicKeyForCertificate(certificate);</span><br><span class="line">            <span class="keyword">if</span> (!publicKey) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            [mutablePinnedPublicKeys addObject:publicKey];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pinnedPublicKeys</span> = [<span class="built_in">NSSet</span> setWithSet:mutablePinnedPublicKeys];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.pinnedPublicKeys</span> = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里调用了 <code>AFPublicKeyForCertificate</code> 对证书进行操作，返回一个公钥。</p>
<hr>
<h2 id="操作_SecTrustRef">操作 SecTrustRef</h2><p>对 <code>serverTrust</code> 的操作的函数基本上都是 C 的 API，都定义在 <code>Security</code> 模块中，先来分析一下在上一节中 <code>AFPublicKeyForCertificate</code> 的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> AFPublicKeyForCertificate(<span class="built_in">NSData</span> *certificate) &#123;</span><br><span class="line">    <span class="comment">// 1. 初始化临时变量</span></span><br><span class="line">    <span class="keyword">id</span> allowedPublicKey = <span class="literal">nil</span>;</span><br><span class="line">    SecCertificateRef allowedCertificate;</span><br><span class="line">    SecCertificateRef allowedCertificates[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">CFArrayRef</span> tempCertificates = <span class="literal">nil</span>;</span><br><span class="line">    SecPolicyRef policy = <span class="literal">nil</span>;</span><br><span class="line">    SecTrustRef allowedTrust = <span class="literal">nil</span>;</span><br><span class="line">    SecTrustResultType result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 因为此处传入的 certificate 参数是 NSData 类型的，所以使用 `SecCertificateCreateWithData` 通过 DER 表示的数据生成一个 `SecCertificateRef` 对象，然后判断返回值是否为 `NULL`</span></span><br><span class="line">    allowedCertificate = SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificate);</span><br><span class="line">    __Require_Quiet(allowedCertificate != <span class="literal">NULL</span>, _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通过上面的 `allowedCertificate` 创建一个 `CFArray`</span></span><br><span class="line">    allowedCertificates[<span class="number">0</span>] = allowedCertificate;</span><br><span class="line">    tempCertificates = <span class="built_in">CFArrayCreate</span>(<span class="literal">NULL</span>, (<span class="keyword">const</span> <span class="keyword">void</span> **)allowedCertificates, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建一个默认的符合 X509 标准的 `SecPolicyRef`，通过默认的 `SecPolicyRef` 和证书创建一个 `SecTrustRef` 用于信任评估，对该对象进行信任评估，确认生成的 `SecTrustRef` 是值得信任的，这里使用的 __Require_noErr_Quiet 和上面的宏差不多，只是会根据返回值判断是否存在错误</span></span><br><span class="line">    policy = SecPolicyCreateBasicX509();</span><br><span class="line">    __Require_noErr_Quiet(SecTrustCreateWithCertificates(tempCertificates, policy, &amp;allowedTrust), _<span class="keyword">out</span>);</span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(allowedTrust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 获取公钥，这里的 __bridge_transfer 会将结果桥接成 NSObject 对象，然后将 SecTrustCopyPublicKey 返回的指针释放</span></span><br><span class="line">    allowedPublicKey = (__bridge_transfer <span class="keyword">id</span>)SecTrustCopyPublicKey(allowedTrust);</span><br><span class="line"></span><br><span class="line">_<span class="keyword">out</span>:</span><br><span class="line">    <span class="comment">// 6. 释放各种 C 语言指针</span></span><br><span class="line">    <span class="keyword">if</span> (allowedTrust) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(allowedTrust);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (policy) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(policy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tempCertificates) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(tempCertificates);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allowedCertificate) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(allowedCertificate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> allowedPublicKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 2 处，使用了一个非常神奇的宏 <code>__Require_Quiet</code>，它会判断 <code>allowedCertificate != NULL</code> 是否成立，如果 <code>allowedCertificate</code> 为空就会跳到 <code>_out</code> 标签处继续执行。</li>
<li>关于 DER 的概念：可参见 <a href="https://en.wikipedia.org/wiki/X.690#DER_encoding" target="_blank" rel="external">Wikipedia</a> 或者 <a href="http://blog.csdn.net/taolinke/article/details/6248968" target="_blank" rel="external">如何查看证书的16进制DER编码，及证书的各个域DER格式</a>。</li>
</ul>
<blockquote>
<p>每一个 <code>SecTrustRef</code> 的对象都是包含多个 <code>SecCertificateRef</code> 和 <code>SecPolicyRef</code>。其中 <code>SecCertificateRef</code> 可以使用 DER 进行表示，并且其中存储着公钥信息。</p>
</blockquote>
<p>对它的操作还有 <code>AFCertificateTrustChainForServerTrust</code> 和 <code>AFPublicKeyTrustChainForServerTrust</code> 但是它们几乎调用了相同的 API：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    <span class="comment">// 1. 使用 SecTrustGetCertificateCount 函数获取到 serverTrust 中需要评估的证书链中的证书数目，并保存到 certificateCount 中</span></span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line">    <span class="comment">// 2. 使用 SecTrustGetCertificateAtIndex 函数获取到证书链中的每个证书，并添加到 trustChain 中，最后返回 trustChain</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line">        <span class="comment">// 3. 使用 SecCertificateCopyData 从证书中或者 DER 表示的数据</span></span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="built_in">NSData</span> *)SecCertificateCopyData(certificate)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="验证服务端是否受信">验证服务端是否受信</h2><p>验证服务端是否守信是通过 <code>- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code> 方法进行的，也是 <code>AFSecurityPolicy</code> 类中的核心方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#1：不能隐式地信任自己签发的证书</span></span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#2：设置 policy</span></span><br><span class="line">    </span><br><span class="line">    <span class="preprocessor">#3：验证证书是否有效</span></span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#4：根据 SSLPinningMode 对服务端进行验证</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-_不能隐式地信任自己签发的证书">1. 不能隐式地信任自己签发的证书</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span><span class="variable">.allowInvalidCertificates</span> &amp;&amp; <span class="keyword">self</span><span class="variable">.validatesDomainName</span> &amp;&amp; (<span class="keyword">self</span><span class="variable">.SSLPinningMode</span> == AFSSLPinningModeNone || [<span class="keyword">self</span><span class="variable">.pinnedCertificates</span> count] == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"In order to validate a domain name for self signed certificates, you MUST use pinning."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).<br>Instead, add your own (self-signed) CA certificate to the list of trusted anchors.</p>
</blockquote>
<p>所以如果没有提供证书或者不验证证书，并且还设置 <code>allowInvalidCertificates</code> 为<strong>真</strong>，满足上面的所有条件，说明这次的验证是不安全的，会直接返回 <code>NO</code>。</p>
<h3 id="2-_设置_policy">2. 设置 policy</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.validatesDomainName</span>) &#123;</span><br><span class="line">    [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要验证域名的话，就以域名为参数创建一个 <code>SecPolicyRef</code>，否则会创建一个符合 X509 标准的默认 <code>SecPolicyRef</code> 对象。</p>
<h3 id="3-_验证证书的有效性">3. 验证证书的有效性</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.SSLPinningMode</span> == AFSSLPinningModeNone) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.allowInvalidCertificates</span> || AFServerTrustIsValid(serverTrust);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class="keyword">self</span><span class="variable">.allowInvalidCertificates</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果<strong>只根据信任列表中的证书</strong>进行验证，即 <code>self.SSLPinningMode == AFSSLPinningModeNone</code>。如果允许无效的证书的就会直接返回 <code>YES</code>。不允许就会对服务端信任进行验证</p>
</li>
<li><p>如果服务器信任无效，并且不允许无效证书，就会返回 <code>NO</code></p>
</li>
</ul>
<h3 id="4-_根据_SSLPinningMode_对服务器信任进行验证">4. 根据 <code>SSLPinningMode</code> 对服务器信任进行验证</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">self</span><span class="variable">.SSLPinningMode</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> AFSSLPinningModeNone:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AFSSLPinningModeNone_直接返回_NO"><code>AFSSLPinningModeNone</code> 直接返回 <code>NO</code></h4><h4 id="AFSSLPinningModeCertificate-1"><code>AFSSLPinningModeCertificate</code></h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.pinnedCertificates</span>) &#123;</span><br><span class="line">    [pinnedCertificates addObject:(__bridge_transfer <span class="keyword">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</span><br><span class="line">&#125;</span><br><span class="line">SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it's the Root CA)</span></span><br><span class="line"><span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line">            </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.pinnedCertificates</span> containsObject:trustChainCertificate]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>从 <code>self.pinnedCertificates</code> 中获取 DER 表示的数据</li>
<li>使用 <code>SecTrustSetAnchorCertificates</code> 为服务器信任设置证书</li>
<li>判断服务器信任的有效性</li>
<li>使用 <code>AFCertificateTrustChainForServerTrust</code> 获取服务器信任中的全部 DER 表示的证书</li>
<li>如果 <code>pinnedCertificates</code> 中有相同的证书，就会返回 <code>YES</code></li>
</ol>
<h4 id="AFSSLPinningModePublicKey-1"><code>AFSSLPinningModePublicKey</code></h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.pinnedPublicKeys</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">            trustedPublicKeyCount += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这部分的实现和上面的差不多，区别有两点：</p>
<ol>
<li>会从服务器信任中获取公钥</li>
<li><code>pinnedPublicKeys</code> 中的公钥与服务器信任中的公钥相同的数量大于 0，就会返回真</li>
</ol>
<hr>
<h2 id="与_AFURLSessionManager_协作">与 AFURLSessionManager 协作</h2><p>在代理协议 <code>- URLSession:didReceiveChallenge:completionHandler:</code> 或者 <code>- URLSession:task:didReceiveChallenge:completionHandler:</code> 代理方法被调用时会运行这段代码</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([challenge<span class="variable">.protectionSpace</span><span class="variable">.authenticationMethod</span> isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.securityPolicy</span> evaluateServerTrust:challenge<span class="variable">.protectionSpace</span><span class="variable">.serverTrust</span> forDomain:challenge<span class="variable">.protectionSpace</span><span class="variable">.host</span>]) &#123;</span><br><span class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">        credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge<span class="variable">.protectionSpace</span><span class="variable">.serverTrust</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengeRejectProtectionSpace</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NSURLAuthenticationChallenge</code> 表示一个认证的挑战，提供了关于这次认证的全部信息。它有一个非常重要的属性 <code>protectionSpace</code>，这里保存了需要认证的保护空间, 每一个 <code>NSURLProtectionSpace</code> 对象都保存了主机地址，端口和认证方法等重要信息。</p>
<p>在上面的方法中，如果保护空间中的认证方法为 <code>NSURLAuthenticationMethodServerTrust</code>，那么就会使用在上一小节中提到的方法 <code>- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code> 对保护空间中的 <code>serverTrust</code> 以及域名 <code>host</code> 进行认证</p>
<p>根据认证的结果，会在 <code>completionHandler</code> 中传入不同的 <code>disposition</code> 和 <code>credential</code> 参数。</p>
<hr>
<h2 id="小结">小结</h2><ul>
<li><code>AFSecurityPolicy</code> 同样也作为一个<strong>即插即用</strong>的模块，在 AFNetworking 中作为验证 HTTPS 证书是否有效的模块存在，在 iOS 对 HTTPS 日渐重视的今天，在我看来，使用 HTTPS 会成为今后 API 开发的标配。</li>
</ul>
<hr>
<h2 id="总结">总结</h2><p>到这里，AFNetworking 源码阅读之旅（UIKit+AFNetworking 除外）就要告一段落了，定有许多不足与遗憾。不过没关系，就让我们去实践中将理论升华，想必到时候一定会有一番新的体会。</p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/AFNetworking/%E9%AA%8C%E8%AF%81%20HTTPS%20%E8%AF%B7%E6%B1%82%E7%9A%84%E8%AF%81%E4%B9%A6%EF%BC%88%E4%BA%94%EF%BC%89.md" target="_blank" rel="external">验证 HTTPS 请求的证书（五）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>自 iOS 9 发布之后，由于新特性 <a href="https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html">App Transport Security</a> 的引入，在默认行为下是不能发送 HTTP 请求的。很多网站都在转用 HTTPS，而 <code>AFNetworking</code> 中的 <code>AFSecurityPolicy</code> 就是为了阻止<a href="https://zh.wikipedia.org/zh/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击</a>，以及其它漏洞的工具。</p>
<p><code>AFSecurityPolicy</code> 主要作用就是验证 HTTPS 请求的证书是否有效，如果应用中有一些敏感信息或者涉及交易信息，一定要使用 HTTPS 来保证交易或者用户信息的安全。</p>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://itangqi.me/tags/AFNetworking/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="Source Code" scheme="http://itangqi.me/tags/Source-Code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 3.0 源码阅读笔记（六）]]></title>
    <link href="http://itangqi.me/2016/05/17/the-notes-of-learning-afnetworking-six/"/>
    <id>http://itangqi.me/2016/05/17/the-notes-of-learning-afnetworking-six/</id>
    <published>2016-05-16T16:00:00.000Z</published>
    <updated>2016-05-28T07:41:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p><code>AFNetworkReachabilityManager</code> 是对 <code>SystemConfiguration</code> 模块的封装，苹果的文档中也有一个类似的项目 <a href="https://developer.apple.com/library/ios/samplecode/reachability/" target="_blank" rel="external">Reachability</a> 这里对网络状态的监控跟苹果官方的实现几乎是完全相同的。</p>
<p>同样在 GitHub 上有一个类似的项目叫做 <a href="https://github.com/tonymillion/Reachability" target="_blank" rel="external">Reachability</a> 不过这个项目<strong>由于命名的原因可能会在审核时被拒绝</strong>。</p>
<p>无论是 <code>AFNetworkReachabilityManager</code>，苹果官方的项目或者说 GitHub 上的 Reachability，它们的实现都是类似的，而在这里我们会以 <code>AFNetworking</code> 中的 <code>AFNetworkReachabilityManager</code> 为例来说明在 iOS 开发中，我们是怎样监控网络状态的。</p>
<a id="more"></a>
<hr>
<h2 id="AFNetworkReachabilityManager_的使用和实现">AFNetworkReachabilityManager 的使用和实现</h2><p><code>AFNetworkReachabilityManager</code> 的使用还是非常简单的，只需要三个步骤，就基本可以完成对网络状态的监控：</p>
<ol>
<li><a href="#init">初始化 <code>AFNetworkReachabilityManager</code></a></li>
<li><a href="#monitor">调用 <code>startMonitoring</code> 方法开始对网络状态进行监控</a></li>
<li><a href="#block">设置 <code>networkReachabilityStatusBlock</code> 在每次网络状态改变时, 调用这个 block</a></li>
</ol>
<h3 id="初始化_AFNetworkReachabilityManager"><a id="init"></a>初始化 AFNetworkReachabilityManager</h3><p>在初始化方法中，使用 <code>SCNetworkReachabilityCreateWithAddress</code> 或者 <code>SCNetworkReachabilityCreateWithName</code> 生成一个 <code>SCNetworkReachabilityRef</code> 的引用：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)managerForDomain:(<span class="built_in">NSString</span> *)domain &#123;</span><br><span class="line">    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(k<span class="built_in">CFAllocatorDefault</span>, [domain UTF8String]);</span><br><span class="line"></span><br><span class="line">    AFNetworkReachabilityManager *manager = [[<span class="keyword">self</span> alloc] initWithReachability:reachability];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)managerForAddress:(<span class="keyword">const</span> <span class="keyword">void</span> *)address &#123;</span><br><span class="line">    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithAddress(k<span class="built_in">CFAllocatorDefault</span>, (<span class="keyword">const</span> <span class="keyword">struct</span> sockaddr *)address);</span><br><span class="line">    AFNetworkReachabilityManager *manager = [[<span class="keyword">self</span> alloc] initWithReachability:reachability];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>这两个方法会通过一个<strong>域名</strong>或者一个 <code>sockaddr_in</code> 的指针生成一个 <code>SCNetworkReachabilityRef</code></li>
<li>调用 <code>- [AFNetworkReachabilityManager initWithReachability:]</code> 将生成的 <code>SCNetworkReachabilityRef</code> 引用传给 <code>networkReachability</code></li>
<li>设置一个默认的 <code>networkReachabilityStatus</code></li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.networkReachability</span> = <span class="built_in">CFBridgingRelease</span>(reachability);</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.networkReachabilityStatus</span> = AFNetworkReachabilityStatusUnknown;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当调用 <code>CFBridgingRelease(reachability)</code> 后，会把 <code>reachability</code> 桥接成一个 NSObject 对象赋值给 <code>self.networkReachability</code>，然后释放原来的 CoreFoundation 对象。</p>
</blockquote>
<h3 id="监控网络状态"><a id="monitor"></a>监控网络状态</h3><p>在初始化 <code>AFNetworkReachabilityManager</code> 后，会调用 <code>startMonitoring</code> 方法开始监控网络状态：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)startMonitoring &#123;</span><br><span class="line">    <span class="comment">// 1. 先调用 `- stopMonitoring` 方法，如果之前设置过对网络状态的监听，使用 `SCNetworkReachabilityUnscheduleFromRunLoop` 方法取消之前在 Main Runloop 中的监听</span></span><br><span class="line">    [<span class="keyword">self</span> stopMonitoring];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.networkReachability</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 2. 创建一个在每次网络状态改变时的回调</span></span><br><span class="line">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">        strongSelf<span class="variable">.networkReachabilityStatus</span> = status;</span><br><span class="line">        <span class="keyword">if</span> (strongSelf<span class="variable">.networkReachabilityStatusBlock</span>) &#123;</span><br><span class="line">            strongSelf<span class="variable">.networkReachabilityStatusBlock</span>(status);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> networkReachability = <span class="keyword">self</span><span class="variable">.networkReachability</span>;</span><br><span class="line">    <span class="comment">// 3. 创建一个 `SCNetworkReachabilityContext`，其中的 `callback` 就是上一步中的创建的 block 对象</span></span><br><span class="line">    SCNetworkReachabilityContext context = &#123;<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="comment">// 4. 当目标的网络状态改变时，会调用传入的回调</span></span><br><span class="line">    SCNetworkReachabilitySetCallback((__bridge SCNetworkReachabilityRef)networkReachability, AFNetworkReachabilityCallback, &amp;context);</span><br><span class="line">    <span class="comment">// 5. 在 Main Runloop 中对应的模式开始监控网络状态</span></span><br><span class="line">    SCNetworkReachabilityScheduleWithRunLoop((__bridge SCNetworkReachabilityRef)networkReachability, <span class="built_in">CFRunLoopGetMain</span>(), k<span class="built_in">CFRunLoopCommonModes</span>);</span><br><span class="line">    <span class="comment">// 6. 获取当前的网络状态，调用 callback</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>),^&#123;</span><br><span class="line">        SCNetworkReachabilityFlags flags;</span><br><span class="line">        <span class="keyword">if</span> (SCNetworkReachabilityGetFlags((__bridge SCNetworkReachabilityRef)networkReachability, &amp;flags)) &#123;</span><br><span class="line">            AFPostReachabilityStatusChange(flags, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1. 关于 <code>AFNetworkReachabilityStatus</code></strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, AFNetworkReachabilityStatus) &#123;</span><br><span class="line">    AFNetworkReachabilityStatusUnknown          = -<span class="number">1</span>,</span><br><span class="line">    AFNetworkReachabilityStatusNotReachable     = <span class="number">0</span>,</span><br><span class="line">    AFNetworkReachabilityStatusReachableViaWWAN = <span class="number">1</span>,</span><br><span class="line">    AFNetworkReachabilityStatusReachableViaWiFi = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2. 关于 <code>SCNetworkReachabilityContext</code></strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 SCNetworkReachabilityContext 结构体时，需要调用 SCDynamicStore 的创建函数，而此创建函数会根据 version 来创建出不同的结构体，SCNetworkReachabilityContext 对应的 version 是 0</span></span><br><span class="line">    <span class="built_in">CFIndex</span>		version;</span><br><span class="line">    <span class="comment">// 下面两个block（release 和 retain）的参数就是 info，此处表示的是网络状态处理的回调函数</span></span><br><span class="line">    <span class="keyword">void</span> *		__nullable info;</span><br><span class="line">    <span class="comment">// 该 retain block 用于对 info 进行 retain，下面那个 AFNetworkReachabilityRetainCallback 核心就是调用了 Block_copy（用于 retain 一个 block 函数，即在堆空间新建或直接引用一个 block 拷贝）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>	* __nonnull (* __nullable retain)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="comment">// 该 release block 用于对 info 进行 release，下面那个 AFNetworkReachabilityReleaseCallback 核心就是调用了 Block_release（用于 release 一个 block 函数，即将 block 从堆空间移除或移除相应引用）</span></span><br><span class="line">    <span class="keyword">void</span>		(* __nullable release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">    <span class="comment">// 提供 info 的 description，此处调用为 NULL</span></span><br><span class="line">    <span class="built_in">CFStringRef</span>	__nonnull (* __nullable copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">&#125; SCNetworkReachabilityContext;</span><br></pre></td></tr></table></figure>
<p>在下一节中会介绍上面所提到的一些 C 函数以及各种回调。</p>
<h3 id="设置_networkReachabilityStatusBlock_以及回调"><a id="block"></a>设置 networkReachabilityStatusBlock 以及回调</h3><p>在 Main Runloop 中对网络状态进行监控之后，在每次网络状态改变，就会调用 <code>AFNetworkReachabilityCallback</code> 函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> AFNetworkReachabilityCallback(SCNetworkReachabilityRef __unused target, SCNetworkReachabilityFlags flags, <span class="keyword">void</span> *info) &#123;</span><br><span class="line">    AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会从 <code>info</code> 中取出之前存在 <code>context</code> 中的 <code>AFNetworkReachabilityStatusBlock</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">    strongSelf<span class="variable">.networkReachabilityStatus</span> = status;</span><br><span class="line">    <span class="keyword">if</span> (strongSelf<span class="variable">.networkReachabilityStatusBlock</span>) &#123;</span><br><span class="line">        strongSelf<span class="variable">.networkReachabilityStatusBlock</span>(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>取出这个 block 之后，传入 <code>AFPostReachabilityStatusChange</code> 函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block) &#123;</span><br><span class="line">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (block) &#123;</span><br><span class="line">            block(status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSNotificationCenter</span> *notificationCenter = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *userInfo = @&#123; AFNetworkingReachabilityNotificationStatusItem: @(status) &#125;;</span><br><span class="line">        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:<span class="literal">nil</span> userInfo:userInfo];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>调用 <code>AFNetworkReachabilityStatusForFlags</code> 获取当前的网络可达性状态</li>
<li><strong>在主线程中异步执行</strong>上面传入的 <code>callback</code> block（设置 <code>self</code> 的网络状态，调用 <code>networkReachabilityStatusBlock</code>）</li>
<li>发送 <code>AFNetworkingReachabilityDidChangeNotification</code> 通知.</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(SCNetworkReachabilityFlags flags) &#123;</span><br><span class="line">    <span class="comment">// 该网络地址可达</span></span><br><span class="line">    <span class="built_in">BOOL</span> isReachable = ((flags &amp; kSCNetworkReachabilityFlagsReachable) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 该网络地址虽然可达，但是需要先建立一个 connection</span></span><br><span class="line">    <span class="built_in">BOOL</span> needsConnection = ((flags &amp; kSCNetworkReachabilityFlagsConnectionRequired) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 该网络虽然也需要先建立一个 connection，但是它是可以自动去 connect 的</span></span><br><span class="line">    <span class="built_in">BOOL</span> canConnectionAutomatically = (((flags &amp; kSCNetworkReachabilityFlagsConnectionOnDemand ) != <span class="number">0</span>) || ((flags &amp; kSCNetworkReachabilityFlagsConnectionOnTraffic) != <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 不需要用户交互，就可以 connect 上（用户交互一般指的是提供网络的账户和密码）</span></span><br><span class="line">    <span class="built_in">BOOL</span> canConnectWithoutUserInteraction = (canConnectionAutomatically &amp;&amp; (flags &amp; kSCNetworkReachabilityFlagsInterventionRequired) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果 isReachable==YES，那么就需要判断是不是得先建立一个 connection，如果需要，那就认为不可达，或者虽然需要先建立一个 connection，但是不需要用户交互，那么认为也是可达的</span></span><br><span class="line">    <span class="built_in">BOOL</span> isNetworkReachable = (isReachable &amp;&amp; (!needsConnection || canConnectWithoutUserInteraction));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  AFNetworkReachabilityStatus 就四种状态 Unknown、NotReachable、ReachableViaWWAN、ReachableViaWiFi，这四种状态字面意思很好理解，这里就不赘述了</span></span><br><span class="line">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusUnknown;</span><br><span class="line">    <span class="keyword">if</span> (isNetworkReachable == <span class="literal">NO</span>) &#123;</span><br><span class="line">        status = AFNetworkReachabilityStatusNotReachable;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#if	TARGET_OS_IPHONE</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; kSCNetworkReachabilityFlagsIsWWAN) != <span class="number">0</span>) &#123;</span><br><span class="line">        status = AFNetworkReachabilityStatusReachableViaWWAN;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        status = AFNetworkReachabilityStatusReachableViaWiFi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>flags</code> 是一个 <code>SCNetworkReachabilityFlags</code>，它的不同位代表了不同的网络可达性状态，通过 <code>flags</code> 的位操作，获取当前的状态信息 <code>AFNetworkReachabilityStatus</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(uint32_t, SCNetworkReachabilityFlags) &#123;</span><br><span class="line">    kSCNetworkReachabilityFlagsTransientConnection = <span class="number">1</span>&lt;&lt;<span class="number">0</span>,</span><br><span class="line">    kSCNetworkReachabilityFlagsReachable = <span class="number">1</span>&lt;&lt;<span class="number">1</span>,</span><br><span class="line">    kSCNetworkReachabilityFlagsConnectionRequired = <span class="number">1</span>&lt;&lt;<span class="number">2</span>,</span><br><span class="line">    kSCNetworkReachabilityFlagsConnectionOnTraffic = <span class="number">1</span>&lt;&lt;<span class="number">3</span>,</span><br><span class="line">    kSCNetworkReachabilityFlagsInterventionRequired = <span class="number">1</span>&lt;&lt;<span class="number">4</span>,</span><br><span class="line">    kSCNetworkReachabilityFlagsConnectionOnDemand = <span class="number">1</span>&lt;&lt;<span class="number">5</span>, <span class="comment">// __OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_3_0)</span></span><br><span class="line">    kSCNetworkReachabilityFlagsIsLocalAddress = <span class="number">1</span>&lt;&lt;<span class="number">16</span>,</span><br><span class="line">    kSCNetworkReachabilityFlagsIsDirect = <span class="number">1</span>&lt;&lt;<span class="number">17</span>,</span><br><span class="line"><span class="preprocessor">#if  TARGET_OS_IPHONE</span></span><br><span class="line">    kSCNetworkReachabilityFlagsIsWWAN = <span class="number">1</span>&lt;&lt;<span class="number">18</span>,</span><br><span class="line"><span class="preprocessor">#endif  // TARGET_OS_IPHONE</span></span><br><span class="line"></span><br><span class="line">    kSCNetworkReachabilityFlagsConnectionAutomatic = kSCNetworkReachabilityFlagsConnectionOnTraffic</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里就是在 <code>SystemConfiguration</code> 中定义的全部的网络状态的标志位。</p>
<hr>
<h2 id="与_AFNetworking_协作">与 AFNetworking 协作</h2><p>其实 <code>AFNetworkReachabilityManager</code> 与 <code>AFNetworking</code> 整个框架并没有太多的耦合。正相反，它在整个框架中作为一个<strong>即插即用</strong>的类使用，每一个 <code>AFURLSessionManager</code> 都会持有一个 <code>AFNetworkReachabilityManager</code> 的实例。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.reachabilityManager</span> = [AFNetworkReachabilityManager sharedManager];</span><br></pre></td></tr></table></figure>
<p>这是整个框架中除了 <code>AFNetworkReachabilityManager.h/m</code> 文件，<strong>唯一一个</strong>引用到这个类的地方。</p>
<hr>
<h2 id="总结">总结</h2><ul>
<li><code>AFNetworkReachabilityManager</code> 实际上只是对底层 <code>SystemConfiguration</code> 库中的 C 函数封装的类（类似于 GCD），它为我们隐藏了 C 语言的实现，提供了统一且简洁的 Objective-C 语言接口</li>
<li>它是 <code>AFNetworking</code> 中一个即插即用的模块</li>
</ul>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/AFNetworking/AFNetworkReachabilityManager%20%E7%9B%91%E6%8E%A7%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%EF%BC%88%E5%9B%9B%EF%BC%89.md" target="_blank" rel="external">AFNetworkReachabilityManager 监控网络状态（四）</a></li>
<li><a href="http://www.cnblogs.com/polobymulberry/p/5174298.html" target="_blank" rel="external">【原】AFNetworking源码阅读（六）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p><code>AFNetworkReachabilityManager</code> 是对 <code>SystemConfiguration</code> 模块的封装，苹果的文档中也有一个类似的项目 <a href="https://developer.apple.com/library/ios/samplecode/reachability/">Reachability</a> 这里对网络状态的监控跟苹果官方的实现几乎是完全相同的。</p>
<p>同样在 GitHub 上有一个类似的项目叫做 <a href="https://github.com/tonymillion/Reachability">Reachability</a> 不过这个项目<strong>由于命名的原因可能会在审核时被拒绝</strong>。</p>
<p>无论是 <code>AFNetworkReachabilityManager</code>，苹果官方的项目或者说 GitHub 上的 Reachability，它们的实现都是类似的，而在这里我们会以 <code>AFNetworking</code> 中的 <code>AFNetworkReachabilityManager</code> 为例来说明在 iOS 开发中，我们是怎样监控网络状态的。</p>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://itangqi.me/tags/AFNetworking/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="Source Code" scheme="http://itangqi.me/tags/Source-Code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 3.0 源码阅读笔记（五）]]></title>
    <link href="http://itangqi.me/2016/05/15/the-notes-of-learning-afnetworking-five/"/>
    <id>http://itangqi.me/2016/05/15/the-notes-of-learning-afnetworking-five/</id>
    <published>2016-05-14T16:00:00.000Z</published>
    <updated>2016-05-28T07:41:22.000Z</updated>
    <content type="html"><![CDATA[<h2 id="AFURLRequestSerialization">AFURLRequestSerialization</h2><p><code>AFURLRequestSerialization</code> 定义为协议，其主要工作是对发出的 HTTP 请求进行处理：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLRequestSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (nullable <span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(nullable <span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>遵循该协议的类同时也要遵循 NSObject、NSSecureCoding 和 NSCopying 这三个协议，以实现 Objective-C 对象的基本行为、安全编码以及拷贝。</p>
<a id="more"></a>
<h3 id="AFHTTPRequestSerializer">AFHTTPRequestSerializer</h3><p>而在 <code>AFURLRequestSerialization</code> 模块中，最为重要的类便是 <code>AFHTTPRequestSerializer</code>，其主要作用为：</p>
<ol>
<li>处理查询的 URL 参数</li>
<li>设置 HTTP 头部字段</li>
<li>设置请求的属性</li>
<li>分块上传</li>
</ol>
<blockquote>
<p>这篇文章不会对其中涉及分块上传的部分进行分析，因为其中涉及到了多个类的功能，比较复杂，如果有兴趣可以研究一下。</p>
</blockquote>
<h3 id="处理查询参数">处理查询参数</h3><p>处理查询参数这部分主要是通过 <code>AFQueryStringPair</code> 还有一些 <strong>C 函数</strong>来完成的，这个类有两个属性 <code>field</code> 和 <code>value</code> 对应 HTTP 请求的查询 URL 中的参数。</p>
<p>我们来看初始化方法，其中的 <code>- (NSString *)URLEncodedStringValue</code> 方法会返回 <code>key=value</code> 这种格式，同时使用 <code>AFPercentEscapedStringFromString</code> 函数来对 <code>field</code> 和 <code>value</code> 进行处理，将其中的 <code>:#[]@!$&amp;&#39;()*+,;=</code> 等字符转换为百分号表示的形式：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithField:(<span class="keyword">id</span>)field value:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.field</span> = field;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.value</span> = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)URLEncodedStringValue &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span><span class="variable">.value</span> || [<span class="keyword">self</span><span class="variable">.value</span> isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFPercentEscapedStringFromString([<span class="keyword">self</span><span class="variable">.field</span> description]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@=%@"</span>, AFPercentEscapedStringFromString([<span class="keyword">self</span><span class="variable">.field</span> description]), AFPercentEscapedStringFromString([<span class="keyword">self</span><span class="variable">.value</span> description])];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一部分代码还负责返回查询参数，将 <code>AFQueryStringPair</code> 或者 <code>key</code> <code>value</code> 转换为以下这种形式：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username = dravenss&amp;password=<span class="number">123456</span>&amp;hello<span class="string">[world]</span>=helloworld</span><br></pre></td></tr></table></figure>
<p>它的实现主要依赖于一个递归函数 <code>AFQueryStringPairsFromKeyAndValue</code>，如果当前的 <code>value</code> 是一个集合类型的话，那么它就会不断地递归调用自己：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromKeyAndValue(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutableQueryStringComponents = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSSortDescriptor</span> *sortDescriptor = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@"description"</span> ascending:<span class="literal">YES</span> selector:<span class="keyword">@selector</span>(compare:)];	 </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后返回一个数组</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    username = draveness,</span><br><span class="line">    password = <span class="number">123456</span>,</span><br><span class="line">    hello[world] = helloworld</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>得到这个数组之后就会调用 <code>AFQueryStringFromParameters</code> 使用 <code>&amp;</code> 来拼接它们：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * AFQueryStringFromParameters(<span class="built_in">NSDictionary</span> *parameters) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutablePairs = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (AFQueryStringPair *pair <span class="keyword">in</span> AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [mutablePairs componentsJoinedByString:<span class="string">@"&amp;"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置_HTTP_头部字段">设置 HTTP 头部字段</h3><p><code>AFHTTPRequestSerializer</code> 在头文件中提供了一些属性方便我们设置 HTTP 头部字段。同时，在类的内部，它提供了 <code>- [AFHTTPRequestSerializer setValue:forHTTPHeaderField:]</code> 方法来设置 HTTP 头部，其实它的实现都是基于一个名为 <code>mutableHTTPRequestHeaders</code> 的属性的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="built_in">NSString</span> *)value</span><br><span class="line">forHTTPHeaderField:(<span class="built_in">NSString</span> *)field</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mutableHTTPRequestHeaders</span> setValue:value forKey:field];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)valueForHTTPHeaderField:(<span class="built_in">NSString</span> *)field &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span><span class="variable">.mutableHTTPRequestHeaders</span> valueForKey:field];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在设置 HTTP 头部字段时，都会存储到这个可变字典中。而当真正使用时，会用 <code>HTTPRequestHeaders</code> 这个方法，来获取对应版本的不可变字典：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDictionary</span> *)HTTPRequestHeaders &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:<span class="keyword">self</span><span class="variable">.mutableHTTPRequestHeaders</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了这里，可以来分析一下，这个类是如何设置一些我们平时常用的头部字段的。首先是 <code>User-Agent</code>，在 <code>AFHTTPRequestSerializer</code> 刚刚初始化时，就会根据当前编译的平台生成一个 <code>userAgent</code> 字符串：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userAgent = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@/%@ (%@; iOS %@; Scale/%0.2f)"</span>, [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)k<span class="built_in">CFBundleExecutableKey</span>] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)k<span class="built_in">CFBundleIdentifierKey</span>], [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][<span class="string">@"CFBundleShortVersionString"</span>] ?: [[<span class="built_in">NSBundle</span> mainBundle] infoDictionary][(__bridge <span class="built_in">NSString</span> *)k<span class="built_in">CFBundleVersionKey</span>], [[<span class="built_in">UIDevice</span> currentDevice] model], [[<span class="built_in">UIDevice</span> currentDevice] systemVersion], [[<span class="built_in">UIScreen</span> mainScreen] scale]];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> setValue:userAgent forHTTPHeaderField:<span class="string">@"User-Agent"</span>];</span><br></pre></td></tr></table></figure>
<p>设置验证字段时，可以使用 <code>- [AFHTTPRequestSerializer setAuthorizationHeaderFieldWithUsername:password:]</code> 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAuthorizationHeaderFieldWithUsername:(<span class="built_in">NSString</span> *)username</span><br><span class="line">                                       password:(<span class="built_in">NSString</span> *)password</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSData</span> *basicAuthCredentials = [[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@:%@"</span>, username, password] dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *base64AuthCredentials = [basicAuthCredentials base64EncodedStringWithOptions:(<span class="built_in">NSDataBase64EncodingOptions</span>)<span class="number">0</span>];</span><br><span class="line">    [<span class="keyword">self</span> setValue:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Basic %@"</span>, base64AuthCredentials] forHTTPHeaderField:<span class="string">@"Authorization"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置请求的属性">设置请求的属性</h3><p>还有一些 <code>NSURLRequest</code> 的属性是通过另一种方式来设置的，AFNetworking 为这些功能提供了接口：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> allowsCellularAccess;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSURLRequestCachePolicy</span> cachePolicy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> HTTPShouldHandleCookies;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> HTTPShouldUsePipelining;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSURLRequestNetworkServiceType</span> networkServiceType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> timeoutInterval;</span><br></pre></td></tr></table></figure>
<p>它们都会通过 <code>AFHTTPRequestSerializerObservedKeyPaths</code> 的调用而返回：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFHTTPRequestSerializerObservedKeyPaths() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSArray</span> *_AFHTTPRequestSerializerObservedKeyPaths = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _AFHTTPRequestSerializerObservedKeyPaths = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(allowsCellularAccess)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(cachePolicy)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldHandleCookies)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldUsePipelining)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(networkServiceType)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(timeoutInterval))];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _AFHTTPRequestSerializerObservedKeyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这些属性被设置时，会触发 KVO，然后将新的属性存储在一个名为 <code>mutableObservedChangedKeyPaths</code> 的字典中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(__unused <span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">                       context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == AFHTTPRequestSerializerObserverContext) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeNewKey</span>] isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.mutableObservedChangedKeyPaths</span> removeObject:keyPath];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.mutableObservedChangedKeyPaths</span> addObject:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后会在生成 <code>NSURLRequest</code> 的时候设置这些属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class="line">mutableRequest<span class="variable">.HTTPMethod</span> = method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.mutableObservedChangedKeyPaths</span> containsObject:keyPath]) &#123;</span><br><span class="line">        [mutableRequest setValue:[<span class="keyword">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这个方法的的具体实现会在下一节中介绍。</p>
<h3 id="工作流程">工作流程</h3><p><code>AFHTTPRequestSerializer</code> 会在 <code>AHHTTPSessionManager</code> 初始化时一并初始化，这时它会根据当前系统环境预设置一些 HTTP 头部字段 <code>Accept-Language</code> <code>User-Agent</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.stringEncoding</span> = <span class="built_in">NSUTF8StringEncoding</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mutableHTTPRequestHeaders</span> = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#1: 设置接收语言，用户代理，略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// HTTP Method Definitions; see http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.HTTPMethodsEncodingParametersInURI</span> = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"GET"</span>, <span class="string">@"HEAD"</span>, <span class="string">@"DELETE"</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mutableObservedChangedKeyPaths</span> = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="built_in">NSSelectorFromString</span>(keyPath)]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:keyPath options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:AFHTTPRequestSerializerObserverContext];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时它还对一些属性进行 KVO，确保它们在改变后更新 <code>NSMutableURLRequest</code> 中对应的属性。</p>
<p>在初始化之后，如果调用了 <code>- [AFHTTPSessionManager dataTaskWithHTTPMethod:URLString:parameters:uploadProgress:downloadProgress:success:failure:]</code>，就会进入 <code>AFHTTPRequestSerializer</code> 的这一方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                     error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(method);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(URLString);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</span><br><span class="line">    <span class="comment">// 1. 对参数进行检查</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(url);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class="line">    <span class="comment">// 2. 设置 HTTP 方法</span></span><br><span class="line">    mutableRequest<span class="variable">.HTTPMethod</span> = method;</span><br><span class="line">    <span class="comment">// 3. 通过 `mutableObservedChangedKeyPaths` 字典设置 `NSMutableURLRequest` 的属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.mutableObservedChangedKeyPaths</span> containsObject:keyPath]) &#123;</span><br><span class="line">            [mutableRequest setValue:[<span class="keyword">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 HTTP 头部字段和查询参数</span></span><br><span class="line">    mutableRequest = [[<span class="keyword">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>- [AFHTTPRequestSerializer  requestBySerializingRequest:withParameters:error:]</code> 方法主要做了以下几件事情：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class="line">    <span class="comment">// 1. 通过 `HTTPRequestHeaders` 字典设置头部字段</span></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.HTTPRequestHeaders</span> enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> field, <span class="keyword">id</span> value, <span class="built_in">BOOL</span> * __unused stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *query = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.queryStringSerialization</span>) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError;</span><br><span class="line">            query = <span class="keyword">self</span><span class="variable">.queryStringSerialization</span>(request, parameters, &amp;serializationError);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    *error = serializationError;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">self</span><span class="variable">.queryStringSerializationStyle</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">                    <span class="comment">// 2. 调用 `AFQueryStringFromParameters` 将参数转换为查询参数</span></span><br><span class="line">                    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 将 parameters 添加到 URL 或者 HTTP body 中</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.HTTPMethodsEncodingParametersInURI</span> containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query) &#123;</span><br><span class="line">            mutableRequest<span class="variable">.URL</span> = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest<span class="variable">.URL</span> absoluteString] stringByAppendingFormat:mutableRequest<span class="variable">.URL</span><span class="variable">.query</span> ? <span class="string">@"&amp;%@"</span> : <span class="string">@"?%@"</span>, query]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class="line">        <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">            query = <span class="string">@""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@"Content-Type"</span>]) &#123;</span><br><span class="line">            [mutableRequest setValue:<span class="string">@"application/x-www-form-urlencoded"</span> forHTTPHeaderField:<span class="string">@"Content-Type"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span><span class="variable">.stringEncoding</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 将 parameters 添加到 URL 或者 HTTP body 中</span></span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="小结">小结</h2><ul>
<li><code>AFURLResponseSerialization</code> 负责对返回的数据进行序列化</li>
<li><code>AFURLRequestSerialization</code> 负责生成 <code>NSMutableURLRequest</code>，为请求设置 HTTP 头部，管理发出的请求</li>
</ul>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/AFNetworking/%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%20AFURLSerialization%EF%BC%88%E4%B8%89%EF%BC%89.md" target="_blank" rel="external">处理请求和响应 AFURLSerialization（三）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="AFURLRequestSerialization">AFURLRequestSerialization</h2><p><code>AFURLRequestSerialization</code> 定义为协议，其主要工作是对发出的 HTTP 请求进行处理：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLRequestSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (nullable <span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(nullable <span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>遵循该协议的类同时也要遵循 NSObject、NSSecureCoding 和 NSCopying 这三个协议，以实现 Objective-C 对象的基本行为、安全编码以及拷贝。</p>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://itangqi.me/tags/AFNetworking/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="Source Code" scheme="http://itangqi.me/tags/Source-Code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 3.0 源码阅读笔记（四）]]></title>
    <link href="http://itangqi.me/2016/05/13/the-notes-of-learning-afnetworking-four/"/>
    <id>http://itangqi.me/2016/05/13/the-notes-of-learning-afnetworking-four/</id>
    <published>2016-05-12T16:00:00.000Z</published>
    <updated>2016-05-28T07:40:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>通过前面的文章，我们已经知道 <code>AFNetworking</code> 是对 <code>NSURLSession</code> 的封装，也了解它是如何发出请求的，在这里我们<strong>对发出请求以及接收响应的过程</strong>进行序列化，这涉及到两个<strong>模块</strong>：</p>
<ul>
<li><a href="#afurlresponseserialization">AFURLResponseSerialization</a></li>
<li><a href="#afurlrequestserialization">AFURLRequestSerialization</a></li>
</ul>
<p>前者是处理响应的模块，将请求返回的数据解析成对应的格式。而后者的主要作用是修改请求（主要是 HTTP 请求）的头部，提供了一些语义明确的接口设置 HTTP 头部字段。</p>
<p>我们首先会对 <code>AFURLResponseSerialization</code> 进行简单的介绍，因为这个模块使用在 <code>AFURLSessionManager</code> 也就是核心类中，而后者 <code>AFURLRequestSerialization</code> 主要用于 <code>AFHTTPSessionManager</code> 中，因为它主要用于<strong>修改 HTTP 头部</strong>。</p>
<a id="more"></a>
<hr>
<h2 id="AFURLResponseSerialization">AFURLResponseSerialization</h2><p>在了解模块中类的具体实现之前，先看一下模块的结构图：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-afnetworking-four-02.png" alt=""></p>
<p><code>AFURLResponseSerialization</code> 定义为协议，且协议的内容非常简单，只有一个必须实现的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLResponseSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (nullable <span class="keyword">id</span>)responseObjectForResponse:(nullable <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(nullable <span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>遵循该协议的类同时也要遵循 NSObject、NSSecureCoding 和 NSCopying 这三个协议，以实现 Objective-C 对象的基本行为、安全编码以及拷贝。</p>
<p><strong>注</strong>：</p>
<ol>
<li>模块中的所有类都遵循 <code>AFURLResponseSerialization</code> 协议</li>
<li><code>AFHTTPResponseSerializer</code> 为模块中最终要的根类</li>
</ol>
<h3 id="AFHTTPResponseSerializer">AFHTTPResponseSerializer</h3><p>下面我们对模块中最重要的根类，也就是 <code>AFHTTPResponseSerializer</code> 的实现进行分析。它是在 <code>AFURLResponseSerialization</code> 模块中最基本的类（因为 <code>AFURLResponseSerialization</code> 只是一个协议）</p>
<h4 id="初始化">初始化</h4><p>首先，依然从实例化方法入手：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)serializer &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.stringEncoding</span> = <span class="built_in">NSUTF8StringEncoding</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.acceptableStatusCodes</span> = [<span class="built_in">NSIndexSet</span> indexSetWithIndexesInRange:<span class="built_in">NSMakeRange</span>(<span class="number">200</span>, <span class="number">100</span>)];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.acceptableContentTypes</span> = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是对 HTTP 响应进行序列化，所以这里设置了 <code>stringEncoding</code> 为 <code>NSUTF8StringEncoding</code> 而且没有对接收的内容类型加以限制。</p>
<p>将 <code>acceptableStatusCodes</code> 设置为从 200 到 299 之间的状态码, 因为只有这些状态码表示<strong>获得了有效的响应</strong>。</p>
<p><strong>补充</strong>：<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="external">HTTP状态码</a></p>
<h4 id="验证响应的有效性">验证响应的有效性</h4><p><code>AFHTTPResponseSerializer</code> 中方法的实现最长，并且最重要的就是 <code>- [AFHTTPResponseSerializer validateResponse:data:error:]</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">                    data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                   error:(<span class="built_in">NSError</span> * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> responseIsValid = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">NSError</span> *validationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 简单的为空判断和类型判断，注意如果 response 为空或类型不对，反而 responseValid 为 YES</span></span><br><span class="line">    <span class="keyword">if</span> (response &amp;&amp; [response isKindOfClass:[<span class="built_in">NSHTTPURLResponse</span> class]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.acceptableContentTypes</span> &amp;&amp; ![<span class="keyword">self</span><span class="variable">.acceptableContentTypes</span> containsObject:[response MIMEType]]) &#123;</span><br><span class="line">truetruetrue<span class="preprocessor">#1: 返回内容类型无效</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.acceptableStatusCodes</span> &amp;&amp; ![<span class="keyword">self</span><span class="variable">.acceptableStatusCodes</span> containsIndex:(<span class="built_in">NSUInteger</span>)response<span class="variable">.statusCode</span>] &amp;&amp; [response URL]) &#123;</span><br><span class="line">truetruetrue<span class="preprocessor">#2: 返回状态码无效</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error &amp;&amp; !responseIsValid) &#123;</span><br><span class="line">        *error = validationError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseIsValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法根据在初始化方法中初始化的属性 <code>acceptableContentTypes</code> 和 <code>acceptableStatusCodes</code> 来判断当前响应是否有效。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([data length] &gt; <span class="number">0</span> &amp;&amp; [response URL]) &#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">                                              <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Request failed: unacceptable content-type: %@"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>), [response MIMEType]],</span><br><span class="line">                                              <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],</span><br><span class="line">                                              AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                                            &#125; mutableCopy];</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorCannotDecodeContentData</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">responseIsValid = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>
<p>其中第一、二部分的代码非常相似，出现错误时通过 <code>AFErrorWithUnderlyingError</code> 生成格式化之后的错误，最后设置 <code>responseIsValid</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">                                   <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@"Request failed: %@ (%ld)"</span>, <span class="string">@"AFNetworking"</span>, <span class="literal">nil</span>), [<span class="built_in">NSHTTPURLResponse</span> localizedStringForStatusCode:response<span class="variable">.statusCode</span>], (<span class="keyword">long</span>)response<span class="variable">.statusCode</span>],</span><br><span class="line">                                   <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],</span><br><span class="line">                                   AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                           &#125; mutableCopy];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (data) &#123;</span><br><span class="line">    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorBadServerResponse</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line"></span><br><span class="line">responseIsValid = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>
<p>第二部分的代码讲解略。</p>
<h4 id="协议的实现">协议的实现</h4><p>主要看 <code>AFURLResponseSerialization</code> 协议的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用上面的方法对响应进行验证，然后返回数据，并没有复杂的逻辑。</p>
<h3 id="AFJSONResponseSerializer">AFJSONResponseSerializer</h3><p>接下来，看一下 <code>AFJSONResponseSerializer</code> 这个继承自 <code>AFHTTPResponseSerializer</code> 类的实现。</p>
<p>初始化方法只是在调用父类的初始化方法之后更新了 <code>acceptableContentTypes</code> 属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.acceptableContentTypes</span> = [<span class="built_in">NSSet</span> setWithObjects:<span class="string">@"application/json"</span>, <span class="string">@"text/json"</span>, <span class="string">@"text/javascript"</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="协议的实现-1">协议的实现</h4><p>这个类中与父类差别最大的就是对 <code>AFURLResponseSerialization</code> 协议的实现。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="preprocessor">#1: 验证请求</span></span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#2: 解决一个由只包含一个空格的响应引起的 bug, 略</span></span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#3: 序列化 JSON</span></span><br><span class="line">true</span><br><span class="line">    <span class="preprocessor">#4: 移除 JSON 中的 null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>验证请求的有效性</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (![<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决一个空格引起的 bug，见 <a href="https://github.com/rails/rails/issues/1742" target="_blank" rel="external">https://github.com/rails/rails/issues/1742</a></p>
</li>
<li><p>序列化 JSON</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line">  <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">  <span class="comment">// Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</span></span><br><span class="line">  <span class="comment">// See https://github.com/rails/rails/issues/1742</span></span><br><span class="line">  <span class="built_in">BOOL</span> isSpace = [data isEqualToData:[<span class="built_in">NSData</span> dataWithBytes:<span class="string">" "</span> length:<span class="number">1</span>]];</span><br><span class="line">  <span class="keyword">if</span> (data<span class="variable">.length</span> &gt; <span class="number">0</span> &amp;&amp; !isSpace) &#123;</span><br><span class="line">      responseObject = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="keyword">self</span><span class="variable">.readingOptions</span> error:&amp;serializationError];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除 JSON 中的 null</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">true<span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.removesKeysWithNullValues</span> &amp;&amp; responseObject) &#123;</span><br><span class="line">true    responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span><span class="variable">.readingOptions</span>);</span><br><span class="line">true&#125;</span><br><span class="line">true``` </span><br><span class="line"></span><br><span class="line">其中移除 JSON 中 null 的函数 `AFJSONObjectByRemovingKeysWithNullValues` 是一个递归调用的函数：</span><br><span class="line"></span><br><span class="line">```objectivec</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> AFJSONObjectByRemovingKeysWithNullValues(<span class="keyword">id</span> JSONObject, <span class="built_in">NSJSONReadingOptions</span> readingOptions) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSArray</span> class]]) &#123;</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:[(<span class="built_in">NSArray</span> *)JSONObject count]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> value <span class="keyword">in</span> (<span class="built_in">NSArray</span> *)JSONObject) &#123;</span><br><span class="line">            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableArray : [<span class="built_in">NSArray</span> arrayWithArray:mutableArray];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSDictionary</span> class]]) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *mutableDictionary = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:JSONObject];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> &lt;<span class="built_in">NSCopying</span>&gt; key <span class="keyword">in</span> [(<span class="built_in">NSDictionary</span> *)JSONObject allKeys]) &#123;</span><br><span class="line">            <span class="keyword">id</span> value = (<span class="built_in">NSDictionary</span> *)JSONObject[key];</span><br><span class="line">            <span class="keyword">if</span> (!value || [value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">                [mutableDictionary removeObjectForKey:key];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> class]] || [value isKindOfClass:[<span class="built_in">NSDictionary</span> class]]) &#123;</span><br><span class="line">                mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableDictionary : [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:mutableDictionary];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JSONObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中移除 <code>null</code> 靠的就是 <code>[mutableDictionary removeObjectForKey:key]</code> 这一行代码。</p>
<p><strong>注</strong>：</p>
<ul>
<li><code>AFXMLParserResponseSerializer</code> 、 <code>AFXMLDocumentResponseSerializer</code> 、<code>AFPropertyListResponseSerializer</code> 、 AFImageResponseSerializer 及 <code>AFCompoundResponseSerializer</code> 将留给感兴趣的同学。</li>
</ul>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/AFNetworking/%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%20AFURLSerialization%EF%BC%88%E4%B8%89%EF%BC%89.md" target="_blank" rel="external">处理请求和响应 AFURLSerialization（三）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>通过前面的文章，我们已经知道 <code>AFNetworking</code> 是对 <code>NSURLSession</code> 的封装，也了解它是如何发出请求的，在这里我们<strong>对发出请求以及接收响应的过程</strong>进行序列化，这涉及到两个<strong>模块</strong>：</p>
<ul>
<li><a href="#afurlresponseserialization">AFURLResponseSerialization</a></li>
<li><a href="#afurlrequestserialization">AFURLRequestSerialization</a></li>
</ul>
<p>前者是处理响应的模块，将请求返回的数据解析成对应的格式。而后者的主要作用是修改请求（主要是 HTTP 请求）的头部，提供了一些语义明确的接口设置 HTTP 头部字段。</p>
<p>我们首先会对 <code>AFURLResponseSerialization</code> 进行简单的介绍，因为这个模块使用在 <code>AFURLSessionManager</code> 也就是核心类中，而后者 <code>AFURLRequestSerialization</code> 主要用于 <code>AFHTTPSessionManager</code> 中，因为它主要用于<strong>修改 HTTP 头部</strong>。</p>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://itangqi.me/tags/AFNetworking/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="Source Code" scheme="http://itangqi.me/tags/Source-Code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 3.0 源码阅读笔记（三）]]></title>
    <link href="http://itangqi.me/2016/05/09/the-notes-of-learning-afnetworking-three/"/>
    <id>http://itangqi.me/2016/05/09/the-notes-of-learning-afnetworking-three/</id>
    <published>2016-05-08T16:00:00.000Z</published>
    <updated>2016-05-28T07:39:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p><code>AFURLSessionManager</code> 绝对可以称得上是 AFNetworking 的核心，所以本文篇幅会相对长一点，但我保证绝对是满满的干货~</p>
<a id="more"></a>
<hr>
<h2 id="AFURLSessionManager">AFURLSessionManager</h2><p>首先，在 <code>AFURLSessionManager.h</code> 中关于 <code>AFURLSessionManager</code> 的概述：</p>
<blockquote>
<p><code>AFURLSessionManager</code> creates and manages an <code>NSURLSession</code> object based on a specified <code>NSURLSessionConfiguration</code> object, which conforms to <code>&lt;NSURLSessionTaskDelegate&gt;</code>, <code>&lt;NSURLSessionDataDelegate&gt;</code>, <code>&lt;NSURLSessionDownloadDelegate&gt;</code>, and <code>&lt;NSURLSessionDelegate&gt;</code>.</p>
</blockquote>
<p>最终可以归结为以下几点：</p>
<ol>
<li><a href="#NSURLSession">负责创建和管理 <code>NSURLSession</code></a></li>
<li><a href="#NSURLSessionTask">管理 <code>NSURLSessionTask</code></a></li>
<li><a href="#NSURLSessionDelegate">实现 <code>NSURLSessionDelegate</code> 等协议中的代理方法</a></li>
<li><a href="#AFURLSessionManagerTaskDelegate">使用 <code>AFURLSessionManagerTaskDelegate</code> 管理进度</a></li>
<li><a href="#_AFURLSessionTaskSwizzling">使用 <code>_AFURLSessionTaskSwizzling</code> 调剂方法</a></li>
<li><a href="#AFSecurityPolocy">引入 <code>AFSecurityPolicy</code> 保证请求的安全</a></li>
<li><a href="#AFNetworkReachabilityManager">引入 <code>AFNetworkReachabilityManager</code> 监控网络状态</a></li>
</ol>
<hr>
<h2 id="创建和管理_NSURLSession"><a id="NSURLSession"></a>创建和管理 <code>NSURLSession</code></h2><p>按惯例，我们由 <code>AFURLSessionManager</code> 的初始化方法：<code>- (instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</code> 进行展开：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">        configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.sessionConfiguration</span> = configuration;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.operationQueue</span> = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.operationQueue</span><span class="variable">.maxConcurrentOperationCount</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.session</span> = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span><span class="variable">.sessionConfiguration</span> delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span><span class="variable">.operationQueue</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.responseSerializer</span> = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.securityPolicy</span> = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#if !TARGET_OS_WATCH</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.reachabilityManager</span> = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mutableTaskDelegatesKeyedByTaskIdentifier</span> = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.lock</span> = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.lock</span><span class="variable">.name</span> = AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.session</span> getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDataTask</span> *task <span class="keyword">in</span> dataTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForDataTask:task uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionUploadTask</span> *uploadTask <span class="keyword">in</span> uploadTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSURLSessionDownloadTask</span> *downloadTask <span class="keyword">in</span> downloadTasks) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:<span class="literal">nil</span> destination:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要完成如下工作：</p>
<ol>
<li>初始化<strong>会话配置</strong>（NSURLSessionConfiguration），默认为 <code>defaultSessionConfiguration</code></li>
<li>设置相应的 <code>OperationQueue</code>，决定请求过程中的一系列事件在哪个 <code>OperationQueue</code> 回调，这里是设置了最大并发量为 1 的队列，也就相当于串行队列了。(AFNetworing 2.0 版本是设置了一条常驻线程来响应所有网络请求的 delegate 事件)</li>
<li>初始化会话（session），并设置会话的代理及代理队列，delegate 用来处理请求中的各种事件，可以设置为 nil 使用系统提供的 delegate，但是要想支持后台传输数据必须提供自定义实现的 delegate；另外，<code>NSURLSession</code> 对象是强引用了 delegate，如果程序最终没有调用  <code>invalidateAndCancel</code> 方法来 invalidate 该 session 的话，则会造成内存泄漏</li>
<li>初始化管理<strong>响应序列化</strong>（AFJSONResponseSerializer），<strong>安全认证</strong>（AFSecurityPolicy）以及<strong>监控网络状态</strong>（AFNetworkReachabilityManager）的实例</li>
<li>初始化保存 data task 的字典（mutableTaskDelegatesKeyedByTaskIdentifier）</li>
</ol>
<hr>
<h2 id="管理_NSURLSessionTask"><a id="NSURLSessionTask"></a>管理 <code>NSURLSessionTask</code></h2><p>接下来，在获得了 <code>AFURLSessionManager</code> 的实例之后，我们可以通过以下方法创建 <code>NSURLSessionDataTask</code> 的实例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> Creates an `NSURLSessionDataTask` with the specified request.</span><br><span class="line"></span><br><span class="line"> @param request The HTTP request for the request.</span><br><span class="line"> @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any.</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这里省略了一些返回 <code>NSURLSessionTask</code> 的方法，因为这些接口的形式都是差不多的。</p>
<p><strong>扩展</strong>：<a href="http://stackoverflow.com/questions/32452889/difference-between-nullable-nullable-and-nullable-in-objective-c" target="_blank" rel="external">Difference between nullable, __nullable and _Nullable in Objective-C</a></p>
<p>下面，我们将以 <code>- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</code> 方法的实现为例，分析它是如何实例化并返回一个 <code>NSURLSessionTask</code> 的实例的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               uploadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                             downloadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                            completionHandler:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [<span class="keyword">self</span><span class="variable">.session</span> dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要完成如下工作：</p>
<ol>
<li>调用 <code>- [NSURLSession dataTaskWithRequest:]</code> 方法传入 <code>NSURLRequest</code></li>
<li>调用 <code>- [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</code> 方法返回一个 <code>AFURLSessionManagerTaskDelegate</code> 对象</li>
<li>将 <code>completionHandler</code> <code>uploadProgressBlock</code> 和 <code>downloadProgressBlock</code> 传入该对象并在相应事件发生时进行回调</li>
</ol>
<blockquote>
<p><code>url_session_manager_create_task_safely</code> 的调用是因为苹果框架中的一个 bug <a href="https://github.com/AFNetworking/AFNetworking/issues/2093" target="_blank" rel="external">#2093</a>，如果有兴趣可以看一下，在这里就不具体说明了。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">                uploadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">    delegate<span class="variable">.manager</span> = <span class="keyword">self</span>;</span><br><span class="line">    delegate<span class="variable">.completionHandler</span> = completionHandler;</span><br><span class="line"></span><br><span class="line">    dataTask<span class="variable">.taskDescription</span> = <span class="keyword">self</span><span class="variable">.taskDescriptionForSessionTasks</span>;</span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    delegate<span class="variable">.uploadProgressBlock</span> = uploadProgressBlock;</span><br><span class="line">    delegate<span class="variable">.downloadProgressBlock</span> = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中同时调用了另一个方法 <code>- [AFURLSessionManager setDelegate:forTask:]</code> 来设置代理：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#1: 检查参数, 略</span></span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.lock</span> lock];</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.mutableTaskDelegatesKeyedByTaskIdentifier</span>[@(task<span class="variable">.taskIdentifier</span>)] = delegate;</span><br><span class="line">    [delegate setupProgressForTask:task];</span><br><span class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.lock</span> unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如上面所提到的，<code>AFURLSessionManager</code> 就是通过字典 <code>mutableTaskDelegatesKeyedByTaskIdentifier</code> 来存储并管理每一个 <code>NSURLSessionTask</code>，它以 <code>taskIdentifier</code> 为键存储 task。</p>
<p>该方法使用 <code>NSLock</code> 来保证不同线程使用 <code>mutableTaskDelegatesKeyedByTaskIdentifier</code> 时，不会出现<strong>线程竞争</strong>的问题（既线程同步）。</p>
<p>同时调用 <a href="#setupProgressForTask">- setupProgressForTask:</a>，我们会在下面具体介绍这个方法。</p>
<hr>
<h2 id="实现_NSURLSessionDelegate_等协议中的代理方法"><a id="NSURLSessionDelegate"></a>实现 <code>NSURLSessionDelegate</code> 等协议中的代理方法</h2><p>首先，<code>NSURLSession</code> 的代理对象结构如下：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-afnetworking-three-01.png" alt=""></p>
<p>接下来，我们来看下具体的代理方法：</p>
<ul>
<li><code>NSURLSessionDelegate</code></li>
<li><code>NSURLSessionTaskDelegate</code>，遵守 <code>NSURLSessionDelegate</code> 协议</li>
<li><p><code>NSURLSessionDataDelegate</code>，遵守 <code>NSURLSessionTaskDelegate</code> 协议，是网络请求通常遵循的协议，常用的方法：</p>
<ul>
<li><p>接受到服务响应时调用的方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler;</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 必须在该方法中对服务器的响应进行授权，才能继续接收服务器返回的数据，调用如下函数</span><br><span class="line">* completionHandler（NSURLSessionResponseAllow）</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接收到服务器返回的数据时调用的方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* data：服务返回的数据，通常为 JSON 格式数据</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>请求完成时调用的方法（成功或失败）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(nullable <span class="built_in">NSError</span> *)error</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* 若出现错误，error 中存放错误信息</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>NSURLSessionDownloadDelegate（通常用于下载大量数据），遵守 NSURLSessionTaskDelegate 协议，常用的方法：</p>
<ul>
<li><p>写入数据到临时文件时调用的方法（服务器返回一点就写入一点）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:	(int64_t)totalBytesExpectedToWrite</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* totalBytesWritten，已写入数据的总长度</span><br><span class="line">* totalBytesExpectedToWrite：总共要写入数据的总长度</span><br><span class="line">* 可以在该方法中计算下载进度</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>遇到错误的时候调用</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line"><span class="comment">/**</span><br><span class="line">*error：若遇到错误，则保存错误信息</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用于断点下载的方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* fileOffset：继续下载时，文件的开始位置</span><br><span class="line">* expectedTotalBytes：剩余的数据总数</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下载完成时调用的方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line"><span class="comment">/**</span><br><span class="line">* location：下载的文件保存的临时位置</span><br><span class="line">* 需要将下载的文件保存在可以长期保存的位置</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="使用_AFURLSessionManagerTaskDelegate_管理进度"><a id="AFURLSessionManagerTaskDelegate"></a>使用 <code>AFURLSessionManagerTaskDelegate</code> 管理进度</h2><p>在上面我们提到过 <code>AFURLSessionManagerTaskDelegate</code> 类，它主要为 task 提供<strong>进度管理</strong>功能，并在 task 结束时<strong>回调</strong>， 也就是调用在 <code>- [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:]</code> 等方法中传入的 <code>completionHandler</code>。</p>
<p><a id="setupProgressForTask"></a>我们首先分析一下 <code>AFURLSessionManagerTaskDelegate</code> 是如何对进度进行跟踪的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupProgressForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#1：设置在上传进度或者下载进度状态改变时的回调</span></span><br><span class="line">true</span><br><span class="line">    <span class="preprocessor">#2：KVO</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的实现有两个部分，一部分是对代理持有的两个属性 <code>uploadProgress</code> 和 <code>downloadProgress</code> 设置回调</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> __typeof__(task) weakTask = task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span><span class="variable">.uploadProgress</span><span class="variable">.totalUnitCount</span> = task<span class="variable">.countOfBytesExpectedToSend</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.uploadProgress</span> setCancellable:<span class="literal">YES</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.uploadProgress</span> setCancellationHandler:^&#123;</span><br><span class="line">   __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">   [strongTask cancel];</span><br><span class="line">&#125;];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.uploadProgress</span> setPausable:<span class="literal">YES</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.uploadProgress</span> setPausingHandler:^&#123;</span><br><span class="line">   __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">   [strongTask suspend];</span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.uploadProgress</span> respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">   [<span class="keyword">self</span><span class="variable">.uploadProgress</span> setResumingHandler:^&#123;</span><br><span class="line">       __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">       [strongTask resume];</span><br><span class="line">   &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只有对 <code>uploadProgress</code> 设置回调的代码，设置 <code>downloadProgress</code> 与这里完全相同</p>
<blockquote>
<p>主要目的是在对应 <code>NSProgress</code> 的状态改变时，调用 <code>resume</code> <code>suspend</code> 等方法改变 task 的状态。</p>
</blockquote>
<p>第二部分是对 task 和 <code>NSProgress</code> 属性进行键值观测：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[task addObserver:<span class="keyword">self</span></span><br><span class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))</span><br><span class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">         context:<span class="literal">NULL</span>];</span><br><span class="line">[task addObserver:<span class="keyword">self</span></span><br><span class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))</span><br><span class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">         context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">[task addObserver:<span class="keyword">self</span></span><br><span class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))</span><br><span class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">         context:<span class="literal">NULL</span>];</span><br><span class="line">[task addObserver:<span class="keyword">self</span></span><br><span class="line">      forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))</span><br><span class="line">         options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">         context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span><span class="variable">.downloadProgress</span> addObserver:<span class="keyword">self</span></span><br><span class="line">                       forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                          options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                          context:<span class="literal">NULL</span>];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.uploadProgress</span> addObserver:<span class="keyword">self</span></span><br><span class="line">                     forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                        options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                        context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>
<p>在 <code>observeValueForKeypath:ofObject:change:context:</code> 方法中改变进度，并调用 block</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> ([object isKindOfClass:[<span class="built_in">NSURLSessionTask</span> class]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))]) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.downloadProgress</span><span class="variable">.completedUnitCount</span> = [change[<span class="string">@"new"</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))]) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.downloadProgress</span><span class="variable">.totalUnitCount</span> = [change[<span class="string">@"new"</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))]) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.uploadProgress</span><span class="variable">.completedUnitCount</span> = [change[<span class="string">@"new"</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))]) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.uploadProgress</span><span class="variable">.totalUnitCount</span> = [change[<span class="string">@"new"</span>] longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span><span class="variable">.downloadProgress</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.downloadProgressBlock</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.downloadProgressBlock</span>(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span><span class="variable">.uploadProgress</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.uploadProgressBlock</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.uploadProgressBlock</span>(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象的某些属性改变时更新 <code>NSProgress</code> 对象或使用 block 传递 <code>NSProgress</code> 对象 <code>self.uploadProgressBlock(object)</code>。</p>
<h3 id="代理方法_URLSession:task:didCompleteWithError:">代理方法 <code>URLSession:task:didCompleteWithError:</code></h3><p>在每一个 <code>NSURLSessionTask</code> 结束时，都会在代理方法 <code>URLSession:task:didCompleteWithError:</code> 中：</p>
<ol>
<li>调用传入的 <code>completionHander</code> block</li>
<li>发出 <code>AFNetworkingTaskDidCompleteNotification</code> 通知</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="preprocessor">#1：获取数据, 存储 `responseSerializer` 和 `downloadFileURL`</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    	<span class="preprocessor">#2：在存在错误时调用 `completionHandler`</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">truetrue<span class="preprocessor">#3：调用 `completionHandler`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是整个代理方法的骨架，先看一下最简单的第一部分代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">NSMutableDictionary</span> *userInfo = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager<span class="variable">.responseSerializer</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体可以查看 #issue 2672。这里主要是针对大文件的时候，性能提升会很明显</span></span><br><span class="line"><span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.mutableData</span>) &#123;</span><br><span class="line">   data = [<span class="keyword">self</span><span class="variable">.mutableData</span> <span class="keyword">copy</span>];</span><br><span class="line">   <span class="comment">// 此处不再需要 mutableData 了</span></span><br><span class="line">   <span class="keyword">self</span><span class="variable">.mutableData</span> = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.downloadFileURL</span>) &#123;</span><br><span class="line">   userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = <span class="keyword">self</span><span class="variable">.downloadFileURL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (data) &#123;</span><br><span class="line">   userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看第二部分：这部分代码从 <code>mutableData</code> 中取出了数据，设置了 <code>userInfo</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 task 出错了，处理 error 信息</span></span><br><span class="line"><span class="comment">// 所以对应的观察者在处理 error 的时候，比如可以先判断 userInfo[AFNetworkingTaskDidCompleteErrorKey] 是否有值，有值的话，就说明是要处理 error</span></span><br><span class="line">userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">dispatch_group_async(manager<span class="variable">.completionGroup</span> ?: url_session_manager_completion_group(), manager<span class="variable">.completionQueue</span> ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.completionHandler</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.completionHandler</span>(task<span class="variable">.response</span>, responseObject, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果当前 <code>manager</code> 持有 <code>completionGroup</code> 或者 <code>completionQueue</code> 就使用它们。否则会创建一个 <code>dispatch_group_t</code> 并在主线程中调用 <code>completionHandler</code> 并发送通知（在主线程中）。</p>
<p>最后一部分：如果在执行当前 task 时没有遇到错误，那么先<strong>对数据进行序列化</strong>，然后同样调用 block 并发送通知。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 根据对应的 task 和 data 将 response data 解析成可用的数据格式，比如 JSON serializer 就将 data 解析成 JSON 格式</span></span><br><span class="line">    responseObject = [manager<span class="variable">.responseSerializer</span> responseObjectForResponse:task<span class="variable">.response</span> data:data error:&amp;serializationError];</span><br><span class="line">    <span class="comment">// 注意如果有 downloadFileURL，意味着 data 存放在了磁盘上了，所以此处 responseObject 保存的是 data 存放位置，供后面 completionHandler 处理。没有 downloadFileURL，就直接使用内存中的解析后的 data 数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.downloadFileURL</span>) &#123;</span><br><span class="line">        responseObject = <span class="keyword">self</span><span class="variable">.downloadFileURL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (responseObject) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 序列化的时候出现错误</span></span><br><span class="line">    <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatch_group_async(manager<span class="variable">.completionGroup</span> ?: url_session_manager_completion_group(), manager<span class="variable">.completionQueue</span> ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.completionHandler</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.completionHandler</span>(task<span class="variable">.response</span>, responseObject, serializationError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="代理方法_URLSession:dataTask:didReceiveData:_和_-_URLSession:downloadTask:didFinishDownloadingToURL:">代理方法 <code>URLSession:dataTask:didReceiveData:</code> 和 <code>- URLSession:downloadTask:didFinishDownloadingToURL:</code></h3><p>这两个代理方法分别会在收到数据或者完成下载对应文件时调用，作用分别是为 <code>mutableData</code> 追加数据和处理下载的文件：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(__unused <span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.mutableData</span> appendData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *fileManagerError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.downloadFileURL</span> = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.downloadTaskDidFinishDownloading</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.downloadFileURL</span> = <span class="keyword">self</span><span class="variable">.downloadTaskDidFinishDownloading</span>(session, downloadTask, location);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.downloadFileURL</span>) &#123;</span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:<span class="keyword">self</span><span class="variable">.downloadFileURL</span> error:&amp;fileManagerError];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fileManagerError) &#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError<span class="variable">.userInfo</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="使用__AFURLSessionTaskSwizzling_调剂方法"><a id="_AFURLSessionTaskSwizzling"></a>使用 <code>_AFURLSessionTaskSwizzling</code> 调剂方法</h2><p><code>_AFURLSessionTaskSwizzling</code> 的唯一功能就是修改 <code>NSURLSessionTask</code> 的 <code>resume</code> 和 <code>suspend</code> 方法，使用下面的方法替换原有的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)af_resume &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@"Does not respond to state"</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_resume];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateRunning</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AF<span class="built_in">NSURLSessionTaskDidResumeNotification</span> object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)af_suspend &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@"Does not respond to state"</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_suspend];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AF<span class="built_in">NSURLSessionTaskDidSuspendNotification</span> object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做的目的是为了在方法 <code>resume</code> 或者 <code>suspend</code> 被调用时发出通知。</p>
<p>具体方法调剂的过程是在 <code>+ load</code> 方法中进行的</p>
<blockquote>
<p><code>load</code> 方法只会在整个文件被引入时调用一次</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@"NSURLSessionTask"</span>)) &#123;</span><br><span class="line">        <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</span><br><span class="line">        <span class="comment">// 首先构建一个 NSURLSession 对象 session，再通过 session 构建出一个 _NSCFLocalDataTask 变量</span></span><br><span class="line">        <span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];</span><br><span class="line"><span class="preprocessor">#pragma GCC diagnostic push</span></span><br><span class="line"><span class="preprocessor">#pragma GCC diagnostic ignored <span class="title">"-Wnonnull"</span></span></span><br><span class="line">        <span class="built_in">NSURLSessionDataTask</span> *localDataTask = [session dataTaskWithURL:<span class="literal">nil</span>];</span><br><span class="line"><span class="preprocessor">#pragma clang diagnostic pop</span></span><br><span class="line">        <span class="comment">// 获取到 af_resume 实现的指针</span></span><br><span class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([<span class="keyword">self</span> class], <span class="keyword">@selector</span>(af_resume)));</span><br><span class="line">        Class currentClass = [localDataTask class];</span><br><span class="line">        <span class="comment">// 检查当前 class 是否实现了 resume。如果实现了，继续第 4 步</span></span><br><span class="line">        <span class="keyword">while</span> (class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume))) &#123;</span><br><span class="line">            <span class="comment">// 获取到当前 class 的父类（superClass）</span></span><br><span class="line">            Class superClass = [currentClass superclass];</span><br><span class="line">            <span class="comment">// 获取到当前 class 对于 resume 实现的指针</span></span><br><span class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line">            <span class="comment">// 获取到父类对于 resume 实现的指针</span></span><br><span class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line">            <span class="comment">// 如果当前 class 对于 resume 的实现和父类不一样（类似 iOS 7 上的情况），并且当前 class 的 resume 实现和 af_resume 不一样，才进行 method swizzling</span></span><br><span class="line">            <span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp;</span><br><span class="line">                originalAFResumeIMP != classResumeIMP) &#123;</span><br><span class="line">                [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置当前操作的 class 为其父类 class，重复步骤 3~8</span></span><br><span class="line">            currentClass = [currentClass superclass];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [localDataTask cancel];</span><br><span class="line">        [session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先用 <code>NSClassFromString(@&quot;NSURLSessionTask&quot;)</code> 判断当前部署的 iOS 版本是否含有类 <code>NSURLSessionTask</code></li>
<li>因为 iOS 7 和 iOS 8 上对于 <code>NSURLSessionTask</code> 的实现不同，所以会通过 <code>- [NSURLSession dataTaskWithURL:]</code> 方法返回一个 <code>NSURLSessionTask</code> 实例</li>
<li>取得当前类 <code>_AFURLSessionTaskSwizzling</code> 中的实现 <code>af_resume</code></li>
<li>如果当前类 <code>currentClass</code> 有 <code>resume</code> 方法<ul>
<li>真：5</li>
<li>假：6</li>
</ul>
</li>
<li>使用 <code>swizzleResumeAndSuspendMethodForClass:</code> 调剂该类的 <code>resume</code> 和 <code>suspend</code> 方法</li>
<li><code>currentClass = [currentClass superclass]</code> </li>
</ol>
<blockquote>
<p>这里复杂的实现是为了解决 bug <a href="https://github.com/AFNetworking/AFNetworking/pull/2702" target="_blank" rel="external">#2702</a></p>
</blockquote>
<hr>
<h2 id="引入_AFSecurityPolicy_保证请求的安全"><a id="AFSecurityPolicy"></a>引入 <code>AFSecurityPolicy</code> 保证请求的安全</h2><p><code>AFSecurityPolicy</code> 是 <code>AFNetworking</code> 用来保证 HTTP 请求安全的类，它被 <code>AFURLSessionManager</code> 持有，如果你在 <code>AFURLSessionManager</code> 的实现文件中搜索 <em>self.securityPolicy</em>，你只会得到三条结果：</p>
<ol>
<li>初始化 <code>self.securityPolicy = [AFSecurityPolicy defaultPolicy]</code></li>
<li>收到连接层的验证请求时</li>
<li>任务接收到验证请求时</li>
</ol>
<p>在 API 调用上，后两者都调用了 <code>- [AFSecurityPolicy evaluateServerTrust:forDomain:]</code> 方法来判断<strong>当前服务器是否被信任</strong>，我们会在接下来的文章中具体介绍这个方法的实现的作用。</p>
<hr>
<h2 id="引入_AFNetworkReachabilityManager_监控网络状态"><a id="AFNetworkReachabilityManager"></a>引入 <code>AFNetworkReachabilityManager</code> 监控网络状态</h2><p>与 <code>AFSecurityPolicy</code> 相同，<code>AFURLSessionManager</code> 对网络状态的监控是由 <code>AFNetworkReachabilityManager</code> 来负责的，它仅仅是持有一个 <code>AFNetworkReachabilityManager</code> 的对象。</p>
<blockquote>
<p>真正需要判断网络状态时，仍然<strong>需要开发者调用对应的 API 获取网络状态</strong>。</p>
</blockquote>
<hr>
<h2 id="小结">小结</h2><ul>
<li><code>AFURLSessionManager</code> 是对 <code>NSURLSession</code> 的封装</li>
<li>它通过 <code>- [AFURLSessionManager dataTaskWithRequest:completionHandler:]</code> 等接口创建 <code>NSURLSessionDataTask</code> 的实例</li>
<li>持有一个字典 <code>mutableTaskDelegatesKeyedByTaskIdentifier</code> 管理这些 data task 实例</li>
<li>引入 <code>AFURLSessionManagerTaskDelegate</code> 来对传入的 <code>uploadProgressBlock</code> <code>downloadProgressBlock</code> <code>completionHandler</code> 在合适的时间进行调用</li>
<li>实现了全部的代理方法来提供 block 接口</li>
<li>通过方法调剂在 data task 状态改变时，发出通知</li>
</ul>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/AFNetworking/AFNetworking%20%E7%9A%84%E6%A0%B8%E5%BF%83%20AFURLSessionManager%EF%BC%88%E4%BA%8C%EF%BC%89.md#NSURLSessionTask" target="_blank" rel="external">AFNetworking 的核心 AFURLSessionManager（二）</a></li>
<li><a href="http://www.cnblogs.com/polobymulberry/p/5160946.html" target="_blank" rel="external">【原】AFNetworking源码阅读（四）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p><code>AFURLSessionManager</code> 绝对可以称得上是 AFNetworking 的核心，所以本文篇幅会相对长一点，但我保证绝对是满满的干货~</p>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://itangqi.me/tags/AFNetworking/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="Source Code" scheme="http://itangqi.me/tags/Source-Code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 3.0 源码阅读笔记（二）]]></title>
    <link href="http://itangqi.me/2016/05/06/the-notes-of-learning-afnetworking-two/"/>
    <id>http://itangqi.me/2016/05/06/the-notes-of-learning-afnetworking-two/</id>
    <published>2016-05-05T16:00:00.000Z</published>
    <updated>2016-05-28T07:30:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>首先，我们来看一下 AFNetworking 框架中主要涉及到了哪些类：</p>
<p><strong>NSURLSession</strong></p>
<ul>
<li><code>AFURLSessionManager</code></li>
<li><code>AFHTTPSessionManager</code></li>
</ul>
<a id="more"></a>
<p><strong>序列化</strong></p>
<ul>
<li><code>AFURLRequestSerialization</code></li>
<li><code>AFURLResponseSerialization</code></li>
</ul>
<p><strong>附加功能</strong></p>
<ul>
<li><code>AFSecurityPolicy</code></li>
<li><code>AFNetworkReachabilityManager</code></li>
</ul>
<!-- more -->
<p>下面，通过一张图来直观地感受下 AF 架构的设计：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-afnetworking-two-01.png" alt=""></p>
<hr>
<h2 id="AFHTTPSessionManager">AFHTTPSessionManager</h2><blockquote>
<p><code>AFHTTPSessionManager</code> is a subclass of <code>AFURLSessionManager</code> with convenience methods for making HTTP requests. When a <code>baseURL</code> is provided, requests made with the <code>GET</code> / <code>POST</code> / et al. convenience methods can be made with relative paths.</p>
</blockquote>
<p>一句话总结：<code>AFHTTPSessionManager</code> 继承于 <code>AFURLSessionManager</code>，并提供了方便的 HTTP 请求方法。</p>
<p>下面，我们通过一段实际代码来感受下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://api.app.net/"</span>]];</span><br><span class="line">[sessionManager GET:<span class="string">@"stream/0/posts/stream/global"</span> parameters:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nonnull responseObject) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"请求成功---%@"</span>, responseObject);</span><br><span class="line">    &#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"请求失败---%@"</span>, error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>通过上面短短几行代码，我们便完成了 GET 请求，有木有很简单！现在是不是很想知道其背后蕴藏的玄机呢？别急，下面就让我们一起来探一探究竟。</p>
<hr>
<h2 id="调用栈">调用栈</h2><h3 id="initWithBaseURL:">initWithBaseURL:</h3><p>首先，我们来探一探 <code>AFHTTPSessionManager</code> 初始化方法 <code>- initWithBaseURL:</code> 的调用栈：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://api.app.net/"</span>]];</span><br></pre></td></tr></table></figure>
<p>我们一路「Command + 左键」，可以归纳出如下结果：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- [AFHTTPSessionManager initWithBaseURL:]</span><br><span class="line">    - [AFHTTPSessionManager initWithBaseURL:sessionConfiguration:]</span><br><span class="line">        - [AFURLSessionManager initWithSessionConfiguration:]</span><br><span class="line">            - [<span class="built_in">NSURLSession</span> sessionWithConfiguration:delegate:delegateQueue:]</span><br><span class="line">            - [AFJSONResponseSerializer serializer] <span class="comment">// 负责序列化响应</span></span><br><span class="line">            - [AFSecurityPolicy defaultPolicy] <span class="comment">// 负责身份认证</span></span><br><span class="line">            - [AFNetworkReachabilityManager sharedManager] <span class="comment">// 查看网络连接情况</span></span><br><span class="line">        - [AFHTTPRequestSerializer serializer] <span class="comment">// 负责序列化请求</span></span><br><span class="line">        - [AFJSONResponseSerializer serializer] <span class="comment">// 负责序列化响应</span></span><br></pre></td></tr></table></figure>
<p>从这个初始化方法的调用栈，我们可以非常清晰地了解这个框架的结构：</p>
<ul>
<li>其中 <code>AFURLSessionManager</code> 是 <code>AFHTTPSessionManager</code> 的父类</li>
<li><code>AFURLSessionManager</code> 负责生成 <code>NSURLSession</code> 的实例，管理 <code>AFSecurityPolicy</code> 和 <code>AFNetworkReachabilityManager</code>，来保证请求的安全和查看网络连接情况，它有一个 <code>AFJSONResponseSerializer</code> 的实例来序列化 HTTP 响应</li>
<li><code>AFHTTPSessionManager</code> 有着<strong>自己的</strong> <code>AFHTTPRequestSerializer</code> 和 <code>AFJSONResponseSerializer</code> 来管理请求和响应的序列化，同时<strong>依赖父类提供的接口</strong>保证安全、监控网络状态，实现发出 HTTP 请求这一核心功能</li>
</ul>
<h4 id="baseURL">baseURL</h4><p>关于 <code>baseURL</code> 一开始我是有点迷糊的，不过源代码中有如下注释：</p>
<blockquote>
<p>For HTTP convenience methods, the request serializer constructs URLs from the path relative to the <code>-baseURL</code>, using <code>NSURL +URLWithString:relativeToURL:</code>, when provided. If <code>baseURL</code> is <code>nil</code>, <code>path</code> needs to resolve to a valid <code>NSURL</code> object using <code>NSURL +URLWithString:</code>.</p>
</blockquote>
<p>并举例进行了说明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *baseURL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/v1/"</span>];</span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"foo"</span> relativeToURL:baseURL];                  <span class="comment">// http://example.com/v1/foo</span></span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"foo?bar=baz"</span> relativeToURL:baseURL];          <span class="comment">// http://example.com/v1/foo?bar=baz</span></span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"/foo"</span> relativeToURL:baseURL];                 <span class="comment">// http://example.com/foo</span></span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"foo/"</span> relativeToURL:baseURL];                 <span class="comment">// http://example.com/v1/foo</span></span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"/foo/"</span> relativeToURL:baseURL];                <span class="comment">// http://example.com/foo/</span></span><br><span class="line">[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example2.com/"</span> relativeToURL:baseURL]; <span class="comment">// http://example2.com/</span></span><br></pre></td></tr></table></figure>
<p>所以，<code>baseURL</code> 为访问的基路径如：<a href="https://api.app.net/，" target="_blank" rel="external">https://api.app.net/，</a> path 是跟在基路径之后的部分路径，如：stream/0/posts/stream/global（因为 AFNetworking 的访问方式才这样划分）。</p>
<h3 id="GET:parameters:process:success:failure:">GET:parameters:process:success:failure:</h3><p>初始化方法很好地揭示了 AFNetworking 整个框架的架构，接下来我们要通过分析另一个方法 <code>- GET:parameters:process:success:failure:</code> 的调用栈，看一下 HTTP 请求是如何发出的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- [AFHTTPSessionManager GET:parameters:process:success:failure:]</span><br><span class="line">    - [AFHTTPSessionManager dataTaskWithHTTPMethod:parameters:uploadProgress:downloadProgress:success:failure:] <span class="comment">// 返回 NSURLSessionDataTask #1</span></span><br><span class="line">        - [AFHTTPRequestSerializer requestWithMethod:URLString:parameters:error:] <span class="comment">// 返回 NSMutableURLRequest</span></span><br><span class="line">        - [AFURLSessionManager dataTaskWithRequest:uploadProgress:downloadProgress:completionHandler:] <span class="comment">// 返回 NSURLSessionDataTask #2</span></span><br><span class="line">            - [<span class="built_in">NSURLSession</span> dataTaskWithRequest:] <span class="comment">// 返回 NSURLSessionDataTask #3</span></span><br><span class="line">            - [AFURLSessionManager addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:]</span><br><span class="line">                - [AFURLSessionManagerTaskDelegate init]</span><br><span class="line">                - [AFURLSessionManager setDelegate:forTask:]</span><br><span class="line">    - [<span class="built_in">NSURLSessionDataTask</span> resume]</span><br></pre></td></tr></table></figure>
<p>在这里 <code>#1</code> <code>#2</code> <code>#3</code> 处返回的是同一个 data task，我们可以看到，在 <code>#3</code> 处调用的方法 <code>- [NSURLSession dataTaskWithRequest:]</code> 和只使用 <code>NSURLSession</code> 发出 HTTP 请求时调用的方法 <code>- [NSURLSession dataTaskWithRequest:completionHandler:]</code> 差不多。在这个地方返回 data task 之后，我们再调用 <code>- resume</code> 方法执行请求，并在某些事件执行时通知代理 <code>AFURLSessionManagerTaskDelegate</code>。</p>
<p>我们在第一篇文章中已经说明过，AFNetworking 3.0 既是在 <code>NSURLSession</code> 之上的高度封装，并提供更加简洁易用的 API。从调用栈的结果来看，将使我们的理解更加清晰。</p>
<hr>
<h2 id="循环引用">循环引用</h2><p>关于在使用 AFNetworking 的过程中出现循环引用的问题，我并没有在实际开发中遇到过（其实我丫的根本就没写过几行代码好嘛（ ＴДＴ）），我是在浏览相关文章时发现这个问题的，所以在此提及一下：</p>
<ul>
<li><a href="https://github.com/AFNetworking/AFNetworking/issues/2149#issuecomment-46842747" target="_blank" rel="external">AFHTTPSessionManager subclass not deallocating - retain cycle?</a></li>
<li><a href="https://github.com/AFNetworking/AFNetworking/issues/3116" target="_blank" rel="external">AFHTTPSessionManager and AFURLSessionManager never deallocated</a></li>
<li><a href="https://github.com/AFNetworking/AFNetworking/issues/2767" target="_blank" rel="external">block retain cycle in AFUrLSessionManager init method</a></li>
</ul>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/AFNetworking/AFNetworking%20%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89.md" target="_blank" rel="external">AFNetworking 概述（一）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>首先，我们来看一下 AFNetworking 框架中主要涉及到了哪些类：</p>
<p><strong>NSURLSession</strong></p>
<ul>
<li><code>AFURLSessionManager</code></li>
<li><code>AFHTTPSessionManager</code></li>
</ul>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://itangqi.me/tags/AFNetworking/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="Source Code" scheme="http://itangqi.me/tags/Source-Code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AFNetworking 3.0 源码阅读笔记（一）]]></title>
    <link href="http://itangqi.me/2016/05/05/the-notes-of-learning-afnetworking-one/"/>
    <id>http://itangqi.me/2016/05/05/the-notes-of-learning-afnetworking-one/</id>
    <published>2016-05-04T16:00:00.000Z</published>
    <updated>2016-05-28T04:28:06.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>在完成 <a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a> 的源码阅读后（可参见系列文章：<a href="http://itangqi.me/2016/03/19/the-notes-of-learning-sdwebimage-one/">SDWebImage 源码阅读笔记</a>），我又将目光瞄向了大名鼎鼎的网络库 <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a>，不过为了能保证源码阅读的流畅性，不至于到时一脸懵逼，在正式开始之前，我又恶补了下网络相关的知识，可参见相关文章：<a href="http://itangqi.me/2016/04/01/from-nsurlconnection-to-nsurlsession/">从 NSURLConnection 到 NSURLSession</a> 与<a href="http://itangqi.me/2016/04/04/the-notes-of-learning-illustrating-http-one/">《图解 HTTP》读书笔记</a>。</p>
<p>好啦，似乎万事具备，就让我们扬帆起航，开启 AFNetworking 源码阅读之旅吧！</p>
<a id="more"></a>
<hr>
<h2 id="概述">概述</h2><p><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking</a> 官方介绍如下：</p>
<blockquote>
<p>AFNetworking is a delightful networking library for iOS and Mac OS X. It’s built on top of the <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html" target="_blank" rel="external">Foundation URL Loading System</a>, extending the powerful high-level networking abstractions built into Cocoa. It has a modular architecture with well-designed, feature-rich APIs that are a joy to use.</p>
</blockquote>
<p>一句话总结：AFNetworking 是一个在 iOS 和 Mac OS X 都令人喜爱的网络库，它是基于 Foundation URL Loading System 进行的一套封装，有着精心设计的模块化架构和丰富的 API 接口。</p>
<hr>
<h2 id="3-0_vs-_2-0">3.0 vs. 2.0</h2><blockquote>
<p>AFNetworking 依靠着开源社区的力量，仍在不断更新中，本系列文章阅读的版本为 <strong>3.1.0</strong>。</p>
</blockquote>
<p>为了迎合 iOS 新版本的升级，AFNetworking 在 3.0 版本中删除了基于 <code>NSURLConnection</code> API 的所有支持。目前 AFNetworking 2.0 官方已经不再提供支持了，其所依赖的 <code>NSURLConnection</code> 系列类也已经被苹果废弃了，意味着苹果官方也不再推荐。因此 AFNetworking 3.0 版本是目前开发的首选（需要兼容旧版本 iOS 的情况下除外）。</p>
<p>尽管 AFNetworking 对外提供的 API 变化不大，这里我们还是需要注意一下 AFNetworking 在 3.0 和 2.0 版本架构上的一个主要变化：</p>
<blockquote>
<p>AFNetworking 3.0 以 Session 为中心，AFNetworking 2.0 以 Operation 为中心。</p>
</blockquote>
<p>这种区别来源与它们下层的依赖，AFNetworking 3.0 依赖的较新的 <code>NSURLSession</code> API，AFNetworking 2.0 依赖于 <code>NSURLConnection</code> 和 <code>NSOperation</code>。</p>
<p>Session 提供了一个较为中心的管理机制，可以通过配置 <code>NSURLSessionConfiguration</code> 来控制一系列请求。而 Operation 则提供了较为分散的管理方法，不同的 Operation 之间没有太大的联系，可以独自进行配置。</p>
<p>如果你对 <code>NSURLConnection</code> 与 <code>NSURLSession</code> 的概念不熟，建议不妨看下我之前的文章：<a href="http://itangqi.me/2016/04/01/from-nsurlconnection-to-nsurlsession/">从 NSURLConnection 到 NSURLSession</a> 补补课：）</p>
<h3 id="新设备要求">新设备要求</h3><p>AFNetworking 3.0 正式支持 iOS 7+，Mac OS X 10.9+，watchOS 2+，tvOS 9 和 Xcode 7。如果你想在针对较旧版本的 SDK 项目中使用 AFNetworking，请检查 <a href="https://github.com/AFNetworking/AFNetworking/blob/master/README.md#requirements" target="_blank" rel="external">README</a> 的兼容性信息。</p>
<h3 id="NSURLConnection_的_API_已被废弃">NSURLConnection 的 API 已被废弃</h3><p>AFNetworking 1.0 建立在 <code>NSURLConnection</code> 的基础 API 之上，AFNetworking 2.0 提供了选择使用 <code>NSURLConnection</code> 的基础 API 或者较新基于 <code>NSURLSession</code> 的 API 的选项。AFNetworking 3.0 现已是完全基于 <code>NSURLSession</code> 的 API，这降低了日后维护的负担，同时支持苹果增强关于 <code>NSURLSession</code> 提供的任何额外功能。由于 Xcode 7 中，<code>NSURLConnection</code> 的 API 已经正式被苹果弃用。虽然该 API 将继续运行，但将没有新功能将被添加，并且苹果已经通知所有基于网络的功能，以充分使 <code>NSURLSession</code> 向前发展。</p>
<p>AFNetworking 2.x 将继续接受严重的 bug 提交和提供安全补丁，但未来不会有新的功能被添加。Alamofire（Swift 下的网络请求）软件基金会建议，所有的项目迁移到基于 <code>NSURLSession</code>的 API。</p>
<h3 id="废弃的类">废弃的类</h3><p>以下的类已从 AFNetworking 3.0 中废弃：</p>
<ul>
<li><code>AFURLConnectionOperation</code></li>
<li><code>AFHTTPRequestOperation</code></li>
<li><code>AFHTTPRequestOperationManager</code></li>
</ul>
<h3 id="修改的类">修改的类</h3><p>以下的类包含基于 <code>NSURLConnection</code> 的 API 的内部实现。他们已经被使用 <code>NSURLSession</code> 重构:</p>
<ul>
<li><code>UIImageView+AFNetworking</code></li>
<li><code>UIWebView+AFNetworking</code></li>
<li><code>UIButton+AFNetworking</code></li>
</ul>
<hr>
<h2 id="迁移">迁移</h2><h3 id="AFHTTPRequestOperationManager_核心代码">AFHTTPRequestOperationManager 核心代码</h3><p>如果你以前使用 <code>AFHTTPRequestOperationManager</code>，你将需要迁移去使用 <code>AFHTTPSessionManager</code>。以下的类在两者过渡间并没有发生变化：</p>
<ul>
<li><code>securityPolicy</code></li>
<li><code>requestSerializer</code></li>
<li><code>responseSerializer</code></li>
</ul>
<h3 id="AFHTTPRequestOperation_核心代码">AFHTTPRequestOperation 核心代码</h3><p>与 <code>NSURLConnection</code> 对象不同，每个共享应用范围的设置如会话管理、缓存策略、Cookie 存储以及 URL 协议等，这些 <code>NSURLSession</code> 对象都可以单独进行配置。使用特定的配置来初始化会话，它可以发送任务来获取数据，并上传或下载文件。</p>
<p>在 AFNetworking 2.0 中，使用 <code>AFHTTPRequestOperation</code>，有可能创建一个没有额外开销的独立的网络请求来获取数据。<code>NSURLSession</code> 则需要更多的开销，为了获得所要请求的数据。</p>
<h3 id="跟踪进程">跟踪进程</h3><p>AFNetworking 3.0 使用 <code>NSProgress</code> 来对 <code>NSURLSessionTasks</code> 进行跟踪。除了在上传/下载的任务中加入了对 block 的支持，<code>AFURLSessionManager</code> 还暴露了两个获得 <code>NSProgress</code> 对象的辅助方法：</p>
<ul>
<li><code>uploadProgressForTask:</code></li>
<li><code>downloadProgressForTask:</code></li>
</ul>
<h3 id="UIKit_的迁移">UIKit 的迁移</h3><p>图片下载已经被重构，以遵循 <a href="https://github.com/alamofire/alamofireimage" target="_blank" rel="external">AlamofireImage</a> 架构与新的 <code>AFImageDownloader</code> 类。这个类的图片下载职责的 delegate 是 UIButton 与 UIImageView 的 Category，并且提供了一些方法，在必要时可以自定义。在 Category 中，下载远程图片的实际方法并没有改变。</p>
<p>UIWebView 的 Category 被重构为使用 <code>AFHTTPSessionManager</code> 作为其网络请求。</p>
<h3 id="UIAlertView_的_Category_被废弃">UIAlertView 的 Category 被废弃</h3><p>从 AFNetworking 3.0 后 <code>UIAlertView</code> 的 Category 因过时而被废弃。并且没有提供  <code>UIAlertController</code> Category 的计划，因为这是应用程序应处理的逻辑，而不是这个库。</p>
<hr>
<h2 id="补充">补充</h2><p>如果你对 AFNetworking 2.0 的实现细节感兴趣，在这里推荐大神 bang 的源码分析：<a href="http://blog.cnbang.net/tech/2320/" target="_blank" rel="external">AFNetworking2.0源码解析</a></p>
<p>在接下来的文章中，我们将正式开始 3.0 的探索：D</p>
<hr>
<h2 id="参考">参考</h2><ul>
<li><a href="https://github.com/AFNetworking/AFNetworking/wiki/AFNetworking-3.0-Migration-Guide#new-requirements-ios-7-mac-os-x-109-watchos-2-tvos-9--xcode-7" target="_blank" rel="external">AFNetworking 3.0 Migration Guide</a></li>
<li><a href="https://skyline75489.github.io/post/2016-3-13_ios_networking_layer_design.html" target="_blank" rel="external">浅析 iOS 应用网络层设计</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>在完成 <a href="https://github.com/rs/SDWebImage">SDWebImage</a> 的源码阅读后（可参见系列文章：<a href="http://itangqi.me/2016/03/19/the-notes-of-learning-sdwebimage-one/">SDWebImage 源码阅读笔记</a>），我又将目光瞄向了大名鼎鼎的网络库 <a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>，不过为了能保证源码阅读的流畅性，不至于到时一脸懵逼，在正式开始之前，我又恶补了下网络相关的知识，可参见相关文章：<a href="http://itangqi.me/2016/04/01/from-nsurlconnection-to-nsurlsession/">从 NSURLConnection 到 NSURLSession</a> 与<a href="http://itangqi.me/2016/04/04/the-notes-of-learning-illustrating-http-one/">《图解 HTTP》读书笔记</a>。</p>
<p>好啦，似乎万事具备，就让我们扬帆起航，开启 AFNetworking 源码阅读之旅吧！</p>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://itangqi.me/tags/AFNetworking/"/>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="Source Code" scheme="http://itangqi.me/tags/Source-Code/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UICollectionView 学习笔记]]></title>
    <link href="http://itangqi.me/2016/04/21/the-notes-of-learning-uicollectionview/"/>
    <id>http://itangqi.me/2016/04/21/the-notes-of-learning-uicollectionview/</id>
    <published>2016-04-20T16:00:00.000Z</published>
    <updated>2016-05-28T03:47:40.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近计划着开个新项目，前期工作准备先撸个图片选择器出来。当然核心肯定是 PhotoKit (ASsetsLibrary) 啦，不过那些会在稍后文章中介绍，今天的主角则是 <strong>UICollectionView</strong>。</p>
<a id="more"></a> 
<hr>
<h2 id="简介">简介</h2><p>首先看苹果官方文档 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionView_class/" target="_blank" rel="external">UICollectionView Class Reference</a> 的介绍:</p>
<blockquote>
<p>The UICollectionView class manages an ordered collection of data items and presents them using customizable layouts. Collection views provide the same general function as table views except that a collection view is able to support more than just single-column layouts. Collection views support customizable layouts that can be used to implement multi-column grids, tiled layouts, circular layouts, and many more. You can even change the layout of a collection view dynamically if you want.</p>
</blockquote>
<p>一句话总结就是：<strong>UICollectionView 与 UITableView 相似，却提供了可自定义多列网格（Grild）的功能。</strong></p>
<hr>
<h2 id="核心">核心</h2><ul>
<li><p><strong>Cells</strong>：单元格，用于展示内容的主体</p>
</li>
<li><p><strong>Supplementary Views</strong>：追加视图，相当于 UITableView 中每个 Section 的 Header 或 Footer</p>
</li>
<li><p><strong>Decoration Views</strong>：装饰视图，用于装饰整个 UICollectionView</p>
</li>
</ul>
<p>UICollectionView 最常见的使用场景，想必就是相册（照片墙）的实现与展示了，下面通过一张图来直观地认识 CollectionView 各部分的构成：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-001.png" alt=""></p>
<hr>
<h2 id="实现">实现</h2><p>如果你在之前有了解及使用过 UITableView 的话，那么恭喜你，你将会快速上手 UICollectionView。</p>
<h3 id="UICollectionViewDataSource">UICollectionViewDataSource</h3><p>UICollectionViewDataSource - 负责提供展示的数据，实现下面两个必须的委托方法，其实 UITableView 并无二意，所以在此不做过多介绍了。</p>
<ul>
<li><p><strong>numberOfItemsInSection</strong>：某个 section 里有多少个 item</p>
</li>
<li><p><strong>cellForItemAtIndexPath</strong>：对于某个位置应该显示什么样的 cell，里面会涉及到 cell 的复用，可参见 TableView</p>
</li>
</ul>
<p>其实到这里，CollectionView 就可以正常显示了，对吧，就是这么简单：）</p>
<h3 id="UICollectionViewDelegate">UICollectionViewDelegate</h3><p>UICollectionViewDelegate - 负责用户的交互、Cell 的外形，委托方法和 TableView 相似，可以选择性实现以下委托方法。</p>
<ul>
<li><p><strong>collectionView:shouldHighlightItemAtIndexPath</strong>：是否支持高亮？</p>
</li>
<li><p><strong>collectionView:didHighlightItemAtIndexPath</strong>：如果支持高亮，那么高亮；</p>
</li>
<li><p><strong>collectionView:shouldSelectItemAtIndexPath</strong>：询问是否可以被选中？</p>
</li>
<li><p><strong>collectionView:didUnhighlightItemAtIndexPath</strong>：如果支持高亮，那么现在取消高亮；</p>
</li>
<li><p><strong>collectionView:didSelectItemAtIndexPath</strong>：如果支持可以被选中，那么选中 cell；</p>
</li>
</ul>
<p>下面再通过几张图来更加清晰地理解：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-002.jpg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-003.jpg" alt=""><br><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-004.jpg" alt=""></p>
<h3 id="UICollectionViewLayout">UICollectionViewLayout</h3><p>在布局上，与 UITableView 直接使用系统提供的样式不同，UICollectionView 使用的是 UICollectionViewLayout 来自定义布局样式。</p>
<p>在苹果官方文档：<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/" target="_blank" rel="external">UICollectionViewLayout Class Reference</a> 中对其做了如下解释:</p>
<blockquote>
<p>The UICollectionViewLayout class is an abstract base class that you subclass and use to generate layout information for a collection view. The job of a layout object is to determine the placement of cells, supplementary views, and decoration views inside the collection view’s bounds and to report that information to the collection view when asked. The collection view then applies the provided layout information to the corresponding views so that they can be presented onscreen.</p>
</blockquote>
<p>这里做下简短的总结：</p>
<ol>
<li><p>UICollectionViewLayout 是一个抽象基类，你需要继承自他，来为 CollectionView 生成 Layout 信息。Layout 对象的作用是决定 Cells，Supplementary Views 和 Decoration Views 在 CollectionView 中的布局位置。当然啦，如果你不想折腾，苹果也贴心的为你准备了 UICollectionViewFlowLayout - 流水式布局效果。</p>
</li>
<li><p>UICollectionView 的显示效果几乎全部由 UICollectionViewLayout 负责，而真正存储着每一个 Cell 的位置、大小等属性的是 UICollectionViewLayoutAttributes 。每一个 Cell 对应着一个属于自己的 UICollectionViewLayoutAttributes，而 UICollectionViewLayout 正是利用 UICollectionViewLayoutAttributes 里存在的信息对每一个 Cell 进行布局。</p>
</li>
</ol>
<p>下面通过一张图来了解 UICollectionView 的构成：</p>
<p><img src="http://7xikfc.com1.z0.glb.clouddn.com/the-notes-of-learning-uicollectionview-005.jpg" alt=""></p>
<h2 id="总结">总结</h2><p>可以说 UICollectionView 是 iOS 开发中必不可少的 UIKit 控件之一。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionView_class/" target="_blank" rel="external">UICollectionView Class Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/" target="_blank" rel="external">UICollectionViewLayout Class Reference</a></li>
<li><a href="http://www.appcoda.com/ios-programming-uicollectionview-tutorial/" target="_blank" rel="external">Create Grid Layout Using UICollectionView in iOS 6</a></li>
<li><a href="http://my.oschina.net/sunqichao/blog/182623" target="_blank" rel="external">UICollectionView 使用 介绍</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>最近计划着开个新项目，前期工作准备先撸个图片选择器出来。当然核心肯定是 PhotoKit (ASsetsLibrary) 啦，不过那些会在稍后文章中介绍，今天的主角则是 <strong>UICollectionView</strong>。</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://itangqi.me/tags/Notes/"/>
    
      <category term="UICollectionView" scheme="http://itangqi.me/tags/UICollectionView/"/>
    
      <category term="iOS" scheme="http://itangqi.me/categories/iOS/"/>
    
  </entry>
  
</feed>
